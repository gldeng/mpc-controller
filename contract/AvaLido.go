// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package contract

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// UnstakeRequest is an auto generated low-level Go binding around an user-defined struct.
type UnstakeRequest struct {
	Requester       common.Address
	RequestedAt     uint64
	AmountRequested *big.Int
	AmountFilled    *big.Int
	AmountClaimed   *big.Int
	StAVAXLocked    *big.Int
}

// AccessControlMetaData contains all meta data concerning the AccessControl contract.
var AccessControlMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"a217fddf": "DEFAULT_ADMIN_ROLE()",
		"248a9ca3": "getRoleAdmin(bytes32)",
		"2f2ff15d": "grantRole(bytes32,address)",
		"91d14854": "hasRole(bytes32,address)",
		"36568abe": "renounceRole(bytes32,address)",
		"d547741f": "revokeRole(bytes32,address)",
		"01ffc9a7": "supportsInterface(bytes4)",
	},
}

// AccessControlABI is the input ABI used to generate the binding from.
// Deprecated: Use AccessControlMetaData.ABI instead.
var AccessControlABI = AccessControlMetaData.ABI

// Deprecated: Use AccessControlMetaData.Sigs instead.
// AccessControlFuncSigs maps the 4-byte function signature to its string representation.
var AccessControlFuncSigs = AccessControlMetaData.Sigs

// AccessControl is an auto generated Go binding around an Ethereum contract.
type AccessControl struct {
	AccessControlCaller     // Read-only binding to the contract
	AccessControlTransactor // Write-only binding to the contract
	AccessControlFilterer   // Log filterer for contract events
}

// AccessControlCaller is an auto generated read-only Go binding around an Ethereum contract.
type AccessControlCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AccessControlTransactor is an auto generated write-only Go binding around an Ethereum contract.
type AccessControlTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AccessControlFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type AccessControlFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AccessControlSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type AccessControlSession struct {
	Contract     *AccessControl    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// AccessControlCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type AccessControlCallerSession struct {
	Contract *AccessControlCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// AccessControlTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type AccessControlTransactorSession struct {
	Contract     *AccessControlTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// AccessControlRaw is an auto generated low-level Go binding around an Ethereum contract.
type AccessControlRaw struct {
	Contract *AccessControl // Generic contract binding to access the raw methods on
}

// AccessControlCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type AccessControlCallerRaw struct {
	Contract *AccessControlCaller // Generic read-only contract binding to access the raw methods on
}

// AccessControlTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type AccessControlTransactorRaw struct {
	Contract *AccessControlTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAccessControl creates a new instance of AccessControl, bound to a specific deployed contract.
func NewAccessControl(address common.Address, backend bind.ContractBackend) (*AccessControl, error) {
	contract, err := bindAccessControl(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &AccessControl{AccessControlCaller: AccessControlCaller{contract: contract}, AccessControlTransactor: AccessControlTransactor{contract: contract}, AccessControlFilterer: AccessControlFilterer{contract: contract}}, nil
}

// NewAccessControlCaller creates a new read-only instance of AccessControl, bound to a specific deployed contract.
func NewAccessControlCaller(address common.Address, caller bind.ContractCaller) (*AccessControlCaller, error) {
	contract, err := bindAccessControl(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AccessControlCaller{contract: contract}, nil
}

// NewAccessControlTransactor creates a new write-only instance of AccessControl, bound to a specific deployed contract.
func NewAccessControlTransactor(address common.Address, transactor bind.ContractTransactor) (*AccessControlTransactor, error) {
	contract, err := bindAccessControl(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AccessControlTransactor{contract: contract}, nil
}

// NewAccessControlFilterer creates a new log filterer instance of AccessControl, bound to a specific deployed contract.
func NewAccessControlFilterer(address common.Address, filterer bind.ContractFilterer) (*AccessControlFilterer, error) {
	contract, err := bindAccessControl(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AccessControlFilterer{contract: contract}, nil
}

// bindAccessControl binds a generic wrapper to an already deployed contract.
func bindAccessControl(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(AccessControlABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AccessControl *AccessControlRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AccessControl.Contract.AccessControlCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AccessControl *AccessControlRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AccessControl.Contract.AccessControlTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AccessControl *AccessControlRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AccessControl.Contract.AccessControlTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AccessControl *AccessControlCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AccessControl.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AccessControl *AccessControlTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AccessControl.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AccessControl *AccessControlTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AccessControl.Contract.contract.Transact(opts, method, params...)
}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_AccessControl *AccessControlCaller) DEFAULTADMINROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _AccessControl.contract.Call(opts, &out, "DEFAULT_ADMIN_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_AccessControl *AccessControlSession) DEFAULTADMINROLE() ([32]byte, error) {
	return _AccessControl.Contract.DEFAULTADMINROLE(&_AccessControl.CallOpts)
}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_AccessControl *AccessControlCallerSession) DEFAULTADMINROLE() ([32]byte, error) {
	return _AccessControl.Contract.DEFAULTADMINROLE(&_AccessControl.CallOpts)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_AccessControl *AccessControlCaller) GetRoleAdmin(opts *bind.CallOpts, role [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _AccessControl.contract.Call(opts, &out, "getRoleAdmin", role)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_AccessControl *AccessControlSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _AccessControl.Contract.GetRoleAdmin(&_AccessControl.CallOpts, role)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_AccessControl *AccessControlCallerSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _AccessControl.Contract.GetRoleAdmin(&_AccessControl.CallOpts, role)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_AccessControl *AccessControlCaller) HasRole(opts *bind.CallOpts, role [32]byte, account common.Address) (bool, error) {
	var out []interface{}
	err := _AccessControl.contract.Call(opts, &out, "hasRole", role, account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_AccessControl *AccessControlSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _AccessControl.Contract.HasRole(&_AccessControl.CallOpts, role, account)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_AccessControl *AccessControlCallerSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _AccessControl.Contract.HasRole(&_AccessControl.CallOpts, role, account)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_AccessControl *AccessControlCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _AccessControl.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_AccessControl *AccessControlSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _AccessControl.Contract.SupportsInterface(&_AccessControl.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_AccessControl *AccessControlCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _AccessControl.Contract.SupportsInterface(&_AccessControl.CallOpts, interfaceId)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_AccessControl *AccessControlTransactor) GrantRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AccessControl.contract.Transact(opts, "grantRole", role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_AccessControl *AccessControlSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AccessControl.Contract.GrantRole(&_AccessControl.TransactOpts, role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_AccessControl *AccessControlTransactorSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AccessControl.Contract.GrantRole(&_AccessControl.TransactOpts, role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_AccessControl *AccessControlTransactor) RenounceRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AccessControl.contract.Transact(opts, "renounceRole", role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_AccessControl *AccessControlSession) RenounceRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AccessControl.Contract.RenounceRole(&_AccessControl.TransactOpts, role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_AccessControl *AccessControlTransactorSession) RenounceRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AccessControl.Contract.RenounceRole(&_AccessControl.TransactOpts, role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_AccessControl *AccessControlTransactor) RevokeRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AccessControl.contract.Transact(opts, "revokeRole", role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_AccessControl *AccessControlSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AccessControl.Contract.RevokeRole(&_AccessControl.TransactOpts, role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_AccessControl *AccessControlTransactorSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AccessControl.Contract.RevokeRole(&_AccessControl.TransactOpts, role, account)
}

// AccessControlRoleAdminChangedIterator is returned from FilterRoleAdminChanged and is used to iterate over the raw logs and unpacked data for RoleAdminChanged events raised by the AccessControl contract.
type AccessControlRoleAdminChangedIterator struct {
	Event *AccessControlRoleAdminChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AccessControlRoleAdminChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AccessControlRoleAdminChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AccessControlRoleAdminChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AccessControlRoleAdminChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AccessControlRoleAdminChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AccessControlRoleAdminChanged represents a RoleAdminChanged event raised by the AccessControl contract.
type AccessControlRoleAdminChanged struct {
	Role              [32]byte
	PreviousAdminRole [32]byte
	NewAdminRole      [32]byte
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRoleAdminChanged is a free log retrieval operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_AccessControl *AccessControlFilterer) FilterRoleAdminChanged(opts *bind.FilterOpts, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (*AccessControlRoleAdminChangedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _AccessControl.contract.FilterLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return &AccessControlRoleAdminChangedIterator{contract: _AccessControl.contract, event: "RoleAdminChanged", logs: logs, sub: sub}, nil
}

// WatchRoleAdminChanged is a free log subscription operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_AccessControl *AccessControlFilterer) WatchRoleAdminChanged(opts *bind.WatchOpts, sink chan<- *AccessControlRoleAdminChanged, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _AccessControl.contract.WatchLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AccessControlRoleAdminChanged)
				if err := _AccessControl.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleAdminChanged is a log parse operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_AccessControl *AccessControlFilterer) ParseRoleAdminChanged(log types.Log) (*AccessControlRoleAdminChanged, error) {
	event := new(AccessControlRoleAdminChanged)
	if err := _AccessControl.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AccessControlRoleGrantedIterator is returned from FilterRoleGranted and is used to iterate over the raw logs and unpacked data for RoleGranted events raised by the AccessControl contract.
type AccessControlRoleGrantedIterator struct {
	Event *AccessControlRoleGranted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AccessControlRoleGrantedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AccessControlRoleGranted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AccessControlRoleGranted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AccessControlRoleGrantedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AccessControlRoleGrantedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AccessControlRoleGranted represents a RoleGranted event raised by the AccessControl contract.
type AccessControlRoleGranted struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleGranted is a free log retrieval operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_AccessControl *AccessControlFilterer) FilterRoleGranted(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*AccessControlRoleGrantedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _AccessControl.contract.FilterLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &AccessControlRoleGrantedIterator{contract: _AccessControl.contract, event: "RoleGranted", logs: logs, sub: sub}, nil
}

// WatchRoleGranted is a free log subscription operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_AccessControl *AccessControlFilterer) WatchRoleGranted(opts *bind.WatchOpts, sink chan<- *AccessControlRoleGranted, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _AccessControl.contract.WatchLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AccessControlRoleGranted)
				if err := _AccessControl.contract.UnpackLog(event, "RoleGranted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleGranted is a log parse operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_AccessControl *AccessControlFilterer) ParseRoleGranted(log types.Log) (*AccessControlRoleGranted, error) {
	event := new(AccessControlRoleGranted)
	if err := _AccessControl.contract.UnpackLog(event, "RoleGranted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AccessControlRoleRevokedIterator is returned from FilterRoleRevoked and is used to iterate over the raw logs and unpacked data for RoleRevoked events raised by the AccessControl contract.
type AccessControlRoleRevokedIterator struct {
	Event *AccessControlRoleRevoked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AccessControlRoleRevokedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AccessControlRoleRevoked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AccessControlRoleRevoked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AccessControlRoleRevokedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AccessControlRoleRevokedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AccessControlRoleRevoked represents a RoleRevoked event raised by the AccessControl contract.
type AccessControlRoleRevoked struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleRevoked is a free log retrieval operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_AccessControl *AccessControlFilterer) FilterRoleRevoked(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*AccessControlRoleRevokedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _AccessControl.contract.FilterLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &AccessControlRoleRevokedIterator{contract: _AccessControl.contract, event: "RoleRevoked", logs: logs, sub: sub}, nil
}

// WatchRoleRevoked is a free log subscription operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_AccessControl *AccessControlFilterer) WatchRoleRevoked(opts *bind.WatchOpts, sink chan<- *AccessControlRoleRevoked, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _AccessControl.contract.WatchLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AccessControlRoleRevoked)
				if err := _AccessControl.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleRevoked is a log parse operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_AccessControl *AccessControlFilterer) ParseRoleRevoked(log types.Log) (*AccessControlRoleRevoked, error) {
	event := new(AccessControlRoleRevoked)
	if err := _AccessControl.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AccessControlEnumerableMetaData contains all meta data concerning the AccessControlEnumerable contract.
var AccessControlEnumerableMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"a217fddf": "DEFAULT_ADMIN_ROLE()",
		"248a9ca3": "getRoleAdmin(bytes32)",
		"9010d07c": "getRoleMember(bytes32,uint256)",
		"ca15c873": "getRoleMemberCount(bytes32)",
		"2f2ff15d": "grantRole(bytes32,address)",
		"91d14854": "hasRole(bytes32,address)",
		"36568abe": "renounceRole(bytes32,address)",
		"d547741f": "revokeRole(bytes32,address)",
		"01ffc9a7": "supportsInterface(bytes4)",
	},
}

// AccessControlEnumerableABI is the input ABI used to generate the binding from.
// Deprecated: Use AccessControlEnumerableMetaData.ABI instead.
var AccessControlEnumerableABI = AccessControlEnumerableMetaData.ABI

// Deprecated: Use AccessControlEnumerableMetaData.Sigs instead.
// AccessControlEnumerableFuncSigs maps the 4-byte function signature to its string representation.
var AccessControlEnumerableFuncSigs = AccessControlEnumerableMetaData.Sigs

// AccessControlEnumerable is an auto generated Go binding around an Ethereum contract.
type AccessControlEnumerable struct {
	AccessControlEnumerableCaller     // Read-only binding to the contract
	AccessControlEnumerableTransactor // Write-only binding to the contract
	AccessControlEnumerableFilterer   // Log filterer for contract events
}

// AccessControlEnumerableCaller is an auto generated read-only Go binding around an Ethereum contract.
type AccessControlEnumerableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AccessControlEnumerableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type AccessControlEnumerableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AccessControlEnumerableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type AccessControlEnumerableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AccessControlEnumerableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type AccessControlEnumerableSession struct {
	Contract     *AccessControlEnumerable // Generic contract binding to set the session for
	CallOpts     bind.CallOpts            // Call options to use throughout this session
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// AccessControlEnumerableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type AccessControlEnumerableCallerSession struct {
	Contract *AccessControlEnumerableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                  // Call options to use throughout this session
}

// AccessControlEnumerableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type AccessControlEnumerableTransactorSession struct {
	Contract     *AccessControlEnumerableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                  // Transaction auth options to use throughout this session
}

// AccessControlEnumerableRaw is an auto generated low-level Go binding around an Ethereum contract.
type AccessControlEnumerableRaw struct {
	Contract *AccessControlEnumerable // Generic contract binding to access the raw methods on
}

// AccessControlEnumerableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type AccessControlEnumerableCallerRaw struct {
	Contract *AccessControlEnumerableCaller // Generic read-only contract binding to access the raw methods on
}

// AccessControlEnumerableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type AccessControlEnumerableTransactorRaw struct {
	Contract *AccessControlEnumerableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAccessControlEnumerable creates a new instance of AccessControlEnumerable, bound to a specific deployed contract.
func NewAccessControlEnumerable(address common.Address, backend bind.ContractBackend) (*AccessControlEnumerable, error) {
	contract, err := bindAccessControlEnumerable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &AccessControlEnumerable{AccessControlEnumerableCaller: AccessControlEnumerableCaller{contract: contract}, AccessControlEnumerableTransactor: AccessControlEnumerableTransactor{contract: contract}, AccessControlEnumerableFilterer: AccessControlEnumerableFilterer{contract: contract}}, nil
}

// NewAccessControlEnumerableCaller creates a new read-only instance of AccessControlEnumerable, bound to a specific deployed contract.
func NewAccessControlEnumerableCaller(address common.Address, caller bind.ContractCaller) (*AccessControlEnumerableCaller, error) {
	contract, err := bindAccessControlEnumerable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AccessControlEnumerableCaller{contract: contract}, nil
}

// NewAccessControlEnumerableTransactor creates a new write-only instance of AccessControlEnumerable, bound to a specific deployed contract.
func NewAccessControlEnumerableTransactor(address common.Address, transactor bind.ContractTransactor) (*AccessControlEnumerableTransactor, error) {
	contract, err := bindAccessControlEnumerable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AccessControlEnumerableTransactor{contract: contract}, nil
}

// NewAccessControlEnumerableFilterer creates a new log filterer instance of AccessControlEnumerable, bound to a specific deployed contract.
func NewAccessControlEnumerableFilterer(address common.Address, filterer bind.ContractFilterer) (*AccessControlEnumerableFilterer, error) {
	contract, err := bindAccessControlEnumerable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AccessControlEnumerableFilterer{contract: contract}, nil
}

// bindAccessControlEnumerable binds a generic wrapper to an already deployed contract.
func bindAccessControlEnumerable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(AccessControlEnumerableABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AccessControlEnumerable *AccessControlEnumerableRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AccessControlEnumerable.Contract.AccessControlEnumerableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AccessControlEnumerable *AccessControlEnumerableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AccessControlEnumerable.Contract.AccessControlEnumerableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AccessControlEnumerable *AccessControlEnumerableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AccessControlEnumerable.Contract.AccessControlEnumerableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AccessControlEnumerable *AccessControlEnumerableCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AccessControlEnumerable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AccessControlEnumerable *AccessControlEnumerableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AccessControlEnumerable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AccessControlEnumerable *AccessControlEnumerableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AccessControlEnumerable.Contract.contract.Transact(opts, method, params...)
}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_AccessControlEnumerable *AccessControlEnumerableCaller) DEFAULTADMINROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _AccessControlEnumerable.contract.Call(opts, &out, "DEFAULT_ADMIN_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_AccessControlEnumerable *AccessControlEnumerableSession) DEFAULTADMINROLE() ([32]byte, error) {
	return _AccessControlEnumerable.Contract.DEFAULTADMINROLE(&_AccessControlEnumerable.CallOpts)
}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_AccessControlEnumerable *AccessControlEnumerableCallerSession) DEFAULTADMINROLE() ([32]byte, error) {
	return _AccessControlEnumerable.Contract.DEFAULTADMINROLE(&_AccessControlEnumerable.CallOpts)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_AccessControlEnumerable *AccessControlEnumerableCaller) GetRoleAdmin(opts *bind.CallOpts, role [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _AccessControlEnumerable.contract.Call(opts, &out, "getRoleAdmin", role)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_AccessControlEnumerable *AccessControlEnumerableSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _AccessControlEnumerable.Contract.GetRoleAdmin(&_AccessControlEnumerable.CallOpts, role)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_AccessControlEnumerable *AccessControlEnumerableCallerSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _AccessControlEnumerable.Contract.GetRoleAdmin(&_AccessControlEnumerable.CallOpts, role)
}

// GetRoleMember is a free data retrieval call binding the contract method 0x9010d07c.
//
// Solidity: function getRoleMember(bytes32 role, uint256 index) view returns(address)
func (_AccessControlEnumerable *AccessControlEnumerableCaller) GetRoleMember(opts *bind.CallOpts, role [32]byte, index *big.Int) (common.Address, error) {
	var out []interface{}
	err := _AccessControlEnumerable.contract.Call(opts, &out, "getRoleMember", role, index)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetRoleMember is a free data retrieval call binding the contract method 0x9010d07c.
//
// Solidity: function getRoleMember(bytes32 role, uint256 index) view returns(address)
func (_AccessControlEnumerable *AccessControlEnumerableSession) GetRoleMember(role [32]byte, index *big.Int) (common.Address, error) {
	return _AccessControlEnumerable.Contract.GetRoleMember(&_AccessControlEnumerable.CallOpts, role, index)
}

// GetRoleMember is a free data retrieval call binding the contract method 0x9010d07c.
//
// Solidity: function getRoleMember(bytes32 role, uint256 index) view returns(address)
func (_AccessControlEnumerable *AccessControlEnumerableCallerSession) GetRoleMember(role [32]byte, index *big.Int) (common.Address, error) {
	return _AccessControlEnumerable.Contract.GetRoleMember(&_AccessControlEnumerable.CallOpts, role, index)
}

// GetRoleMemberCount is a free data retrieval call binding the contract method 0xca15c873.
//
// Solidity: function getRoleMemberCount(bytes32 role) view returns(uint256)
func (_AccessControlEnumerable *AccessControlEnumerableCaller) GetRoleMemberCount(opts *bind.CallOpts, role [32]byte) (*big.Int, error) {
	var out []interface{}
	err := _AccessControlEnumerable.contract.Call(opts, &out, "getRoleMemberCount", role)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetRoleMemberCount is a free data retrieval call binding the contract method 0xca15c873.
//
// Solidity: function getRoleMemberCount(bytes32 role) view returns(uint256)
func (_AccessControlEnumerable *AccessControlEnumerableSession) GetRoleMemberCount(role [32]byte) (*big.Int, error) {
	return _AccessControlEnumerable.Contract.GetRoleMemberCount(&_AccessControlEnumerable.CallOpts, role)
}

// GetRoleMemberCount is a free data retrieval call binding the contract method 0xca15c873.
//
// Solidity: function getRoleMemberCount(bytes32 role) view returns(uint256)
func (_AccessControlEnumerable *AccessControlEnumerableCallerSession) GetRoleMemberCount(role [32]byte) (*big.Int, error) {
	return _AccessControlEnumerable.Contract.GetRoleMemberCount(&_AccessControlEnumerable.CallOpts, role)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_AccessControlEnumerable *AccessControlEnumerableCaller) HasRole(opts *bind.CallOpts, role [32]byte, account common.Address) (bool, error) {
	var out []interface{}
	err := _AccessControlEnumerable.contract.Call(opts, &out, "hasRole", role, account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_AccessControlEnumerable *AccessControlEnumerableSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _AccessControlEnumerable.Contract.HasRole(&_AccessControlEnumerable.CallOpts, role, account)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_AccessControlEnumerable *AccessControlEnumerableCallerSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _AccessControlEnumerable.Contract.HasRole(&_AccessControlEnumerable.CallOpts, role, account)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_AccessControlEnumerable *AccessControlEnumerableCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _AccessControlEnumerable.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_AccessControlEnumerable *AccessControlEnumerableSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _AccessControlEnumerable.Contract.SupportsInterface(&_AccessControlEnumerable.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_AccessControlEnumerable *AccessControlEnumerableCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _AccessControlEnumerable.Contract.SupportsInterface(&_AccessControlEnumerable.CallOpts, interfaceId)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_AccessControlEnumerable *AccessControlEnumerableTransactor) GrantRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AccessControlEnumerable.contract.Transact(opts, "grantRole", role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_AccessControlEnumerable *AccessControlEnumerableSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AccessControlEnumerable.Contract.GrantRole(&_AccessControlEnumerable.TransactOpts, role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_AccessControlEnumerable *AccessControlEnumerableTransactorSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AccessControlEnumerable.Contract.GrantRole(&_AccessControlEnumerable.TransactOpts, role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_AccessControlEnumerable *AccessControlEnumerableTransactor) RenounceRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AccessControlEnumerable.contract.Transact(opts, "renounceRole", role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_AccessControlEnumerable *AccessControlEnumerableSession) RenounceRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AccessControlEnumerable.Contract.RenounceRole(&_AccessControlEnumerable.TransactOpts, role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_AccessControlEnumerable *AccessControlEnumerableTransactorSession) RenounceRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AccessControlEnumerable.Contract.RenounceRole(&_AccessControlEnumerable.TransactOpts, role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_AccessControlEnumerable *AccessControlEnumerableTransactor) RevokeRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AccessControlEnumerable.contract.Transact(opts, "revokeRole", role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_AccessControlEnumerable *AccessControlEnumerableSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AccessControlEnumerable.Contract.RevokeRole(&_AccessControlEnumerable.TransactOpts, role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_AccessControlEnumerable *AccessControlEnumerableTransactorSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AccessControlEnumerable.Contract.RevokeRole(&_AccessControlEnumerable.TransactOpts, role, account)
}

// AccessControlEnumerableRoleAdminChangedIterator is returned from FilterRoleAdminChanged and is used to iterate over the raw logs and unpacked data for RoleAdminChanged events raised by the AccessControlEnumerable contract.
type AccessControlEnumerableRoleAdminChangedIterator struct {
	Event *AccessControlEnumerableRoleAdminChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AccessControlEnumerableRoleAdminChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AccessControlEnumerableRoleAdminChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AccessControlEnumerableRoleAdminChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AccessControlEnumerableRoleAdminChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AccessControlEnumerableRoleAdminChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AccessControlEnumerableRoleAdminChanged represents a RoleAdminChanged event raised by the AccessControlEnumerable contract.
type AccessControlEnumerableRoleAdminChanged struct {
	Role              [32]byte
	PreviousAdminRole [32]byte
	NewAdminRole      [32]byte
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRoleAdminChanged is a free log retrieval operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_AccessControlEnumerable *AccessControlEnumerableFilterer) FilterRoleAdminChanged(opts *bind.FilterOpts, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (*AccessControlEnumerableRoleAdminChangedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _AccessControlEnumerable.contract.FilterLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return &AccessControlEnumerableRoleAdminChangedIterator{contract: _AccessControlEnumerable.contract, event: "RoleAdminChanged", logs: logs, sub: sub}, nil
}

// WatchRoleAdminChanged is a free log subscription operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_AccessControlEnumerable *AccessControlEnumerableFilterer) WatchRoleAdminChanged(opts *bind.WatchOpts, sink chan<- *AccessControlEnumerableRoleAdminChanged, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _AccessControlEnumerable.contract.WatchLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AccessControlEnumerableRoleAdminChanged)
				if err := _AccessControlEnumerable.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleAdminChanged is a log parse operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_AccessControlEnumerable *AccessControlEnumerableFilterer) ParseRoleAdminChanged(log types.Log) (*AccessControlEnumerableRoleAdminChanged, error) {
	event := new(AccessControlEnumerableRoleAdminChanged)
	if err := _AccessControlEnumerable.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AccessControlEnumerableRoleGrantedIterator is returned from FilterRoleGranted and is used to iterate over the raw logs and unpacked data for RoleGranted events raised by the AccessControlEnumerable contract.
type AccessControlEnumerableRoleGrantedIterator struct {
	Event *AccessControlEnumerableRoleGranted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AccessControlEnumerableRoleGrantedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AccessControlEnumerableRoleGranted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AccessControlEnumerableRoleGranted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AccessControlEnumerableRoleGrantedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AccessControlEnumerableRoleGrantedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AccessControlEnumerableRoleGranted represents a RoleGranted event raised by the AccessControlEnumerable contract.
type AccessControlEnumerableRoleGranted struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleGranted is a free log retrieval operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_AccessControlEnumerable *AccessControlEnumerableFilterer) FilterRoleGranted(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*AccessControlEnumerableRoleGrantedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _AccessControlEnumerable.contract.FilterLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &AccessControlEnumerableRoleGrantedIterator{contract: _AccessControlEnumerable.contract, event: "RoleGranted", logs: logs, sub: sub}, nil
}

// WatchRoleGranted is a free log subscription operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_AccessControlEnumerable *AccessControlEnumerableFilterer) WatchRoleGranted(opts *bind.WatchOpts, sink chan<- *AccessControlEnumerableRoleGranted, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _AccessControlEnumerable.contract.WatchLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AccessControlEnumerableRoleGranted)
				if err := _AccessControlEnumerable.contract.UnpackLog(event, "RoleGranted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleGranted is a log parse operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_AccessControlEnumerable *AccessControlEnumerableFilterer) ParseRoleGranted(log types.Log) (*AccessControlEnumerableRoleGranted, error) {
	event := new(AccessControlEnumerableRoleGranted)
	if err := _AccessControlEnumerable.contract.UnpackLog(event, "RoleGranted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AccessControlEnumerableRoleRevokedIterator is returned from FilterRoleRevoked and is used to iterate over the raw logs and unpacked data for RoleRevoked events raised by the AccessControlEnumerable contract.
type AccessControlEnumerableRoleRevokedIterator struct {
	Event *AccessControlEnumerableRoleRevoked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AccessControlEnumerableRoleRevokedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AccessControlEnumerableRoleRevoked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AccessControlEnumerableRoleRevoked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AccessControlEnumerableRoleRevokedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AccessControlEnumerableRoleRevokedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AccessControlEnumerableRoleRevoked represents a RoleRevoked event raised by the AccessControlEnumerable contract.
type AccessControlEnumerableRoleRevoked struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleRevoked is a free log retrieval operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_AccessControlEnumerable *AccessControlEnumerableFilterer) FilterRoleRevoked(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*AccessControlEnumerableRoleRevokedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _AccessControlEnumerable.contract.FilterLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &AccessControlEnumerableRoleRevokedIterator{contract: _AccessControlEnumerable.contract, event: "RoleRevoked", logs: logs, sub: sub}, nil
}

// WatchRoleRevoked is a free log subscription operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_AccessControlEnumerable *AccessControlEnumerableFilterer) WatchRoleRevoked(opts *bind.WatchOpts, sink chan<- *AccessControlEnumerableRoleRevoked, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _AccessControlEnumerable.contract.WatchLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AccessControlEnumerableRoleRevoked)
				if err := _AccessControlEnumerable.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleRevoked is a log parse operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_AccessControlEnumerable *AccessControlEnumerableFilterer) ParseRoleRevoked(log types.Log) (*AccessControlEnumerableRoleRevoked, error) {
	event := new(AccessControlEnumerableRoleRevoked)
	if err := _AccessControlEnumerable.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AddressMetaData contains all meta data concerning the Address contract.
var AddressMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c67276011fbbd766e3659d6c8805f6ea0298f574624be0044bf6a894246192af64736f6c634300080a0033",
}

// AddressABI is the input ABI used to generate the binding from.
// Deprecated: Use AddressMetaData.ABI instead.
var AddressABI = AddressMetaData.ABI

// AddressBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use AddressMetaData.Bin instead.
var AddressBin = AddressMetaData.Bin

// DeployAddress deploys a new Ethereum contract, binding an instance of Address to it.
func DeployAddress(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Address, error) {
	parsed, err := AddressMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(AddressBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Address{AddressCaller: AddressCaller{contract: contract}, AddressTransactor: AddressTransactor{contract: contract}, AddressFilterer: AddressFilterer{contract: contract}}, nil
}

// Address is an auto generated Go binding around an Ethereum contract.
type Address struct {
	AddressCaller     // Read-only binding to the contract
	AddressTransactor // Write-only binding to the contract
	AddressFilterer   // Log filterer for contract events
}

// AddressCaller is an auto generated read-only Go binding around an Ethereum contract.
type AddressCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AddressTransactor is an auto generated write-only Go binding around an Ethereum contract.
type AddressTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AddressFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type AddressFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AddressSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type AddressSession struct {
	Contract     *Address          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// AddressCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type AddressCallerSession struct {
	Contract *AddressCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// AddressTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type AddressTransactorSession struct {
	Contract     *AddressTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// AddressRaw is an auto generated low-level Go binding around an Ethereum contract.
type AddressRaw struct {
	Contract *Address // Generic contract binding to access the raw methods on
}

// AddressCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type AddressCallerRaw struct {
	Contract *AddressCaller // Generic read-only contract binding to access the raw methods on
}

// AddressTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type AddressTransactorRaw struct {
	Contract *AddressTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAddress creates a new instance of Address, bound to a specific deployed contract.
func NewAddress(address common.Address, backend bind.ContractBackend) (*Address, error) {
	contract, err := bindAddress(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Address{AddressCaller: AddressCaller{contract: contract}, AddressTransactor: AddressTransactor{contract: contract}, AddressFilterer: AddressFilterer{contract: contract}}, nil
}

// NewAddressCaller creates a new read-only instance of Address, bound to a specific deployed contract.
func NewAddressCaller(address common.Address, caller bind.ContractCaller) (*AddressCaller, error) {
	contract, err := bindAddress(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AddressCaller{contract: contract}, nil
}

// NewAddressTransactor creates a new write-only instance of Address, bound to a specific deployed contract.
func NewAddressTransactor(address common.Address, transactor bind.ContractTransactor) (*AddressTransactor, error) {
	contract, err := bindAddress(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AddressTransactor{contract: contract}, nil
}

// NewAddressFilterer creates a new log filterer instance of Address, bound to a specific deployed contract.
func NewAddressFilterer(address common.Address, filterer bind.ContractFilterer) (*AddressFilterer, error) {
	contract, err := bindAddress(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AddressFilterer{contract: contract}, nil
}

// bindAddress binds a generic wrapper to an already deployed contract.
func bindAddress(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(AddressABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Address *AddressRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Address.Contract.AddressCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Address *AddressRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Address.Contract.AddressTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Address *AddressRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Address.Contract.AddressTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Address *AddressCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Address.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Address *AddressTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Address.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Address *AddressTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Address.Contract.contract.Transact(opts, method, params...)
}

// AddressUpgradeableMetaData contains all meta data concerning the AddressUpgradeable contract.
var AddressUpgradeableMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212207c13578e9f24e8512736bdab752f45e0b9a3817a8772aeab7f927c8ab669fc8164736f6c634300080a0033",
}

// AddressUpgradeableABI is the input ABI used to generate the binding from.
// Deprecated: Use AddressUpgradeableMetaData.ABI instead.
var AddressUpgradeableABI = AddressUpgradeableMetaData.ABI

// AddressUpgradeableBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use AddressUpgradeableMetaData.Bin instead.
var AddressUpgradeableBin = AddressUpgradeableMetaData.Bin

// DeployAddressUpgradeable deploys a new Ethereum contract, binding an instance of AddressUpgradeable to it.
func DeployAddressUpgradeable(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *AddressUpgradeable, error) {
	parsed, err := AddressUpgradeableMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(AddressUpgradeableBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &AddressUpgradeable{AddressUpgradeableCaller: AddressUpgradeableCaller{contract: contract}, AddressUpgradeableTransactor: AddressUpgradeableTransactor{contract: contract}, AddressUpgradeableFilterer: AddressUpgradeableFilterer{contract: contract}}, nil
}

// AddressUpgradeable is an auto generated Go binding around an Ethereum contract.
type AddressUpgradeable struct {
	AddressUpgradeableCaller     // Read-only binding to the contract
	AddressUpgradeableTransactor // Write-only binding to the contract
	AddressUpgradeableFilterer   // Log filterer for contract events
}

// AddressUpgradeableCaller is an auto generated read-only Go binding around an Ethereum contract.
type AddressUpgradeableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AddressUpgradeableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type AddressUpgradeableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AddressUpgradeableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type AddressUpgradeableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AddressUpgradeableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type AddressUpgradeableSession struct {
	Contract     *AddressUpgradeable // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// AddressUpgradeableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type AddressUpgradeableCallerSession struct {
	Contract *AddressUpgradeableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// AddressUpgradeableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type AddressUpgradeableTransactorSession struct {
	Contract     *AddressUpgradeableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// AddressUpgradeableRaw is an auto generated low-level Go binding around an Ethereum contract.
type AddressUpgradeableRaw struct {
	Contract *AddressUpgradeable // Generic contract binding to access the raw methods on
}

// AddressUpgradeableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type AddressUpgradeableCallerRaw struct {
	Contract *AddressUpgradeableCaller // Generic read-only contract binding to access the raw methods on
}

// AddressUpgradeableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type AddressUpgradeableTransactorRaw struct {
	Contract *AddressUpgradeableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAddressUpgradeable creates a new instance of AddressUpgradeable, bound to a specific deployed contract.
func NewAddressUpgradeable(address common.Address, backend bind.ContractBackend) (*AddressUpgradeable, error) {
	contract, err := bindAddressUpgradeable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &AddressUpgradeable{AddressUpgradeableCaller: AddressUpgradeableCaller{contract: contract}, AddressUpgradeableTransactor: AddressUpgradeableTransactor{contract: contract}, AddressUpgradeableFilterer: AddressUpgradeableFilterer{contract: contract}}, nil
}

// NewAddressUpgradeableCaller creates a new read-only instance of AddressUpgradeable, bound to a specific deployed contract.
func NewAddressUpgradeableCaller(address common.Address, caller bind.ContractCaller) (*AddressUpgradeableCaller, error) {
	contract, err := bindAddressUpgradeable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AddressUpgradeableCaller{contract: contract}, nil
}

// NewAddressUpgradeableTransactor creates a new write-only instance of AddressUpgradeable, bound to a specific deployed contract.
func NewAddressUpgradeableTransactor(address common.Address, transactor bind.ContractTransactor) (*AddressUpgradeableTransactor, error) {
	contract, err := bindAddressUpgradeable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AddressUpgradeableTransactor{contract: contract}, nil
}

// NewAddressUpgradeableFilterer creates a new log filterer instance of AddressUpgradeable, bound to a specific deployed contract.
func NewAddressUpgradeableFilterer(address common.Address, filterer bind.ContractFilterer) (*AddressUpgradeableFilterer, error) {
	contract, err := bindAddressUpgradeable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AddressUpgradeableFilterer{contract: contract}, nil
}

// bindAddressUpgradeable binds a generic wrapper to an already deployed contract.
func bindAddressUpgradeable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(AddressUpgradeableABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AddressUpgradeable *AddressUpgradeableRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AddressUpgradeable.Contract.AddressUpgradeableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AddressUpgradeable *AddressUpgradeableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AddressUpgradeable.Contract.AddressUpgradeableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AddressUpgradeable *AddressUpgradeableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AddressUpgradeable.Contract.AddressUpgradeableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AddressUpgradeable *AddressUpgradeableCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AddressUpgradeable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AddressUpgradeable *AddressUpgradeableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AddressUpgradeable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AddressUpgradeable *AddressUpgradeableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AddressUpgradeable.Contract.contract.Transact(opts, method, params...)
}

// AvaLidoMetaData contains all meta data concerning the AvaLido contract.
var AvaLidoMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"ClaimTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStakeAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoAvailableValidators\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProtocolStakedAmountTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooManyConcurrentUnstakeRequests\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"finalClaim\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestIndex\",\"type\":\"uint256\"}],\"name\":\"ClaimEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"DepositEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProtocolFeeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestIndex\",\"type\":\"uint256\"}],\"name\":\"RequestFullyFilledEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fillAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestIndex\",\"type\":\"uint256\"}],\"name\":\"RequestPartiallyFilledEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsCollectedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"avaxAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stAvaxAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestIndex\",\"type\":\"uint256\"}],\"name\":\"WithdrawRequestSubmittedEvent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountPendingAVAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountStakedAVAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalControlled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"avaxAmount\",\"type\":\"uint256\"}],\"name\":\"avaxToStAVAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimUnstakedPrincipals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateAVAXToStAVAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateStAVAXToAVAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lidoFeeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"authorFeeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"validatorSelectorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mpcManagerAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initiateStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxProtocolControlledAVAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxUnstakeRequests\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStakeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStakeBatchAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mpcManager\",\"outputs\":[{\"internalType\":\"contractIMpcManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"principalTreasury\",\"outputs\":[{\"internalType\":\"contractITreasury\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolControlledAVAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeeSplitter\",\"outputs\":[{\"internalType\":\"contractPaymentSplitter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestIndex\",\"type\":\"uint256\"}],\"name\":\"requestByIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"requestedAt\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"amountRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountFilled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stAVAXLocked\",\"type\":\"uint256\"}],\"internalType\":\"structUnstakeRequest\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stAVAXAmount\",\"type\":\"uint256\"}],\"name\":\"requestWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardTreasury\",\"outputs\":[{\"internalType\":\"contractITreasury\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxProtocolControlledAVAX\",\"type\":\"uint256\"}],\"name\":\"setMaxProtocolControlledAVAX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_maxUnstakeRequests\",\"type\":\"uint8\"}],\"name\":\"setMaxUnstakeRequests\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minStakeAmount\",\"type\":\"uint256\"}],\"name\":\"setMinStakeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minStakeBatchAmount\",\"type\":\"uint256\"}],\"name\":\"setMinStakeBatchAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setPrincipalTreasuryAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_protocolFeePercentage\",\"type\":\"uint256\"}],\"name\":\"setProtocolFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"paymentAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"paymentSplit\",\"type\":\"uint256[]\"}],\"name\":\"setProtocolFeeSplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setRewardTreasuryAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakePeriod\",\"type\":\"uint256\"}],\"name\":\"setStakePeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalControlled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stAvaxAmount\",\"type\":\"uint256\"}],\"name\":\"stAVAXToAVAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"unstakeRequestCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unstakeRequests\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"requestedAt\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"amountRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountFilled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stAVAXLocked\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatorSelector\",\"outputs\":[{\"internalType\":\"contractIValidatorSelector\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"a217fddf": "DEFAULT_ADMIN_ROLE()",
		"dd62ed3e": "allowance(address,address)",
		"7e1f1bfb": "amountPendingAVAX()",
		"873dfe34": "amountStakedAVAX()",
		"095ea7b3": "approve(address,uint256)",
		"85990de5": "avaxToStAVAX(uint256,uint256)",
		"70a08231": "balanceOf(address)",
		"c3490263": "claim(uint256,uint256)",
		"372500ab": "claimRewards()",
		"446ed20b": "claimUnstakedPrincipals()",
		"313ce567": "decimals()",
		"a457c2d7": "decreaseAllowance(address,uint256)",
		"d0e30db0": "deposit()",
		"9f94a9e3": "exchangeRateAVAXToStAVAX()",
		"67300041": "exchangeRateStAVAXToAVAX()",
		"248a9ca3": "getRoleAdmin(bytes32)",
		"9010d07c": "getRoleMember(bytes32,uint256)",
		"ca15c873": "getRoleMemberCount(bytes32)",
		"2f2ff15d": "grantRole(bytes32,address)",
		"91d14854": "hasRole(bytes32,address)",
		"39509351": "increaseAllowance(address,uint256)",
		"f8c8765e": "initialize(address,address,address,address)",
		"db4567d3": "initiateStake()",
		"53524303": "maxProtocolControlledAVAX()",
		"a7602c7e": "maxUnstakeRequests()",
		"f1887684": "minStakeAmount()",
		"ad1497fa": "minStakeBatchAmount()",
		"846b3c8b": "mpcManager()",
		"06fdde03": "name()",
		"8456cb59": "pause()",
		"5c975abb": "paused()",
		"1c0fc3f6": "principalTreasury()",
		"a23b4965": "protocolControlledAVAX()",
		"8e50e509": "protocolFeePercentage()",
		"9d7710a5": "protocolFeeSplitter()",
		"36568abe": "renounceRole(bytes32,address)",
		"3d3da6ef": "requestByIndex(uint256)",
		"9ee679e8": "requestWithdrawal(uint256)",
		"046f7da2": "resume()",
		"d547741f": "revokeRole(bytes32,address)",
		"c7c934a1": "rewardTreasury()",
		"818a8e4c": "setMaxProtocolControlledAVAX(uint256)",
		"1031eb9c": "setMaxUnstakeRequests(uint8)",
		"eb4af045": "setMinStakeAmount(uint256)",
		"262b1f9e": "setMinStakeBatchAmount(uint256)",
		"d1f8aaac": "setPrincipalTreasuryAddress(address)",
		"d8a5e936": "setProtocolFeePercentage(uint256)",
		"2659bc15": "setProtocolFeeSplit(address[],uint256[])",
		"cb1045d0": "setRewardTreasuryAddress(address)",
		"1e6b4c6f": "setStakePeriod(uint256)",
		"bc56684a": "stAVAXToAVAX(uint256,uint256)",
		"c1699a99": "stakePeriod()",
		"01ffc9a7": "supportsInterface(bytes4)",
		"95d89b41": "symbol()",
		"18160ddd": "totalSupply()",
		"a9059cbb": "transfer(address,uint256)",
		"23b872dd": "transferFrom(address,address,uint256)",
		"ad874808": "unstakeRequestCount(address)",
		"f87975af": "unstakeRequests(uint256)",
		"e039e3cc": "validatorSelector()",
	},
	Bin: "0x608060405234801561001057600080fd5b506000805460ff191690556001805561503a8061002e6000396000f3fe608060405260043610620003e35760003560e01c80639010d07c1162000203578063c34902631162000117578063d8a5e93611620000ad578063eb4af0451162000078578063eb4af0451462000bb0578063f18876841462000bd5578063f87975af1462000bed578063f8c8765e1462000c5257600080fd5b8063d8a5e9361462000b27578063db4567d31462000b4c578063dd62ed3e1462000b64578063e039e3cc1462000b8957600080fd5b8063cb1045d011620000ee578063cb1045d01462000aae578063d0e30db01462000ad3578063d1f8aaac1462000add578063d547741f1462000b0257600080fd5b8063c34902631462000a42578063c7c934a11462000a67578063ca15c8731462000a8957600080fd5b8063a23b49651162000199578063ad1497fa1162000164578063ad1497fa14620009b9578063ad87480814620009d1578063bc56684a1462000a05578063c1699a991462000a2a57600080fd5b8063a23b4965146200093b578063a457c2d71462000953578063a7602c7e1462000978578063a9059cbb146200099457600080fd5b80639d7710a511620001da5780639d7710a514620008c55780639ee679e814620008e75780639f94a9e3146200090c578063a217fddf146200092457600080fd5b80639010d07c146200086357806391d14854146200088857806395d89b4114620008ad57600080fd5b8063372500ab11620002fb57806370a082311162000291578063846b3c8b116200025c578063846b3c8b14620007ec57806385990de5146200080e578063873dfe3414620008335780638e50e509146200084b57600080fd5b806370a08231146200075d5780637e1f1bfb1462000797578063818a8e4c14620007af5780638456cb5914620007d457600080fd5b8063446ed20b11620002d2578063446ed20b14620006fb5780635352430314620007135780635c975abb146200072b57806367300041146200074557600080fd5b8063372500ab146200063f5780633950935114620006575780633d3da6ef146200067c57600080fd5b80631e6b4c6f116200037d5780632659bc1511620003485780632659bc1514620005ac5780632f2ff15d14620005d1578063313ce56714620005f657806336568abe146200061a57600080fd5b80631e6b4c6f146200050957806323b872dd146200052e578063248a9ca31462000553578063262b1f9e146200058757600080fd5b8063095ea7b311620003be578063095ea7b314620004635780631031eb9c146200048857806318160ddd14620004ad5780631c0fc3f614620004ce57600080fd5b806301ffc9a714620003e8578063046f7da2146200042257806306fdde03146200043c575b600080fd5b348015620003f557600080fd5b506200040d620004073660046200353d565b62000c77565b60405190151581526020015b60405180910390f35b3480156200042f57600080fd5b506200043a62000ca5565b005b3480156200044957600080fd5b506200045462000cde565b604051620004199190620035c6565b3480156200047057600080fd5b506200040d62000482366004620035f3565b62000d78565b3480156200049557600080fd5b506200043a620004a736600462003620565b62000d92565b348015620004ba57600080fd5b506037545b60405190815260200162000419565b348015620004db57600080fd5b50607754620004f0906001600160a01b031681565b6040516001600160a01b03909116815260200162000419565b3480156200051657600080fd5b506200043a6200052836600462003645565b62000dc4565b3480156200053b57600080fd5b506200040d6200054d3660046200365f565b62000de5565b3480156200056057600080fd5b50620004bf6200057236600462003645565b60009081526067602052604090206001015490565b3480156200059457600080fd5b506200043a620005a636600462003645565b62000e0f565b348015620005b957600080fd5b506200043a620005cb36600462003782565b62000e30565b348015620005de57600080fd5b506200043a620005f03660046200384f565b62000eab565b3480156200060357600080fd5b5060125b60405160ff909116815260200162000419565b3480156200062757600080fd5b506200043a620006393660046200384f565b62000ed9565b3480156200064c57600080fd5b506200043a62000f5f565b3480156200066457600080fd5b506200040d62000676366004620035f3565b620010dd565b3480156200068957600080fd5b50620006a16200069b36600462003645565b62001105565b60405162000419919081516001600160a01b031681526020808301516001600160401b03169082015260408083015190820152606080830151908201526080808301519082015260a0918201519181019190915260c00190565b3480156200070857600080fd5b506200043a620011d8565b3480156200072057600080fd5b50620004bf60735481565b3480156200073857600080fd5b5060005460ff166200040d565b3480156200075257600080fd5b50620004bf620012c4565b3480156200076a57600080fd5b50620004bf6200077c3660046200387e565b6001600160a01b031660009081526035602052604090205490565b348015620007a457600080fd5b50620004bf606c5481565b348015620007bc57600080fd5b506200043a620007ce36600462003645565b620012e8565b348015620007e157600080fd5b506200043a62001309565b348015620007f957600080fd5b50607654620004f0906001600160a01b031681565b3480156200081b57600080fd5b50620004bf6200082d3660046200389c565b6200133f565b3480156200084057600080fd5b50620004bf606b5481565b3480156200085857600080fd5b50620004bf606f5481565b3480156200087057600080fd5b50620004f0620008823660046200389c565b6200137a565b3480156200089557600080fd5b506200040d620008a73660046200384f565b62001394565b348015620008ba57600080fd5b5062000454620013bf565b348015620008d257600080fd5b50606e54620004f0906001600160a01b031681565b348015620008f457600080fd5b50620004bf6200090636600462003645565b620013d0565b3480156200091957600080fd5b50620004bf6200168a565b3480156200093157600080fd5b50620004bf600081565b3480156200094857600080fd5b50620004bf620016a9565b3480156200096057600080fd5b506200040d62000972366004620035f3565b620016bb565b3480156200098557600080fd5b50607454620006079060ff1681565b348015620009a157600080fd5b506200040d620009b3366004620035f3565b62001747565b348015620009c657600080fd5b50620004bf60705481565b348015620009de57600080fd5b5062000607620009f03660046200387e565b606d6020526000908152604090205460ff1681565b34801562000a1257600080fd5b50620004bf62000a243660046200389c565b62001757565b34801562000a3757600080fd5b50620004bf60725481565b34801562000a4f57600080fd5b506200043a62000a613660046200389c565b62001795565b34801562000a7457600080fd5b50607854620004f0906001600160a01b031681565b34801562000a9657600080fd5b50620004bf62000aa836600462003645565b62001a69565b34801562000abb57600080fd5b506200043a62000acd3660046200387e565b62001a82565b6200043a62001ae8565b34801562000aea57600080fd5b506200043a62000afc3660046200387e565b62001c00565b34801562000b0f57600080fd5b506200043a62000b213660046200384f565b62001c66565b34801562000b3457600080fd5b506200043a62000b4636600462003645565b62001c8f565b34801562000b5957600080fd5b50620004bf62001cd0565b34801562000b7157600080fd5b50620004bf62000b83366004620038bf565b62001f42565b34801562000b9657600080fd5b50607454620004f09061010090046001600160a01b031681565b34801562000bbd57600080fd5b506200043a62000bcf36600462003645565b62001f6d565b34801562000be257600080fd5b50620004bf60715481565b34801562000bfa57600080fd5b5062000c1262000c0c36600462003645565b62001f8e565b604080516001600160a01b0390971687526001600160401b039095166020870152938501929092526060840152608083015260a082015260c00162000419565b34801562000c5f57600080fd5b506200043a62000c71366004620038ee565b62001fec565b60006001600160e01b03198216635a05180f60e01b148062000c9f575062000c9f8262002386565b92915050565b7fd76e3374742c17bd14ffaf46cd349ec292baf7d8425512fa8fe132557a4c967b62000cd181620023bd565b62000cdb620023c9565b50565b60606038805462000cef906200394b565b80601f016020809104026020016040519081016040528092919081815260200182805462000d1d906200394b565b801562000d6e5780601f1062000d425761010080835404028352916020019162000d6e565b820191906000526020600020905b81548152906001019060200180831162000d5057829003601f168201915b5050505050905090565b60003362000d888185856200241d565b5060019392505050565b60008051602062004fc583398151915262000dad81620023bd565b506074805460ff191660ff92909216919091179055565b60008051602062004fc583398151915262000ddf81620023bd565b50607255565b60003362000df585828562002545565b62000e02858585620025c6565b60019150505b9392505050565b60008051602062004fc583398151915262000e2a81620023bd565b50607055565b60008051602062004fe583398151915262000e4b81620023bd565b828260405162000e5b9062003489565b62000e6892919062003988565b604051809103906000f08015801562000e85573d6000803e3d6000fd5b50606e80546001600160a01b0319166001600160a01b0392909216919091179055505050565b60008281526067602052604090206001015462000ec881620023bd565b62000ed4838362002779565b505050565b6001600160a01b038116331462000f4f5760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b60648201526084015b60405180910390fd5b62000f5b82826200279f565b5050565b6078546001600160a01b0316318062000f755750565b60785460405163379607f560e01b8152600481018390526001600160a01b039091169063379607f590602401600060405180830381600087803b15801562000fbc57600080fd5b505af115801562000fd1573d6000803e3d6000fd5b5050505060006064606f548362000fe9919062003a26565b62000ff5919062003a5e565b606e546040519192506001600160a01b03169082156108fc029083906000818181858888f1935050505015801562001031573d6000803e3d6000fd5b506040518181527f77bb62f6d632f13698ee0dfd8902692281a720e3bd4e18f03b96f3ba43ec5c259060200160405180910390a1600062001073828462003a81565b90507f4f085349488b0a9bbaba55c0dce4ef2ebfc933ff64bdfe6ff3d4b27fdb46770681604051620010a791815260200190565b60405180910390a16000620010bc82620027c5565b905080606c6000828254620010d2919062003a9b565b909155505050505050565b60003362000d88818585620010f3838362001f42565b620010ff919062003a9b565b6200241d565b620011516040518060c0016040528060006001600160a01b0316815260200160006001600160401b03168152602001600081526020016000815260200160008152602001600081525090565b6069828154811062001167576200116762003ab6565b60009182526020918290206040805160c081018252600590930290910180546001600160a01b03811684526001600160401b03600160a01b9091041693830193909352600183015490820152600282015460608201526003820154608082015260049091015460a082015292915050565b6077546001600160a01b03163180620011ee5750565b606b541580620011ff575080606b54105b156200121e57604051630103be3b60e21b815260040160405180910390fd5b60775460405163379607f560e01b8152600481018390526001600160a01b039091169063379607f590602401600060405180830381600087803b1580156200126557600080fd5b505af11580156200127a573d6000803e3d6000fd5b5050505080606b600082825462001292919062003a81565b9091555060009050620012a582620027c5565b905080606c6000828254620012bb919062003a9b565b90915550505050565b6000620012e3620012d4620016a9565b670de0b6b3a764000062001757565b905090565b60008051602062004fc58339815191526200130381620023bd565b50607355565b7fd76e3374742c17bd14ffaf46cd349ec292baf7d8425512fa8fe132557a4c967b6200133581620023bd565b62000cdb62002b0a565b60006200134b60375490565b158062001356575082155b156200136457508062000c9f565b62000e08826200137360375490565b8562002b4a565b600082815260686020526040812062000e08908362002c00565b60009182526067602090815260408084206001600160a01b0393909316845291905290205460ff1690565b60606039805462000cef906200394b565b6000620013dc62002c0e565b620013e662002c56565b816200140557604051630103be3b60e21b815260040160405180910390fd5b607454336000908152606d602052604090205460ff9182169116106200143e576040516376f6999760e11b815260040160405180910390fd5b336000908152606d60205260408120805460ff16916200145e8362003acc565b91906101000a81548160ff021916908360ff160217905550508162001498336001600160a01b031660009081526035602052604090205490565b1015620014b857604051631e9acf1760e31b815260040160405180910390fd5b620014c5333084620025c6565b6000620014dc620014d5620016a9565b8462001757565b6040805160c0810182523381526001600160401b03428116602083019081529282018481526000606084018181526080850182815260a086018b81526069805460018181018355828752985160059091027f7fb4302e8e91f9110a6554c2c0a24601252c2a42c2220ca988efcfe399914308810180549b51909916600160a01b026001600160e01b0319909b166001600160a01b0392909216919091179990991790965593517f7fb4302e8e91f9110a6554c2c0a24601252c2a42c2220ca988efcfe39991430988015590517f7fb4302e8e91f9110a6554c2c0a24601252c2a42c2220ca988efcfe39991430a870155517f7fb4302e8e91f9110a6554c2c0a24601252c2a42c2220ca988efcfe39991430b86015590517f7fb4302e8e91f9110a6554c2c0a24601252c2a42c2220ca988efcfe39991430c909401939093555492935090916200162d919062003a81565b6040805184815260208101879052428183015260608101839052905191925033917fdae9f04ebd508b8d6ff61ab1601937224910e223f2a01713eab68e3d4aeb10ef9181900360800190a29150506200168560018055565b919050565b6000620012e36200169a620016a9565b670de0b6b3a76400006200133f565b600047606b54620012e3919062003a9b565b60003381620016cb828662001f42565b9050838110156200172d5760405162461bcd60e51b815260206004820152602560248201527f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77604482015264207a65726f60d81b606482015260840162000f46565b6200173c82868684036200241d565b506001949350505050565b60003362000d88818585620025c6565b60006200176360375490565b620017715750600062000c9f565b826200177f57508062000c9f565b62000e0882846200178f60375490565b62002b4a565b6200179f62002c0e565b620017a962002c56565b6000620017b68362001105565b80519091506001600160a01b03163314620017e45760405163ea8e4eb560e01b815260040160405180910390fd5b80608001518160600151620017fa919062003a81565b8211156200181b5760405163a77cefcd60e01b815260040160405180910390fd5b478211156200183d57604051631e9acf1760e31b815260040160405180910390fd5b818160800181815162001851919062003a9b565b90525060698054829190859081106200186e576200186e62003ab6565b6000918252602080832084516005909302018054918501516001600160401b0316600160a01b026001600160e01b03199092166001600160a01b03909316929092171781556040808401516001830155606084015160028301556080840151600383015560a09384015160049092019190915591830151918301519091620018f891859062002b4a565b905062001906308262002cb2565b604051339084156108fc029085906000818181858888f1935050505015801562001934573d6000803e3d6000fd5b50604082015160808301511062001a1e57336000908152606d60205260408120805460ff1691620019658362003aef565b91906101000a81548160ff021916908360ff160217905550506069848154811062001994576200199462003ab6565b60009182526020822060059091020180546001600160e01b03191681556001808201839055600282018390556003820183905560049091019190915560405133907f30694308508a999b8c8335a05cfb5919eb0bd4d9415c29592c8f558145dbfaa59062001a0e9087908990918252602082015260400190565b60405180910390a3505062001a5f565b604080518481526020810186905260009133917f30694308508a999b8c8335a05cfb5919eb0bd4d9415c29592c8f558145dbfaa5910160405180910390a350505b62000f5b60018055565b600081815260686020526040812062000c9f9062002dea565b60008051602062004fe583398151915262001a9d81620023bd565b6001600160a01b03821662001ac55760405163e6c4247b60e01b815260040160405180910390fd5b50607880546001600160a01b0319166001600160a01b0392909216919091179055565b62001af262002c0e565b62001afc62002c56565b607154349081101562001b2257604051630103be3b60e21b815260040160405180910390fd5b6073548162001b30620016a9565b62001b3c919062003a9b565b111562001b5c57604051631027f1cd60e11b815260040160405180910390fd5b600062001b808262001b6d620016a9565b62001b79919062003a81565b836200133f565b905062001b8e338262002df5565b6040805183815242602082015233917fad40ae5dc69974ba932d08b0a608e89109412d41d04850f5196f144875ae2660910160405180910390a2600062001bd583620027c5565b905080606c600082825462001beb919062003a9b565b9091555050600180555062001bfe915050565b565b60008051602062004fe583398151915262001c1b81620023bd565b6001600160a01b03821662001c435760405163e6c4247b60e01b815260040160405180910390fd5b50607780546001600160a01b0319166001600160a01b0392909216919091179055565b60008281526067602052604090206001015462001c8381620023bd565b62000ed483836200279f565b7f0fc26914248bb9568b0afb008dd993637f6fb6bdc9598c222c68a21e90ca53c162001cbb81620023bd565b606482111562001cca57600080fd5b50606f55565b600062001cdc62002c0e565b62001ce662002c56565b606c54158062001cf95750607054606c54105b1562001d085750600062001f35565b607454606c54604051636194697d60e01b815260048101919091526000918291829161010090046001600160a01b031690636194697d90602401600060405180830381865afa15801562001d60573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405262001d8a919081019062003b71565b92509250925082516000148062001da057508151155b1562001dbf5760405163023ae0f360e11b815260040160405180910390fd5b600081606c5462001dd1919062003a81565b905080606b600082825462001de7919062003a9b565b9091555050606c829055600062001e014261070862003a9b565b905060006072548262001e15919062003a9b565b905060005b865181101562001f2b5785818151811062001e395762001e3962003ab6565b60200260200101516000141562001e505762001f16565b60765486516001600160a01b03909116906389060b349088908490811062001e7c5762001e7c62003ab6565b602002602001015189848151811062001e995762001e9962003ab6565b602002602001015189858151811062001eb65762001eb662003ab6565b602002602001015187876040518663ffffffff1660e01b815260040162001ee1949392919062003cb8565b6000604051808303818588803b15801562001efb57600080fd5b505af115801562001f10573d6000803e3d6000fd5b50505050505b8062001f228162003ce9565b91505062001e1a565b5091955050505050505b62001f3f60018055565b90565b6001600160a01b03918216600090815260366020908152604080832093909416825291909152205490565b60008051602062004fc583398151915262001f8881620023bd565b50607155565b6069818154811062001f9f57600080fd5b6000918252602090912060059091020180546001820154600283015460038401546004909401546001600160a01b0384169550600160a01b9093046001600160401b031693919290919086565b600254610100900460ff16158080156200200d5750600254600160ff909116105b80620020295750303b15801562002029575060025460ff166001145b6200208e5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b606482015260840162000f46565b6002805460ff191660011790558015620020b2576002805461ff0019166101001790555b620020ff6040518060400160405280600b81526020016a0a6e8c2d6cac84082ac82b60ab1b815250604051806040016040528060068152602001650e6e882ac82b60d31b81525062002eba565b6200210c60003362002ef0565b620021387fd76e3374742c17bd14ffaf46cd349ec292baf7d8425512fa8fe132557a4c967b3362002ef0565b620021647f0fc26914248bb9568b0afb008dd993637f6fb6bdc9598c222c68a21e90ca53c13362002ef0565b6200217f60008051602062004fe58339815191523362002ef0565b620021ab7f9fece4792c7ff5d25a4f6041da7db799a6228be21fcb6358ef0b12f1dd685cb63362002ef0565b620021c660008051602062004fc58339815191523362002ef0565b600a606f819055678ac7230489e8000060705567016345785d8a0000607155621275006072556074805469152d02c7e14af6800000607355607680546001600160a01b038781166001600160a01b0319909216919091179091558616610100026001600160a81b0319909116179091179055604080516002808252606082018352600092602083019080368337019050509050858160008151811062002270576200227062003ab6565b60200260200101906001600160a01b031690816001600160a01b0316815250508481600181518110620022a757620022a762003ab6565b6001600160a01b03929092166020928302919091018201526040805160028082526060820183526000939192909183019080368337019050509050605081600081518110620022fa57620022fa62003ab6565b6020026020010181815250506014816001815181106200231e576200231e62003ab6565b60200260200101818152505062002336828262000e30565b505080156200237f576002805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b5050505050565b60006001600160e01b03198216637965db0b60e01b148062000c9f57506301ffc9a760e01b6001600160e01b031983161462000c9f565b62000cdb813362002efc565b620023d362002f60565b6000805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b6001600160a01b038316620024815760405162461bcd60e51b8152602060048201526024808201527f45524332303a20617070726f76652066726f6d20746865207a65726f206164646044820152637265737360e01b606482015260840162000f46565b6001600160a01b038216620024e45760405162461bcd60e51b815260206004820152602260248201527f45524332303a20617070726f766520746f20746865207a65726f206164647265604482015261737360f01b606482015260840162000f46565b6001600160a01b0383811660008181526036602090815260408083209487168084529482529182902085905590518481527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a3505050565b600062002553848462001f42565b90506000198114620025c05781811015620025b15760405162461bcd60e51b815260206004820152601d60248201527f45524332303a20696e73756666696369656e7420616c6c6f77616e6365000000604482015260640162000f46565b620025c084848484036200241d565b50505050565b6001600160a01b0383166200262c5760405162461bcd60e51b815260206004820152602560248201527f45524332303a207472616e736665722066726f6d20746865207a65726f206164604482015264647265737360d81b606482015260840162000f46565b6001600160a01b038216620026905760405162461bcd60e51b815260206004820152602360248201527f45524332303a207472616e7366657220746f20746865207a65726f206164647260448201526265737360e81b606482015260840162000f46565b6001600160a01b038316600090815260356020526040902054818110156200270a5760405162461bcd60e51b815260206004820152602660248201527f45524332303a207472616e7366657220616d6f756e7420657863656564732062604482015265616c616e636560d01b606482015260840162000f46565b6001600160a01b0380851660008181526035602052604080822086860390559286168082529083902080548601905591517fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef906200276b9086815260200190565b60405180910390a3620025c0565b62002785828262002fab565b600082815260686020526040902062000ed4908262003035565b620027ab82826200304c565b600082815260686020526040902062000ed49082620030b6565b600081620027d557506000919050565b606a5460009083905b60695481101562002b025781620027f55762002b02565b6200288a606982815481106200280f576200280f62003ab6565b60009182526020918290206040805160c081018252600590930290910180546001600160a01b03811684526001600160401b03600160a01b9091041693830193909352600183015490820152600282015460608201526003820154608082015260049091015460a08201526040810151606090910151101590565b15620028e95760405162461bcd60e51b815260206004820152602760248201527f496e76616c6964207374617465202d2066696c6c6564207265717565737420696044820152666e20717565756560c81b606482015260840162000f46565b60698181548110620028ff57620028ff62003ab6565b9060005260206000209060050201600101546069828154811062002927576200292762003ab6565b906000526020600020906005020160020154101562002adf5760006069828154811062002958576200295862003ab6565b9060005260206000209060050201600201546069838154811062002980576200298062003ab6565b9060005260206000209060050201600101546200299e919062003a81565b90506000620029ae8285620030cd565b9050620029bc818662003a9b565b94508060698481548110620029d557620029d562003ab6565b90600052602060002090600502016002016000828254620029f7919062003a9b565b9250508190555062002a18606984815481106200280f576200280f62003ab6565b1562002aa05762002a2b83600162003a9b565b606a55606980548490811062002a455762002a4562003ab6565b9060005260206000209060050201600101547f6c09cd6b64ed10fcbd787eb4226ec81ab34e3db928a77faef8d22bc10ebe82ed428560405162002a92929190918252602082015260400190565b60405180910390a262002adc565b604080514281526020810185905282917fdc0903a14c2c2526071b103c0305417a977225da3764984a90de4c9b8195cac5910160405180910390a25b50505b62002aeb838662003a81565b91508062002af98162003ce9565b915050620027de565b509392505050565b62002b1462002c0e565b6000805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258620024003390565b60008080600019858709858702925082811083820303915050806000141562002b8a5783828162002b7f5762002b7f62003a48565b049250505062000e08565b80841162002b9757600080fd5b60008486880960026001871981018816978890046003810283188082028403028082028403028082028403028082028403028082028403029081029092039091026000889003889004909101858311909403939093029303949094049190911702949350505050565b600062000e088383620030e5565b60005460ff161562001bfe5760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b604482015260640162000f46565b6002600154141562002cab5760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00604482015260640162000f46565b6002600155565b6001600160a01b03821662002d145760405162461bcd60e51b815260206004820152602160248201527f45524332303a206275726e2066726f6d20746865207a65726f206164647265736044820152607360f81b606482015260840162000f46565b6001600160a01b0382166000908152603560205260409020548181101562002d8a5760405162461bcd60e51b815260206004820152602260248201527f45524332303a206275726e20616d6f756e7420657863656564732062616c616e604482015261636560f01b606482015260840162000f46565b6001600160a01b03831660008181526035602090815260408083208686039055603780548790039055518581529192917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef910160405180910390a3505050565b600062000c9f825490565b6001600160a01b03821662002e4d5760405162461bcd60e51b815260206004820152601f60248201527f45524332303a206d696e7420746f20746865207a65726f206164647265737300604482015260640162000f46565b806037600082825462002e61919062003a9b565b90915550506001600160a01b0382166000818152603560209081526040808320805486019055518481527fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef910160405180910390a35050565b600254610100900460ff1662002ee45760405162461bcd60e51b815260040162000f469062003d07565b62000f5b828262003112565b62000f5b828262002779565b62002f08828262001394565b62000f5b5762002f188162003167565b62002f258360206200317a565b60405160200162002f3892919062003d52565b60408051601f198184030181529082905262461bcd60e51b825262000f4691600401620035c6565b60005460ff1662001bfe5760405162461bcd60e51b815260206004820152601460248201527314185d5cd8589b194e881b9bdd081c185d5cd95960621b604482015260640162000f46565b62002fb7828262001394565b62000f5b5760008281526067602090815260408083206001600160a01b03851684529091529020805460ff1916600117905562002ff13390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b600062000e08836001600160a01b03841662003333565b62003058828262001394565b1562000f5b5760008281526067602090815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b600062000e08836001600160a01b03841662003385565b6000818310620030de578162000e08565b5090919050565b6000826000018281548110620030ff57620030ff62003ab6565b9060005260206000200154905092915050565b600254610100900460ff166200313c5760405162461bcd60e51b815260040162000f469062003d07565b81516200315190603890602085019062003497565b50805162000ed490603990602084019062003497565b606062000c9f6001600160a01b03831660145b606060006200318b83600262003a26565b6200319890600262003a9b565b6001600160401b03811115620031b257620031b2620036a0565b6040519080825280601f01601f191660200182016040528015620031dd576020820181803683370190505b509050600360fc1b81600081518110620031fb57620031fb62003ab6565b60200101906001600160f81b031916908160001a905350600f60fb1b816001815181106200322d576200322d62003ab6565b60200101906001600160f81b031916908160001a90535060006200325384600262003a26565b6200326090600162003a9b565b90505b6001811115620032e2576f181899199a1a9b1b9c1cb0b131b232b360811b85600f166010811062003298576200329862003ab6565b1a60f81b828281518110620032b157620032b162003ab6565b60200101906001600160f81b031916908160001a90535060049490941c93620032da8162003dcb565b905062003263565b50831562000e085760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e74604482015260640162000f46565b60008181526001830160205260408120546200337c5750815460018181018455600084815260208082209093018490558454848252828601909352604090209190915562000c9f565b50600062000c9f565b600081815260018301602052604081205480156200347e576000620033ac60018362003a81565b8554909150600090620033c29060019062003a81565b90508181146200342e576000866000018281548110620033e657620033e662003ab6565b90600052602060002001549050808760000184815481106200340c576200340c62003ab6565b6000918252602080832090910192909255918252600188019052604090208390555b855486908062003442576200344262003de5565b60019003818190600052602060002001600090559055856001016000868152602001908152602001600020600090556001935050505062000c9f565b600091505062000c9f565b6111c98062003dfc83390190565b828054620034a5906200394b565b90600052602060002090601f016020900481019282620034c9576000855562003514565b82601f10620034e457805160ff191683800117855562003514565b8280016001018555821562003514579182015b8281111562003514578251825591602001919060010190620034f7565b506200352292915062003526565b5090565b5b8082111562003522576000815560010162003527565b6000602082840312156200355057600080fd5b81356001600160e01b03198116811462000e0857600080fd5b60005b83811015620035865781810151838201526020016200356c565b83811115620025c05750506000910152565b60008151808452620035b281602086016020860162003569565b601f01601f19169290920160200192915050565b60208152600062000e08602083018462003598565b80356001600160a01b03811681146200168557600080fd5b600080604083850312156200360757600080fd5b6200361283620035db565b946020939093013593505050565b6000602082840312156200363357600080fd5b813560ff8116811462000e0857600080fd5b6000602082840312156200365857600080fd5b5035919050565b6000806000606084860312156200367557600080fd5b6200368084620035db565b92506200369060208501620035db565b9150604084013590509250925092565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b0381118282101715620036e157620036e1620036a0565b604052919050565b60006001600160401b03821115620037055762003705620036a0565b5060051b60200190565b600082601f8301126200372157600080fd5b813560206200373a6200373483620036e9565b620036b6565b82815260059290921b840181019181810190868411156200375a57600080fd5b8286015b848110156200377757803583529183019183016200375e565b509695505050505050565b600080604083850312156200379657600080fd5b82356001600160401b0380821115620037ae57600080fd5b818501915085601f830112620037c357600080fd5b81356020620037d66200373483620036e9565b82815260059290921b84018101918181019089841115620037f657600080fd5b948201945b838610156200381f576200380f86620035db565b82529482019490820190620037fb565b965050860135925050808211156200383657600080fd5b5062003845858286016200370f565b9150509250929050565b600080604083850312156200386357600080fd5b823591506200387560208401620035db565b90509250929050565b6000602082840312156200389157600080fd5b62000e0882620035db565b60008060408385031215620038b057600080fd5b50508035926020909101359150565b60008060408385031215620038d357600080fd5b620038de83620035db565b91506200387560208401620035db565b600080600080608085870312156200390557600080fd5b6200391085620035db565b93506200392060208601620035db565b92506200393060408601620035db565b91506200394060608601620035db565b905092959194509250565b600181811c908216806200396057607f821691505b602082108114156200398257634e487b7160e01b600052602260045260246000fd5b50919050565b604080825283519082018190526000906020906060840190828701845b82811015620039cc5781516001600160a01b031684529284019290840190600101620039a5565b5050508381038285015284518082528583019183019060005b8181101562003a0357835183529284019291840191600101620039e5565b5090979650505050505050565b634e487b7160e01b600052601160045260246000fd5b600081600019048311821515161562003a435762003a4362003a10565b500290565b634e487b7160e01b600052601260045260246000fd5b60008262003a7c57634e487b7160e01b600052601260045260246000fd5b500490565b60008282101562003a965762003a9662003a10565b500390565b6000821982111562003ab15762003ab162003a10565b500190565b634e487b7160e01b600052603260045260246000fd5b600060ff821660ff81141562003ae65762003ae662003a10565b60010192915050565b600060ff82168062003b055762003b0562003a10565b6000190192915050565b600082601f83011262003b2157600080fd5b8151602062003b346200373483620036e9565b82815260059290921b8401810191818101908684111562003b5457600080fd5b8286015b8481101562003777578051835291830191830162003b58565b60008060006060848603121562003b8757600080fd5b83516001600160401b038082111562003b9f57600080fd5b818601915086601f83011262003bb457600080fd5b8151602062003bc76200373483620036e9565b82815260059290921b8401810191818101908a84111562003be757600080fd5b8286015b8481101562003c7d5780518681111562003c055760008081fd5b8701603f81018d1362003c185760008081fd5b8481015160408882111562003c315762003c31620036a0565b62003c45601f8301601f19168801620036b6565b8281528f8284860101111562003c5b5760008081fd5b62003c6c8389830184870162003569565b865250505091830191830162003beb565b509189015191975090935050508082111562003c9857600080fd5b5062003ca78682870162003b0f565b925050604084015190509250925092565b60808152600062003ccd608083018762003598565b6020830195909552506040810192909252606090910152919050565b600060001982141562003d005762003d0062003a10565b5060010190565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b7f416363657373436f6e74726f6c3a206163636f756e742000000000000000000081526000835162003d8c81601785016020880162003569565b7001034b99036b4b9b9b4b733903937b6329607d1b601791840191820152835162003dbf81602884016020880162003569565b01602801949350505050565b60008162003ddd5762003ddd62003a10565b506000190190565b634e487b7160e01b600052603160045260246000fdfe6080604052604051620011c9380380620011c983398101604081905262000026916200042e565b8051825114620000985760405162461bcd60e51b815260206004820152603260248201527f5061796d656e7453706c69747465723a2070617965657320616e6420736861726044820152710cae640d8cadccee8d040dad2e6dac2e8c6d60731b60648201526084015b60405180910390fd5b6000825111620000eb5760405162461bcd60e51b815260206004820152601a60248201527f5061796d656e7453706c69747465723a206e6f2070617965657300000000000060448201526064016200008f565b60005b82518110156200015757620001428382815181106200011157620001116200050c565b60200260200101518383815181106200012e576200012e6200050c565b60200260200101516200016060201b60201c565b806200014e8162000538565b915050620000ee565b50505062000571565b6001600160a01b038216620001cd5760405162461bcd60e51b815260206004820152602c60248201527f5061796d656e7453706c69747465723a206163636f756e74206973207468652060448201526b7a65726f206164647265737360a01b60648201526084016200008f565b600081116200021f5760405162461bcd60e51b815260206004820152601d60248201527f5061796d656e7453706c69747465723a2073686172657320617265203000000060448201526064016200008f565b6001600160a01b038216600090815260026020526040902054156200029b5760405162461bcd60e51b815260206004820152602b60248201527f5061796d656e7453706c69747465723a206163636f756e7420616c726561647960448201526a206861732073686172657360a81b60648201526084016200008f565b60048054600181019091557f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b0180546001600160a01b0319166001600160a01b0384169081179091556000908152600260205260408120829055546200030390829062000556565b600055604080516001600160a01b0384168152602081018390527f40c340f65e17194d14ddddb073d3c9f888e3cb52b5aae0c6c7706b4fbc905fac910160405180910390a15050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b03811182821017156200038d576200038d6200034c565b604052919050565b60006001600160401b03821115620003b157620003b16200034c565b5060051b60200190565b600082601f830112620003cd57600080fd5b81516020620003e6620003e08362000395565b62000362565b82815260059290921b840181019181810190868411156200040657600080fd5b8286015b848110156200042357805183529183019183016200040a565b509695505050505050565b600080604083850312156200044257600080fd5b82516001600160401b03808211156200045a57600080fd5b818501915085601f8301126200046f57600080fd5b8151602062000482620003e08362000395565b82815260059290921b84018101918181019089841115620004a257600080fd5b948201945b83861015620004d95785516001600160a01b0381168114620004c95760008081fd5b82529482019490820190620004a7565b91880151919650909350505080821115620004f357600080fd5b506200050285828601620003bb565b9150509250929050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b60006000198214156200054f576200054f62000522565b5060010190565b600082198211156200056c576200056c62000522565b500190565b610c4880620005816000396000f3fe6080604052600436106100a05760003560e01c80639852595c116100645780639852595c146101d2578063a3f8eace14610208578063c45ac05014610228578063ce7c2ac214610248578063d79779b21461027e578063e33b7de3146102b457600080fd5b806319165587146100ee5780633a98ef3914610110578063406072a91461013457806348b750441461017a5780638b83209b1461019a57600080fd5b366100e9577f6ef95f06320e7a25a04a175ca677b7052bdd97131872c2192525a629f51be77033604080516001600160a01b0390921682523460208301520160405180910390a1005b600080fd5b3480156100fa57600080fd5b5061010e6101093660046109bc565b6102c9565b005b34801561011c57600080fd5b506000545b6040519081526020015b60405180910390f35b34801561014057600080fd5b5061012161014f3660046109d9565b6001600160a01b03918216600090815260066020908152604080832093909416825291909152205490565b34801561018657600080fd5b5061010e6101953660046109d9565b6103b6565b3480156101a657600080fd5b506101ba6101b5366004610a12565b6104c4565b6040516001600160a01b03909116815260200161012b565b3480156101de57600080fd5b506101216101ed3660046109bc565b6001600160a01b031660009081526003602052604090205490565b34801561021457600080fd5b506101216102233660046109bc565b6104f4565b34801561023457600080fd5b506101216102433660046109d9565b61053c565b34801561025457600080fd5b506101216102633660046109bc565b6001600160a01b031660009081526002602052604090205490565b34801561028a57600080fd5b506101216102993660046109bc565b6001600160a01b031660009081526005602052604090205490565b3480156102c057600080fd5b50600154610121565b6001600160a01b0381166000908152600260205260409020546103075760405162461bcd60e51b81526004016102fe90610a2b565b60405180910390fd5b6000610312826104f4565b9050806103315760405162461bcd60e51b81526004016102fe90610a71565b80600160008282546103439190610ad2565b90915550506001600160a01b03821660009081526003602052604090208054820190556103708282610607565b604080516001600160a01b0384168152602081018390527fdf20fd1e76bc69d672e4814fafb2c449bba3a5369d8359adf9e05e6fde87b056910160405180910390a15050565b6001600160a01b0381166000908152600260205260409020546103eb5760405162461bcd60e51b81526004016102fe90610a2b565b60006103f7838361053c565b9050806104165760405162461bcd60e51b81526004016102fe90610a71565b6001600160a01b0383166000908152600560205260408120805483929061043e908490610ad2565b90915550506001600160a01b038084166000908152600660209081526040808320938616835292905220805482019055610479838383610725565b604080516001600160a01b038481168252602082018490528516917f3be5b7a71e84ed12875d241991c70855ac5817d847039e17a9d895c1ceb0f18a910160405180910390a2505050565b6000600482815481106104d9576104d9610aea565b6000918252602090912001546001600160a01b031692915050565b60008061050060015490565b61050a9047610ad2565b90506105358382610530866001600160a01b031660009081526003602052604090205490565b610777565b9392505050565b6001600160a01b03821660009081526005602052604081205481906040516370a0823160e01b81523060048201526001600160a01b038616906370a0823190602401602060405180830381865afa15801561059b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105bf9190610b00565b6105c99190610ad2565b6001600160a01b038086166000908152600660209081526040808320938816835292905220549091506105ff9084908390610777565b949350505050565b804710156106575760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a20696e73756666696369656e742062616c616e636500000060448201526064016102fe565b6000826001600160a01b03168260405160006040518083038185875af1925050503d80600081146106a4576040519150601f19603f3d011682016040523d82523d6000602084013e6106a9565b606091505b50509050806107205760405162461bcd60e51b815260206004820152603a60248201527f416464726573733a20756e61626c6520746f2073656e642076616c75652c207260448201527f6563697069656e74206d6179206861766520726576657274656400000000000060648201526084016102fe565b505050565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663a9059cbb60e01b1790526107209084906107b2565b600080546001600160a01b03851682526002602052604082205483919061079e9086610b19565b6107a89190610b38565b6105ff9190610b5a565b6000610807826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166108849092919063ffffffff16565b80519091501561072057808060200190518101906108259190610b71565b6107205760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016102fe565b60606105ff848460008585600080866001600160a01b031685876040516108ab9190610bc3565b60006040518083038185875af1925050503d80600081146108e8576040519150601f19603f3d011682016040523d82523d6000602084013e6108ed565b606091505b50915091506108fe87838387610909565b979650505050505050565b6060831561097557825161096e576001600160a01b0385163b61096e5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016102fe565b50816105ff565b6105ff838381511561098a5781518083602001fd5b8060405162461bcd60e51b81526004016102fe9190610bdf565b6001600160a01b03811681146109b957600080fd5b50565b6000602082840312156109ce57600080fd5b8135610535816109a4565b600080604083850312156109ec57600080fd5b82356109f7816109a4565b91506020830135610a07816109a4565b809150509250929050565b600060208284031215610a2457600080fd5b5035919050565b60208082526026908201527f5061796d656e7453706c69747465723a206163636f756e7420686173206e6f2060408201526573686172657360d01b606082015260800190565b6020808252602b908201527f5061796d656e7453706c69747465723a206163636f756e74206973206e6f742060408201526a191d59481c185e5b595b9d60aa1b606082015260800190565b634e487b7160e01b600052601160045260246000fd5b60008219821115610ae557610ae5610abc565b500190565b634e487b7160e01b600052603260045260246000fd5b600060208284031215610b1257600080fd5b5051919050565b6000816000190483118215151615610b3357610b33610abc565b500290565b600082610b5557634e487b7160e01b600052601260045260246000fd5b500490565b600082821015610b6c57610b6c610abc565b500390565b600060208284031215610b8357600080fd5b8151801515811461053557600080fd5b60005b83811015610bae578181015183820152602001610b96565b83811115610bbd576000848401525b50505050565b60008251610bd5818460208701610b93565b9190910192915050565b6020815260008251806020840152610bfe816040850160208701610b93565b601f01601f1916919091016040019291505056fea264697066735822122072124e5593df9b0f269294bc9437eac01d2c53da3f72549c0203647d323fdb5464736f6c634300080a0033d3ef87a7ea0f8f246b3bb6af4b410a89667f439c24eb3b101b985c7586acc2d2eed8967f77314cb9509704749de6f91c4a59cade181d6e377c26775e759a943da264697066735822122090d4035d6b39f7505429d62e6555e4050b67b79e788b6a8a41a99c5c57250bb664736f6c634300080a0033",
}

// AvaLidoABI is the input ABI used to generate the binding from.
// Deprecated: Use AvaLidoMetaData.ABI instead.
var AvaLidoABI = AvaLidoMetaData.ABI

// Deprecated: Use AvaLidoMetaData.Sigs instead.
// AvaLidoFuncSigs maps the 4-byte function signature to its string representation.
var AvaLidoFuncSigs = AvaLidoMetaData.Sigs

// AvaLidoBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use AvaLidoMetaData.Bin instead.
var AvaLidoBin = AvaLidoMetaData.Bin

// DeployAvaLido deploys a new Ethereum contract, binding an instance of AvaLido to it.
func DeployAvaLido(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *AvaLido, error) {
	parsed, err := AvaLidoMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(AvaLidoBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &AvaLido{AvaLidoCaller: AvaLidoCaller{contract: contract}, AvaLidoTransactor: AvaLidoTransactor{contract: contract}, AvaLidoFilterer: AvaLidoFilterer{contract: contract}}, nil
}

// AvaLido is an auto generated Go binding around an Ethereum contract.
type AvaLido struct {
	AvaLidoCaller     // Read-only binding to the contract
	AvaLidoTransactor // Write-only binding to the contract
	AvaLidoFilterer   // Log filterer for contract events
}

// AvaLidoCaller is an auto generated read-only Go binding around an Ethereum contract.
type AvaLidoCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AvaLidoTransactor is an auto generated write-only Go binding around an Ethereum contract.
type AvaLidoTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AvaLidoFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type AvaLidoFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AvaLidoSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type AvaLidoSession struct {
	Contract     *AvaLido          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// AvaLidoCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type AvaLidoCallerSession struct {
	Contract *AvaLidoCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// AvaLidoTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type AvaLidoTransactorSession struct {
	Contract     *AvaLidoTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// AvaLidoRaw is an auto generated low-level Go binding around an Ethereum contract.
type AvaLidoRaw struct {
	Contract *AvaLido // Generic contract binding to access the raw methods on
}

// AvaLidoCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type AvaLidoCallerRaw struct {
	Contract *AvaLidoCaller // Generic read-only contract binding to access the raw methods on
}

// AvaLidoTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type AvaLidoTransactorRaw struct {
	Contract *AvaLidoTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAvaLido creates a new instance of AvaLido, bound to a specific deployed contract.
func NewAvaLido(address common.Address, backend bind.ContractBackend) (*AvaLido, error) {
	contract, err := bindAvaLido(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &AvaLido{AvaLidoCaller: AvaLidoCaller{contract: contract}, AvaLidoTransactor: AvaLidoTransactor{contract: contract}, AvaLidoFilterer: AvaLidoFilterer{contract: contract}}, nil
}

// NewAvaLidoCaller creates a new read-only instance of AvaLido, bound to a specific deployed contract.
func NewAvaLidoCaller(address common.Address, caller bind.ContractCaller) (*AvaLidoCaller, error) {
	contract, err := bindAvaLido(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AvaLidoCaller{contract: contract}, nil
}

// NewAvaLidoTransactor creates a new write-only instance of AvaLido, bound to a specific deployed contract.
func NewAvaLidoTransactor(address common.Address, transactor bind.ContractTransactor) (*AvaLidoTransactor, error) {
	contract, err := bindAvaLido(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AvaLidoTransactor{contract: contract}, nil
}

// NewAvaLidoFilterer creates a new log filterer instance of AvaLido, bound to a specific deployed contract.
func NewAvaLidoFilterer(address common.Address, filterer bind.ContractFilterer) (*AvaLidoFilterer, error) {
	contract, err := bindAvaLido(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AvaLidoFilterer{contract: contract}, nil
}

// bindAvaLido binds a generic wrapper to an already deployed contract.
func bindAvaLido(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(AvaLidoABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AvaLido *AvaLidoRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AvaLido.Contract.AvaLidoCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AvaLido *AvaLidoRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AvaLido.Contract.AvaLidoTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AvaLido *AvaLidoRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AvaLido.Contract.AvaLidoTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AvaLido *AvaLidoCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AvaLido.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AvaLido *AvaLidoTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AvaLido.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AvaLido *AvaLidoTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AvaLido.Contract.contract.Transact(opts, method, params...)
}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_AvaLido *AvaLidoCaller) DEFAULTADMINROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "DEFAULT_ADMIN_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_AvaLido *AvaLidoSession) DEFAULTADMINROLE() ([32]byte, error) {
	return _AvaLido.Contract.DEFAULTADMINROLE(&_AvaLido.CallOpts)
}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_AvaLido *AvaLidoCallerSession) DEFAULTADMINROLE() ([32]byte, error) {
	return _AvaLido.Contract.DEFAULTADMINROLE(&_AvaLido.CallOpts)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_AvaLido *AvaLidoCaller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_AvaLido *AvaLidoSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _AvaLido.Contract.Allowance(&_AvaLido.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_AvaLido *AvaLidoCallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _AvaLido.Contract.Allowance(&_AvaLido.CallOpts, owner, spender)
}

// AmountPendingAVAX is a free data retrieval call binding the contract method 0x7e1f1bfb.
//
// Solidity: function amountPendingAVAX() view returns(uint256)
func (_AvaLido *AvaLidoCaller) AmountPendingAVAX(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "amountPendingAVAX")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// AmountPendingAVAX is a free data retrieval call binding the contract method 0x7e1f1bfb.
//
// Solidity: function amountPendingAVAX() view returns(uint256)
func (_AvaLido *AvaLidoSession) AmountPendingAVAX() (*big.Int, error) {
	return _AvaLido.Contract.AmountPendingAVAX(&_AvaLido.CallOpts)
}

// AmountPendingAVAX is a free data retrieval call binding the contract method 0x7e1f1bfb.
//
// Solidity: function amountPendingAVAX() view returns(uint256)
func (_AvaLido *AvaLidoCallerSession) AmountPendingAVAX() (*big.Int, error) {
	return _AvaLido.Contract.AmountPendingAVAX(&_AvaLido.CallOpts)
}

// AmountStakedAVAX is a free data retrieval call binding the contract method 0x873dfe34.
//
// Solidity: function amountStakedAVAX() view returns(uint256)
func (_AvaLido *AvaLidoCaller) AmountStakedAVAX(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "amountStakedAVAX")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// AmountStakedAVAX is a free data retrieval call binding the contract method 0x873dfe34.
//
// Solidity: function amountStakedAVAX() view returns(uint256)
func (_AvaLido *AvaLidoSession) AmountStakedAVAX() (*big.Int, error) {
	return _AvaLido.Contract.AmountStakedAVAX(&_AvaLido.CallOpts)
}

// AmountStakedAVAX is a free data retrieval call binding the contract method 0x873dfe34.
//
// Solidity: function amountStakedAVAX() view returns(uint256)
func (_AvaLido *AvaLidoCallerSession) AmountStakedAVAX() (*big.Int, error) {
	return _AvaLido.Contract.AmountStakedAVAX(&_AvaLido.CallOpts)
}

// AvaxToStAVAX is a free data retrieval call binding the contract method 0x85990de5.
//
// Solidity: function avaxToStAVAX(uint256 totalControlled, uint256 avaxAmount) view returns(uint256)
func (_AvaLido *AvaLidoCaller) AvaxToStAVAX(opts *bind.CallOpts, totalControlled *big.Int, avaxAmount *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "avaxToStAVAX", totalControlled, avaxAmount)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// AvaxToStAVAX is a free data retrieval call binding the contract method 0x85990de5.
//
// Solidity: function avaxToStAVAX(uint256 totalControlled, uint256 avaxAmount) view returns(uint256)
func (_AvaLido *AvaLidoSession) AvaxToStAVAX(totalControlled *big.Int, avaxAmount *big.Int) (*big.Int, error) {
	return _AvaLido.Contract.AvaxToStAVAX(&_AvaLido.CallOpts, totalControlled, avaxAmount)
}

// AvaxToStAVAX is a free data retrieval call binding the contract method 0x85990de5.
//
// Solidity: function avaxToStAVAX(uint256 totalControlled, uint256 avaxAmount) view returns(uint256)
func (_AvaLido *AvaLidoCallerSession) AvaxToStAVAX(totalControlled *big.Int, avaxAmount *big.Int) (*big.Int, error) {
	return _AvaLido.Contract.AvaxToStAVAX(&_AvaLido.CallOpts, totalControlled, avaxAmount)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_AvaLido *AvaLidoCaller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_AvaLido *AvaLidoSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _AvaLido.Contract.BalanceOf(&_AvaLido.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_AvaLido *AvaLidoCallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _AvaLido.Contract.BalanceOf(&_AvaLido.CallOpts, account)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_AvaLido *AvaLidoCaller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "decimals")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_AvaLido *AvaLidoSession) Decimals() (uint8, error) {
	return _AvaLido.Contract.Decimals(&_AvaLido.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_AvaLido *AvaLidoCallerSession) Decimals() (uint8, error) {
	return _AvaLido.Contract.Decimals(&_AvaLido.CallOpts)
}

// ExchangeRateAVAXToStAVAX is a free data retrieval call binding the contract method 0x9f94a9e3.
//
// Solidity: function exchangeRateAVAXToStAVAX() view returns(uint256)
func (_AvaLido *AvaLidoCaller) ExchangeRateAVAXToStAVAX(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "exchangeRateAVAXToStAVAX")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ExchangeRateAVAXToStAVAX is a free data retrieval call binding the contract method 0x9f94a9e3.
//
// Solidity: function exchangeRateAVAXToStAVAX() view returns(uint256)
func (_AvaLido *AvaLidoSession) ExchangeRateAVAXToStAVAX() (*big.Int, error) {
	return _AvaLido.Contract.ExchangeRateAVAXToStAVAX(&_AvaLido.CallOpts)
}

// ExchangeRateAVAXToStAVAX is a free data retrieval call binding the contract method 0x9f94a9e3.
//
// Solidity: function exchangeRateAVAXToStAVAX() view returns(uint256)
func (_AvaLido *AvaLidoCallerSession) ExchangeRateAVAXToStAVAX() (*big.Int, error) {
	return _AvaLido.Contract.ExchangeRateAVAXToStAVAX(&_AvaLido.CallOpts)
}

// ExchangeRateStAVAXToAVAX is a free data retrieval call binding the contract method 0x67300041.
//
// Solidity: function exchangeRateStAVAXToAVAX() view returns(uint256)
func (_AvaLido *AvaLidoCaller) ExchangeRateStAVAXToAVAX(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "exchangeRateStAVAXToAVAX")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ExchangeRateStAVAXToAVAX is a free data retrieval call binding the contract method 0x67300041.
//
// Solidity: function exchangeRateStAVAXToAVAX() view returns(uint256)
func (_AvaLido *AvaLidoSession) ExchangeRateStAVAXToAVAX() (*big.Int, error) {
	return _AvaLido.Contract.ExchangeRateStAVAXToAVAX(&_AvaLido.CallOpts)
}

// ExchangeRateStAVAXToAVAX is a free data retrieval call binding the contract method 0x67300041.
//
// Solidity: function exchangeRateStAVAXToAVAX() view returns(uint256)
func (_AvaLido *AvaLidoCallerSession) ExchangeRateStAVAXToAVAX() (*big.Int, error) {
	return _AvaLido.Contract.ExchangeRateStAVAXToAVAX(&_AvaLido.CallOpts)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_AvaLido *AvaLidoCaller) GetRoleAdmin(opts *bind.CallOpts, role [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "getRoleAdmin", role)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_AvaLido *AvaLidoSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _AvaLido.Contract.GetRoleAdmin(&_AvaLido.CallOpts, role)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_AvaLido *AvaLidoCallerSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _AvaLido.Contract.GetRoleAdmin(&_AvaLido.CallOpts, role)
}

// GetRoleMember is a free data retrieval call binding the contract method 0x9010d07c.
//
// Solidity: function getRoleMember(bytes32 role, uint256 index) view returns(address)
func (_AvaLido *AvaLidoCaller) GetRoleMember(opts *bind.CallOpts, role [32]byte, index *big.Int) (common.Address, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "getRoleMember", role, index)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetRoleMember is a free data retrieval call binding the contract method 0x9010d07c.
//
// Solidity: function getRoleMember(bytes32 role, uint256 index) view returns(address)
func (_AvaLido *AvaLidoSession) GetRoleMember(role [32]byte, index *big.Int) (common.Address, error) {
	return _AvaLido.Contract.GetRoleMember(&_AvaLido.CallOpts, role, index)
}

// GetRoleMember is a free data retrieval call binding the contract method 0x9010d07c.
//
// Solidity: function getRoleMember(bytes32 role, uint256 index) view returns(address)
func (_AvaLido *AvaLidoCallerSession) GetRoleMember(role [32]byte, index *big.Int) (common.Address, error) {
	return _AvaLido.Contract.GetRoleMember(&_AvaLido.CallOpts, role, index)
}

// GetRoleMemberCount is a free data retrieval call binding the contract method 0xca15c873.
//
// Solidity: function getRoleMemberCount(bytes32 role) view returns(uint256)
func (_AvaLido *AvaLidoCaller) GetRoleMemberCount(opts *bind.CallOpts, role [32]byte) (*big.Int, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "getRoleMemberCount", role)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetRoleMemberCount is a free data retrieval call binding the contract method 0xca15c873.
//
// Solidity: function getRoleMemberCount(bytes32 role) view returns(uint256)
func (_AvaLido *AvaLidoSession) GetRoleMemberCount(role [32]byte) (*big.Int, error) {
	return _AvaLido.Contract.GetRoleMemberCount(&_AvaLido.CallOpts, role)
}

// GetRoleMemberCount is a free data retrieval call binding the contract method 0xca15c873.
//
// Solidity: function getRoleMemberCount(bytes32 role) view returns(uint256)
func (_AvaLido *AvaLidoCallerSession) GetRoleMemberCount(role [32]byte) (*big.Int, error) {
	return _AvaLido.Contract.GetRoleMemberCount(&_AvaLido.CallOpts, role)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_AvaLido *AvaLidoCaller) HasRole(opts *bind.CallOpts, role [32]byte, account common.Address) (bool, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "hasRole", role, account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_AvaLido *AvaLidoSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _AvaLido.Contract.HasRole(&_AvaLido.CallOpts, role, account)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_AvaLido *AvaLidoCallerSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _AvaLido.Contract.HasRole(&_AvaLido.CallOpts, role, account)
}

// MaxProtocolControlledAVAX is a free data retrieval call binding the contract method 0x53524303.
//
// Solidity: function maxProtocolControlledAVAX() view returns(uint256)
func (_AvaLido *AvaLidoCaller) MaxProtocolControlledAVAX(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "maxProtocolControlledAVAX")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MaxProtocolControlledAVAX is a free data retrieval call binding the contract method 0x53524303.
//
// Solidity: function maxProtocolControlledAVAX() view returns(uint256)
func (_AvaLido *AvaLidoSession) MaxProtocolControlledAVAX() (*big.Int, error) {
	return _AvaLido.Contract.MaxProtocolControlledAVAX(&_AvaLido.CallOpts)
}

// MaxProtocolControlledAVAX is a free data retrieval call binding the contract method 0x53524303.
//
// Solidity: function maxProtocolControlledAVAX() view returns(uint256)
func (_AvaLido *AvaLidoCallerSession) MaxProtocolControlledAVAX() (*big.Int, error) {
	return _AvaLido.Contract.MaxProtocolControlledAVAX(&_AvaLido.CallOpts)
}

// MaxUnstakeRequests is a free data retrieval call binding the contract method 0xa7602c7e.
//
// Solidity: function maxUnstakeRequests() view returns(uint8)
func (_AvaLido *AvaLidoCaller) MaxUnstakeRequests(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "maxUnstakeRequests")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// MaxUnstakeRequests is a free data retrieval call binding the contract method 0xa7602c7e.
//
// Solidity: function maxUnstakeRequests() view returns(uint8)
func (_AvaLido *AvaLidoSession) MaxUnstakeRequests() (uint8, error) {
	return _AvaLido.Contract.MaxUnstakeRequests(&_AvaLido.CallOpts)
}

// MaxUnstakeRequests is a free data retrieval call binding the contract method 0xa7602c7e.
//
// Solidity: function maxUnstakeRequests() view returns(uint8)
func (_AvaLido *AvaLidoCallerSession) MaxUnstakeRequests() (uint8, error) {
	return _AvaLido.Contract.MaxUnstakeRequests(&_AvaLido.CallOpts)
}

// MinStakeAmount is a free data retrieval call binding the contract method 0xf1887684.
//
// Solidity: function minStakeAmount() view returns(uint256)
func (_AvaLido *AvaLidoCaller) MinStakeAmount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "minStakeAmount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinStakeAmount is a free data retrieval call binding the contract method 0xf1887684.
//
// Solidity: function minStakeAmount() view returns(uint256)
func (_AvaLido *AvaLidoSession) MinStakeAmount() (*big.Int, error) {
	return _AvaLido.Contract.MinStakeAmount(&_AvaLido.CallOpts)
}

// MinStakeAmount is a free data retrieval call binding the contract method 0xf1887684.
//
// Solidity: function minStakeAmount() view returns(uint256)
func (_AvaLido *AvaLidoCallerSession) MinStakeAmount() (*big.Int, error) {
	return _AvaLido.Contract.MinStakeAmount(&_AvaLido.CallOpts)
}

// MinStakeBatchAmount is a free data retrieval call binding the contract method 0xad1497fa.
//
// Solidity: function minStakeBatchAmount() view returns(uint256)
func (_AvaLido *AvaLidoCaller) MinStakeBatchAmount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "minStakeBatchAmount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinStakeBatchAmount is a free data retrieval call binding the contract method 0xad1497fa.
//
// Solidity: function minStakeBatchAmount() view returns(uint256)
func (_AvaLido *AvaLidoSession) MinStakeBatchAmount() (*big.Int, error) {
	return _AvaLido.Contract.MinStakeBatchAmount(&_AvaLido.CallOpts)
}

// MinStakeBatchAmount is a free data retrieval call binding the contract method 0xad1497fa.
//
// Solidity: function minStakeBatchAmount() view returns(uint256)
func (_AvaLido *AvaLidoCallerSession) MinStakeBatchAmount() (*big.Int, error) {
	return _AvaLido.Contract.MinStakeBatchAmount(&_AvaLido.CallOpts)
}

// MpcManager is a free data retrieval call binding the contract method 0x846b3c8b.
//
// Solidity: function mpcManager() view returns(address)
func (_AvaLido *AvaLidoCaller) MpcManager(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "mpcManager")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// MpcManager is a free data retrieval call binding the contract method 0x846b3c8b.
//
// Solidity: function mpcManager() view returns(address)
func (_AvaLido *AvaLidoSession) MpcManager() (common.Address, error) {
	return _AvaLido.Contract.MpcManager(&_AvaLido.CallOpts)
}

// MpcManager is a free data retrieval call binding the contract method 0x846b3c8b.
//
// Solidity: function mpcManager() view returns(address)
func (_AvaLido *AvaLidoCallerSession) MpcManager() (common.Address, error) {
	return _AvaLido.Contract.MpcManager(&_AvaLido.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_AvaLido *AvaLidoCaller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_AvaLido *AvaLidoSession) Name() (string, error) {
	return _AvaLido.Contract.Name(&_AvaLido.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_AvaLido *AvaLidoCallerSession) Name() (string, error) {
	return _AvaLido.Contract.Name(&_AvaLido.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_AvaLido *AvaLidoCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_AvaLido *AvaLidoSession) Paused() (bool, error) {
	return _AvaLido.Contract.Paused(&_AvaLido.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_AvaLido *AvaLidoCallerSession) Paused() (bool, error) {
	return _AvaLido.Contract.Paused(&_AvaLido.CallOpts)
}

// PrincipalTreasury is a free data retrieval call binding the contract method 0x1c0fc3f6.
//
// Solidity: function principalTreasury() view returns(address)
func (_AvaLido *AvaLidoCaller) PrincipalTreasury(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "principalTreasury")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PrincipalTreasury is a free data retrieval call binding the contract method 0x1c0fc3f6.
//
// Solidity: function principalTreasury() view returns(address)
func (_AvaLido *AvaLidoSession) PrincipalTreasury() (common.Address, error) {
	return _AvaLido.Contract.PrincipalTreasury(&_AvaLido.CallOpts)
}

// PrincipalTreasury is a free data retrieval call binding the contract method 0x1c0fc3f6.
//
// Solidity: function principalTreasury() view returns(address)
func (_AvaLido *AvaLidoCallerSession) PrincipalTreasury() (common.Address, error) {
	return _AvaLido.Contract.PrincipalTreasury(&_AvaLido.CallOpts)
}

// ProtocolControlledAVAX is a free data retrieval call binding the contract method 0xa23b4965.
//
// Solidity: function protocolControlledAVAX() view returns(uint256)
func (_AvaLido *AvaLidoCaller) ProtocolControlledAVAX(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "protocolControlledAVAX")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ProtocolControlledAVAX is a free data retrieval call binding the contract method 0xa23b4965.
//
// Solidity: function protocolControlledAVAX() view returns(uint256)
func (_AvaLido *AvaLidoSession) ProtocolControlledAVAX() (*big.Int, error) {
	return _AvaLido.Contract.ProtocolControlledAVAX(&_AvaLido.CallOpts)
}

// ProtocolControlledAVAX is a free data retrieval call binding the contract method 0xa23b4965.
//
// Solidity: function protocolControlledAVAX() view returns(uint256)
func (_AvaLido *AvaLidoCallerSession) ProtocolControlledAVAX() (*big.Int, error) {
	return _AvaLido.Contract.ProtocolControlledAVAX(&_AvaLido.CallOpts)
}

// ProtocolFeePercentage is a free data retrieval call binding the contract method 0x8e50e509.
//
// Solidity: function protocolFeePercentage() view returns(uint256)
func (_AvaLido *AvaLidoCaller) ProtocolFeePercentage(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "protocolFeePercentage")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ProtocolFeePercentage is a free data retrieval call binding the contract method 0x8e50e509.
//
// Solidity: function protocolFeePercentage() view returns(uint256)
func (_AvaLido *AvaLidoSession) ProtocolFeePercentage() (*big.Int, error) {
	return _AvaLido.Contract.ProtocolFeePercentage(&_AvaLido.CallOpts)
}

// ProtocolFeePercentage is a free data retrieval call binding the contract method 0x8e50e509.
//
// Solidity: function protocolFeePercentage() view returns(uint256)
func (_AvaLido *AvaLidoCallerSession) ProtocolFeePercentage() (*big.Int, error) {
	return _AvaLido.Contract.ProtocolFeePercentage(&_AvaLido.CallOpts)
}

// ProtocolFeeSplitter is a free data retrieval call binding the contract method 0x9d7710a5.
//
// Solidity: function protocolFeeSplitter() view returns(address)
func (_AvaLido *AvaLidoCaller) ProtocolFeeSplitter(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "protocolFeeSplitter")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// ProtocolFeeSplitter is a free data retrieval call binding the contract method 0x9d7710a5.
//
// Solidity: function protocolFeeSplitter() view returns(address)
func (_AvaLido *AvaLidoSession) ProtocolFeeSplitter() (common.Address, error) {
	return _AvaLido.Contract.ProtocolFeeSplitter(&_AvaLido.CallOpts)
}

// ProtocolFeeSplitter is a free data retrieval call binding the contract method 0x9d7710a5.
//
// Solidity: function protocolFeeSplitter() view returns(address)
func (_AvaLido *AvaLidoCallerSession) ProtocolFeeSplitter() (common.Address, error) {
	return _AvaLido.Contract.ProtocolFeeSplitter(&_AvaLido.CallOpts)
}

// RequestByIndex is a free data retrieval call binding the contract method 0x3d3da6ef.
//
// Solidity: function requestByIndex(uint256 requestIndex) view returns((address,uint64,uint256,uint256,uint256,uint256))
func (_AvaLido *AvaLidoCaller) RequestByIndex(opts *bind.CallOpts, requestIndex *big.Int) (UnstakeRequest, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "requestByIndex", requestIndex)

	if err != nil {
		return *new(UnstakeRequest), err
	}

	out0 := *abi.ConvertType(out[0], new(UnstakeRequest)).(*UnstakeRequest)

	return out0, err

}

// RequestByIndex is a free data retrieval call binding the contract method 0x3d3da6ef.
//
// Solidity: function requestByIndex(uint256 requestIndex) view returns((address,uint64,uint256,uint256,uint256,uint256))
func (_AvaLido *AvaLidoSession) RequestByIndex(requestIndex *big.Int) (UnstakeRequest, error) {
	return _AvaLido.Contract.RequestByIndex(&_AvaLido.CallOpts, requestIndex)
}

// RequestByIndex is a free data retrieval call binding the contract method 0x3d3da6ef.
//
// Solidity: function requestByIndex(uint256 requestIndex) view returns((address,uint64,uint256,uint256,uint256,uint256))
func (_AvaLido *AvaLidoCallerSession) RequestByIndex(requestIndex *big.Int) (UnstakeRequest, error) {
	return _AvaLido.Contract.RequestByIndex(&_AvaLido.CallOpts, requestIndex)
}

// RewardTreasury is a free data retrieval call binding the contract method 0xc7c934a1.
//
// Solidity: function rewardTreasury() view returns(address)
func (_AvaLido *AvaLidoCaller) RewardTreasury(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "rewardTreasury")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// RewardTreasury is a free data retrieval call binding the contract method 0xc7c934a1.
//
// Solidity: function rewardTreasury() view returns(address)
func (_AvaLido *AvaLidoSession) RewardTreasury() (common.Address, error) {
	return _AvaLido.Contract.RewardTreasury(&_AvaLido.CallOpts)
}

// RewardTreasury is a free data retrieval call binding the contract method 0xc7c934a1.
//
// Solidity: function rewardTreasury() view returns(address)
func (_AvaLido *AvaLidoCallerSession) RewardTreasury() (common.Address, error) {
	return _AvaLido.Contract.RewardTreasury(&_AvaLido.CallOpts)
}

// StAVAXToAVAX is a free data retrieval call binding the contract method 0xbc56684a.
//
// Solidity: function stAVAXToAVAX(uint256 totalControlled, uint256 stAvaxAmount) view returns(uint256)
func (_AvaLido *AvaLidoCaller) StAVAXToAVAX(opts *bind.CallOpts, totalControlled *big.Int, stAvaxAmount *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "stAVAXToAVAX", totalControlled, stAvaxAmount)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// StAVAXToAVAX is a free data retrieval call binding the contract method 0xbc56684a.
//
// Solidity: function stAVAXToAVAX(uint256 totalControlled, uint256 stAvaxAmount) view returns(uint256)
func (_AvaLido *AvaLidoSession) StAVAXToAVAX(totalControlled *big.Int, stAvaxAmount *big.Int) (*big.Int, error) {
	return _AvaLido.Contract.StAVAXToAVAX(&_AvaLido.CallOpts, totalControlled, stAvaxAmount)
}

// StAVAXToAVAX is a free data retrieval call binding the contract method 0xbc56684a.
//
// Solidity: function stAVAXToAVAX(uint256 totalControlled, uint256 stAvaxAmount) view returns(uint256)
func (_AvaLido *AvaLidoCallerSession) StAVAXToAVAX(totalControlled *big.Int, stAvaxAmount *big.Int) (*big.Int, error) {
	return _AvaLido.Contract.StAVAXToAVAX(&_AvaLido.CallOpts, totalControlled, stAvaxAmount)
}

// StakePeriod is a free data retrieval call binding the contract method 0xc1699a99.
//
// Solidity: function stakePeriod() view returns(uint256)
func (_AvaLido *AvaLidoCaller) StakePeriod(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "stakePeriod")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// StakePeriod is a free data retrieval call binding the contract method 0xc1699a99.
//
// Solidity: function stakePeriod() view returns(uint256)
func (_AvaLido *AvaLidoSession) StakePeriod() (*big.Int, error) {
	return _AvaLido.Contract.StakePeriod(&_AvaLido.CallOpts)
}

// StakePeriod is a free data retrieval call binding the contract method 0xc1699a99.
//
// Solidity: function stakePeriod() view returns(uint256)
func (_AvaLido *AvaLidoCallerSession) StakePeriod() (*big.Int, error) {
	return _AvaLido.Contract.StakePeriod(&_AvaLido.CallOpts)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_AvaLido *AvaLidoCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_AvaLido *AvaLidoSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _AvaLido.Contract.SupportsInterface(&_AvaLido.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_AvaLido *AvaLidoCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _AvaLido.Contract.SupportsInterface(&_AvaLido.CallOpts, interfaceId)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_AvaLido *AvaLidoCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_AvaLido *AvaLidoSession) Symbol() (string, error) {
	return _AvaLido.Contract.Symbol(&_AvaLido.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_AvaLido *AvaLidoCallerSession) Symbol() (string, error) {
	return _AvaLido.Contract.Symbol(&_AvaLido.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_AvaLido *AvaLidoCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_AvaLido *AvaLidoSession) TotalSupply() (*big.Int, error) {
	return _AvaLido.Contract.TotalSupply(&_AvaLido.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_AvaLido *AvaLidoCallerSession) TotalSupply() (*big.Int, error) {
	return _AvaLido.Contract.TotalSupply(&_AvaLido.CallOpts)
}

// UnstakeRequestCount is a free data retrieval call binding the contract method 0xad874808.
//
// Solidity: function unstakeRequestCount(address ) view returns(uint8)
func (_AvaLido *AvaLidoCaller) UnstakeRequestCount(opts *bind.CallOpts, arg0 common.Address) (uint8, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "unstakeRequestCount", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// UnstakeRequestCount is a free data retrieval call binding the contract method 0xad874808.
//
// Solidity: function unstakeRequestCount(address ) view returns(uint8)
func (_AvaLido *AvaLidoSession) UnstakeRequestCount(arg0 common.Address) (uint8, error) {
	return _AvaLido.Contract.UnstakeRequestCount(&_AvaLido.CallOpts, arg0)
}

// UnstakeRequestCount is a free data retrieval call binding the contract method 0xad874808.
//
// Solidity: function unstakeRequestCount(address ) view returns(uint8)
func (_AvaLido *AvaLidoCallerSession) UnstakeRequestCount(arg0 common.Address) (uint8, error) {
	return _AvaLido.Contract.UnstakeRequestCount(&_AvaLido.CallOpts, arg0)
}

// UnstakeRequests is a free data retrieval call binding the contract method 0xf87975af.
//
// Solidity: function unstakeRequests(uint256 ) view returns(address requester, uint64 requestedAt, uint256 amountRequested, uint256 amountFilled, uint256 amountClaimed, uint256 stAVAXLocked)
func (_AvaLido *AvaLidoCaller) UnstakeRequests(opts *bind.CallOpts, arg0 *big.Int) (struct {
	Requester       common.Address
	RequestedAt     uint64
	AmountRequested *big.Int
	AmountFilled    *big.Int
	AmountClaimed   *big.Int
	StAVAXLocked    *big.Int
}, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "unstakeRequests", arg0)

	outstruct := new(struct {
		Requester       common.Address
		RequestedAt     uint64
		AmountRequested *big.Int
		AmountFilled    *big.Int
		AmountClaimed   *big.Int
		StAVAXLocked    *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Requester = *abi.ConvertType(out[0], new(common.Address)).(*common.Address)
	outstruct.RequestedAt = *abi.ConvertType(out[1], new(uint64)).(*uint64)
	outstruct.AmountRequested = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.AmountFilled = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)
	outstruct.AmountClaimed = *abi.ConvertType(out[4], new(*big.Int)).(**big.Int)
	outstruct.StAVAXLocked = *abi.ConvertType(out[5], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// UnstakeRequests is a free data retrieval call binding the contract method 0xf87975af.
//
// Solidity: function unstakeRequests(uint256 ) view returns(address requester, uint64 requestedAt, uint256 amountRequested, uint256 amountFilled, uint256 amountClaimed, uint256 stAVAXLocked)
func (_AvaLido *AvaLidoSession) UnstakeRequests(arg0 *big.Int) (struct {
	Requester       common.Address
	RequestedAt     uint64
	AmountRequested *big.Int
	AmountFilled    *big.Int
	AmountClaimed   *big.Int
	StAVAXLocked    *big.Int
}, error) {
	return _AvaLido.Contract.UnstakeRequests(&_AvaLido.CallOpts, arg0)
}

// UnstakeRequests is a free data retrieval call binding the contract method 0xf87975af.
//
// Solidity: function unstakeRequests(uint256 ) view returns(address requester, uint64 requestedAt, uint256 amountRequested, uint256 amountFilled, uint256 amountClaimed, uint256 stAVAXLocked)
func (_AvaLido *AvaLidoCallerSession) UnstakeRequests(arg0 *big.Int) (struct {
	Requester       common.Address
	RequestedAt     uint64
	AmountRequested *big.Int
	AmountFilled    *big.Int
	AmountClaimed   *big.Int
	StAVAXLocked    *big.Int
}, error) {
	return _AvaLido.Contract.UnstakeRequests(&_AvaLido.CallOpts, arg0)
}

// ValidatorSelector is a free data retrieval call binding the contract method 0xe039e3cc.
//
// Solidity: function validatorSelector() view returns(address)
func (_AvaLido *AvaLidoCaller) ValidatorSelector(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AvaLido.contract.Call(opts, &out, "validatorSelector")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// ValidatorSelector is a free data retrieval call binding the contract method 0xe039e3cc.
//
// Solidity: function validatorSelector() view returns(address)
func (_AvaLido *AvaLidoSession) ValidatorSelector() (common.Address, error) {
	return _AvaLido.Contract.ValidatorSelector(&_AvaLido.CallOpts)
}

// ValidatorSelector is a free data retrieval call binding the contract method 0xe039e3cc.
//
// Solidity: function validatorSelector() view returns(address)
func (_AvaLido *AvaLidoCallerSession) ValidatorSelector() (common.Address, error) {
	return _AvaLido.Contract.ValidatorSelector(&_AvaLido.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_AvaLido *AvaLidoTransactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_AvaLido *AvaLidoSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.Approve(&_AvaLido.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_AvaLido *AvaLidoTransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.Approve(&_AvaLido.TransactOpts, spender, amount)
}

// Claim is a paid mutator transaction binding the contract method 0xc3490263.
//
// Solidity: function claim(uint256 requestIndex, uint256 amount) returns()
func (_AvaLido *AvaLidoTransactor) Claim(opts *bind.TransactOpts, requestIndex *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "claim", requestIndex, amount)
}

// Claim is a paid mutator transaction binding the contract method 0xc3490263.
//
// Solidity: function claim(uint256 requestIndex, uint256 amount) returns()
func (_AvaLido *AvaLidoSession) Claim(requestIndex *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.Claim(&_AvaLido.TransactOpts, requestIndex, amount)
}

// Claim is a paid mutator transaction binding the contract method 0xc3490263.
//
// Solidity: function claim(uint256 requestIndex, uint256 amount) returns()
func (_AvaLido *AvaLidoTransactorSession) Claim(requestIndex *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.Claim(&_AvaLido.TransactOpts, requestIndex, amount)
}

// ClaimRewards is a paid mutator transaction binding the contract method 0x372500ab.
//
// Solidity: function claimRewards() returns()
func (_AvaLido *AvaLidoTransactor) ClaimRewards(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "claimRewards")
}

// ClaimRewards is a paid mutator transaction binding the contract method 0x372500ab.
//
// Solidity: function claimRewards() returns()
func (_AvaLido *AvaLidoSession) ClaimRewards() (*types.Transaction, error) {
	return _AvaLido.Contract.ClaimRewards(&_AvaLido.TransactOpts)
}

// ClaimRewards is a paid mutator transaction binding the contract method 0x372500ab.
//
// Solidity: function claimRewards() returns()
func (_AvaLido *AvaLidoTransactorSession) ClaimRewards() (*types.Transaction, error) {
	return _AvaLido.Contract.ClaimRewards(&_AvaLido.TransactOpts)
}

// ClaimUnstakedPrincipals is a paid mutator transaction binding the contract method 0x446ed20b.
//
// Solidity: function claimUnstakedPrincipals() returns()
func (_AvaLido *AvaLidoTransactor) ClaimUnstakedPrincipals(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "claimUnstakedPrincipals")
}

// ClaimUnstakedPrincipals is a paid mutator transaction binding the contract method 0x446ed20b.
//
// Solidity: function claimUnstakedPrincipals() returns()
func (_AvaLido *AvaLidoSession) ClaimUnstakedPrincipals() (*types.Transaction, error) {
	return _AvaLido.Contract.ClaimUnstakedPrincipals(&_AvaLido.TransactOpts)
}

// ClaimUnstakedPrincipals is a paid mutator transaction binding the contract method 0x446ed20b.
//
// Solidity: function claimUnstakedPrincipals() returns()
func (_AvaLido *AvaLidoTransactorSession) ClaimUnstakedPrincipals() (*types.Transaction, error) {
	return _AvaLido.Contract.ClaimUnstakedPrincipals(&_AvaLido.TransactOpts)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_AvaLido *AvaLidoTransactor) DecreaseAllowance(opts *bind.TransactOpts, spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "decreaseAllowance", spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_AvaLido *AvaLidoSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.DecreaseAllowance(&_AvaLido.TransactOpts, spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_AvaLido *AvaLidoTransactorSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.DecreaseAllowance(&_AvaLido.TransactOpts, spender, subtractedValue)
}

// Deposit is a paid mutator transaction binding the contract method 0xd0e30db0.
//
// Solidity: function deposit() payable returns()
func (_AvaLido *AvaLidoTransactor) Deposit(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "deposit")
}

// Deposit is a paid mutator transaction binding the contract method 0xd0e30db0.
//
// Solidity: function deposit() payable returns()
func (_AvaLido *AvaLidoSession) Deposit() (*types.Transaction, error) {
	return _AvaLido.Contract.Deposit(&_AvaLido.TransactOpts)
}

// Deposit is a paid mutator transaction binding the contract method 0xd0e30db0.
//
// Solidity: function deposit() payable returns()
func (_AvaLido *AvaLidoTransactorSession) Deposit() (*types.Transaction, error) {
	return _AvaLido.Contract.Deposit(&_AvaLido.TransactOpts)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_AvaLido *AvaLidoTransactor) GrantRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "grantRole", role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_AvaLido *AvaLidoSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AvaLido.Contract.GrantRole(&_AvaLido.TransactOpts, role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_AvaLido *AvaLidoTransactorSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AvaLido.Contract.GrantRole(&_AvaLido.TransactOpts, role, account)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_AvaLido *AvaLidoTransactor) IncreaseAllowance(opts *bind.TransactOpts, spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "increaseAllowance", spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_AvaLido *AvaLidoSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.IncreaseAllowance(&_AvaLido.TransactOpts, spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_AvaLido *AvaLidoTransactorSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.IncreaseAllowance(&_AvaLido.TransactOpts, spender, addedValue)
}

// Initialize is a paid mutator transaction binding the contract method 0xf8c8765e.
//
// Solidity: function initialize(address lidoFeeAddress, address authorFeeAddress, address validatorSelectorAddress, address _mpcManagerAddress) returns()
func (_AvaLido *AvaLidoTransactor) Initialize(opts *bind.TransactOpts, lidoFeeAddress common.Address, authorFeeAddress common.Address, validatorSelectorAddress common.Address, _mpcManagerAddress common.Address) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "initialize", lidoFeeAddress, authorFeeAddress, validatorSelectorAddress, _mpcManagerAddress)
}

// Initialize is a paid mutator transaction binding the contract method 0xf8c8765e.
//
// Solidity: function initialize(address lidoFeeAddress, address authorFeeAddress, address validatorSelectorAddress, address _mpcManagerAddress) returns()
func (_AvaLido *AvaLidoSession) Initialize(lidoFeeAddress common.Address, authorFeeAddress common.Address, validatorSelectorAddress common.Address, _mpcManagerAddress common.Address) (*types.Transaction, error) {
	return _AvaLido.Contract.Initialize(&_AvaLido.TransactOpts, lidoFeeAddress, authorFeeAddress, validatorSelectorAddress, _mpcManagerAddress)
}

// Initialize is a paid mutator transaction binding the contract method 0xf8c8765e.
//
// Solidity: function initialize(address lidoFeeAddress, address authorFeeAddress, address validatorSelectorAddress, address _mpcManagerAddress) returns()
func (_AvaLido *AvaLidoTransactorSession) Initialize(lidoFeeAddress common.Address, authorFeeAddress common.Address, validatorSelectorAddress common.Address, _mpcManagerAddress common.Address) (*types.Transaction, error) {
	return _AvaLido.Contract.Initialize(&_AvaLido.TransactOpts, lidoFeeAddress, authorFeeAddress, validatorSelectorAddress, _mpcManagerAddress)
}

// InitiateStake is a paid mutator transaction binding the contract method 0xdb4567d3.
//
// Solidity: function initiateStake() returns(uint256)
func (_AvaLido *AvaLidoTransactor) InitiateStake(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "initiateStake")
}

// InitiateStake is a paid mutator transaction binding the contract method 0xdb4567d3.
//
// Solidity: function initiateStake() returns(uint256)
func (_AvaLido *AvaLidoSession) InitiateStake() (*types.Transaction, error) {
	return _AvaLido.Contract.InitiateStake(&_AvaLido.TransactOpts)
}

// InitiateStake is a paid mutator transaction binding the contract method 0xdb4567d3.
//
// Solidity: function initiateStake() returns(uint256)
func (_AvaLido *AvaLidoTransactorSession) InitiateStake() (*types.Transaction, error) {
	return _AvaLido.Contract.InitiateStake(&_AvaLido.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_AvaLido *AvaLidoTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_AvaLido *AvaLidoSession) Pause() (*types.Transaction, error) {
	return _AvaLido.Contract.Pause(&_AvaLido.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_AvaLido *AvaLidoTransactorSession) Pause() (*types.Transaction, error) {
	return _AvaLido.Contract.Pause(&_AvaLido.TransactOpts)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_AvaLido *AvaLidoTransactor) RenounceRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "renounceRole", role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_AvaLido *AvaLidoSession) RenounceRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AvaLido.Contract.RenounceRole(&_AvaLido.TransactOpts, role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_AvaLido *AvaLidoTransactorSession) RenounceRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AvaLido.Contract.RenounceRole(&_AvaLido.TransactOpts, role, account)
}

// RequestWithdrawal is a paid mutator transaction binding the contract method 0x9ee679e8.
//
// Solidity: function requestWithdrawal(uint256 stAVAXAmount) returns(uint256)
func (_AvaLido *AvaLidoTransactor) RequestWithdrawal(opts *bind.TransactOpts, stAVAXAmount *big.Int) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "requestWithdrawal", stAVAXAmount)
}

// RequestWithdrawal is a paid mutator transaction binding the contract method 0x9ee679e8.
//
// Solidity: function requestWithdrawal(uint256 stAVAXAmount) returns(uint256)
func (_AvaLido *AvaLidoSession) RequestWithdrawal(stAVAXAmount *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.RequestWithdrawal(&_AvaLido.TransactOpts, stAVAXAmount)
}

// RequestWithdrawal is a paid mutator transaction binding the contract method 0x9ee679e8.
//
// Solidity: function requestWithdrawal(uint256 stAVAXAmount) returns(uint256)
func (_AvaLido *AvaLidoTransactorSession) RequestWithdrawal(stAVAXAmount *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.RequestWithdrawal(&_AvaLido.TransactOpts, stAVAXAmount)
}

// Resume is a paid mutator transaction binding the contract method 0x046f7da2.
//
// Solidity: function resume() returns()
func (_AvaLido *AvaLidoTransactor) Resume(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "resume")
}

// Resume is a paid mutator transaction binding the contract method 0x046f7da2.
//
// Solidity: function resume() returns()
func (_AvaLido *AvaLidoSession) Resume() (*types.Transaction, error) {
	return _AvaLido.Contract.Resume(&_AvaLido.TransactOpts)
}

// Resume is a paid mutator transaction binding the contract method 0x046f7da2.
//
// Solidity: function resume() returns()
func (_AvaLido *AvaLidoTransactorSession) Resume() (*types.Transaction, error) {
	return _AvaLido.Contract.Resume(&_AvaLido.TransactOpts)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_AvaLido *AvaLidoTransactor) RevokeRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "revokeRole", role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_AvaLido *AvaLidoSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AvaLido.Contract.RevokeRole(&_AvaLido.TransactOpts, role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_AvaLido *AvaLidoTransactorSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _AvaLido.Contract.RevokeRole(&_AvaLido.TransactOpts, role, account)
}

// SetMaxProtocolControlledAVAX is a paid mutator transaction binding the contract method 0x818a8e4c.
//
// Solidity: function setMaxProtocolControlledAVAX(uint256 _maxProtocolControlledAVAX) returns()
func (_AvaLido *AvaLidoTransactor) SetMaxProtocolControlledAVAX(opts *bind.TransactOpts, _maxProtocolControlledAVAX *big.Int) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "setMaxProtocolControlledAVAX", _maxProtocolControlledAVAX)
}

// SetMaxProtocolControlledAVAX is a paid mutator transaction binding the contract method 0x818a8e4c.
//
// Solidity: function setMaxProtocolControlledAVAX(uint256 _maxProtocolControlledAVAX) returns()
func (_AvaLido *AvaLidoSession) SetMaxProtocolControlledAVAX(_maxProtocolControlledAVAX *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.SetMaxProtocolControlledAVAX(&_AvaLido.TransactOpts, _maxProtocolControlledAVAX)
}

// SetMaxProtocolControlledAVAX is a paid mutator transaction binding the contract method 0x818a8e4c.
//
// Solidity: function setMaxProtocolControlledAVAX(uint256 _maxProtocolControlledAVAX) returns()
func (_AvaLido *AvaLidoTransactorSession) SetMaxProtocolControlledAVAX(_maxProtocolControlledAVAX *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.SetMaxProtocolControlledAVAX(&_AvaLido.TransactOpts, _maxProtocolControlledAVAX)
}

// SetMaxUnstakeRequests is a paid mutator transaction binding the contract method 0x1031eb9c.
//
// Solidity: function setMaxUnstakeRequests(uint8 _maxUnstakeRequests) returns()
func (_AvaLido *AvaLidoTransactor) SetMaxUnstakeRequests(opts *bind.TransactOpts, _maxUnstakeRequests uint8) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "setMaxUnstakeRequests", _maxUnstakeRequests)
}

// SetMaxUnstakeRequests is a paid mutator transaction binding the contract method 0x1031eb9c.
//
// Solidity: function setMaxUnstakeRequests(uint8 _maxUnstakeRequests) returns()
func (_AvaLido *AvaLidoSession) SetMaxUnstakeRequests(_maxUnstakeRequests uint8) (*types.Transaction, error) {
	return _AvaLido.Contract.SetMaxUnstakeRequests(&_AvaLido.TransactOpts, _maxUnstakeRequests)
}

// SetMaxUnstakeRequests is a paid mutator transaction binding the contract method 0x1031eb9c.
//
// Solidity: function setMaxUnstakeRequests(uint8 _maxUnstakeRequests) returns()
func (_AvaLido *AvaLidoTransactorSession) SetMaxUnstakeRequests(_maxUnstakeRequests uint8) (*types.Transaction, error) {
	return _AvaLido.Contract.SetMaxUnstakeRequests(&_AvaLido.TransactOpts, _maxUnstakeRequests)
}

// SetMinStakeAmount is a paid mutator transaction binding the contract method 0xeb4af045.
//
// Solidity: function setMinStakeAmount(uint256 _minStakeAmount) returns()
func (_AvaLido *AvaLidoTransactor) SetMinStakeAmount(opts *bind.TransactOpts, _minStakeAmount *big.Int) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "setMinStakeAmount", _minStakeAmount)
}

// SetMinStakeAmount is a paid mutator transaction binding the contract method 0xeb4af045.
//
// Solidity: function setMinStakeAmount(uint256 _minStakeAmount) returns()
func (_AvaLido *AvaLidoSession) SetMinStakeAmount(_minStakeAmount *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.SetMinStakeAmount(&_AvaLido.TransactOpts, _minStakeAmount)
}

// SetMinStakeAmount is a paid mutator transaction binding the contract method 0xeb4af045.
//
// Solidity: function setMinStakeAmount(uint256 _minStakeAmount) returns()
func (_AvaLido *AvaLidoTransactorSession) SetMinStakeAmount(_minStakeAmount *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.SetMinStakeAmount(&_AvaLido.TransactOpts, _minStakeAmount)
}

// SetMinStakeBatchAmount is a paid mutator transaction binding the contract method 0x262b1f9e.
//
// Solidity: function setMinStakeBatchAmount(uint256 _minStakeBatchAmount) returns()
func (_AvaLido *AvaLidoTransactor) SetMinStakeBatchAmount(opts *bind.TransactOpts, _minStakeBatchAmount *big.Int) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "setMinStakeBatchAmount", _minStakeBatchAmount)
}

// SetMinStakeBatchAmount is a paid mutator transaction binding the contract method 0x262b1f9e.
//
// Solidity: function setMinStakeBatchAmount(uint256 _minStakeBatchAmount) returns()
func (_AvaLido *AvaLidoSession) SetMinStakeBatchAmount(_minStakeBatchAmount *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.SetMinStakeBatchAmount(&_AvaLido.TransactOpts, _minStakeBatchAmount)
}

// SetMinStakeBatchAmount is a paid mutator transaction binding the contract method 0x262b1f9e.
//
// Solidity: function setMinStakeBatchAmount(uint256 _minStakeBatchAmount) returns()
func (_AvaLido *AvaLidoTransactorSession) SetMinStakeBatchAmount(_minStakeBatchAmount *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.SetMinStakeBatchAmount(&_AvaLido.TransactOpts, _minStakeBatchAmount)
}

// SetPrincipalTreasuryAddress is a paid mutator transaction binding the contract method 0xd1f8aaac.
//
// Solidity: function setPrincipalTreasuryAddress(address _address) returns()
func (_AvaLido *AvaLidoTransactor) SetPrincipalTreasuryAddress(opts *bind.TransactOpts, _address common.Address) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "setPrincipalTreasuryAddress", _address)
}

// SetPrincipalTreasuryAddress is a paid mutator transaction binding the contract method 0xd1f8aaac.
//
// Solidity: function setPrincipalTreasuryAddress(address _address) returns()
func (_AvaLido *AvaLidoSession) SetPrincipalTreasuryAddress(_address common.Address) (*types.Transaction, error) {
	return _AvaLido.Contract.SetPrincipalTreasuryAddress(&_AvaLido.TransactOpts, _address)
}

// SetPrincipalTreasuryAddress is a paid mutator transaction binding the contract method 0xd1f8aaac.
//
// Solidity: function setPrincipalTreasuryAddress(address _address) returns()
func (_AvaLido *AvaLidoTransactorSession) SetPrincipalTreasuryAddress(_address common.Address) (*types.Transaction, error) {
	return _AvaLido.Contract.SetPrincipalTreasuryAddress(&_AvaLido.TransactOpts, _address)
}

// SetProtocolFeePercentage is a paid mutator transaction binding the contract method 0xd8a5e936.
//
// Solidity: function setProtocolFeePercentage(uint256 _protocolFeePercentage) returns()
func (_AvaLido *AvaLidoTransactor) SetProtocolFeePercentage(opts *bind.TransactOpts, _protocolFeePercentage *big.Int) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "setProtocolFeePercentage", _protocolFeePercentage)
}

// SetProtocolFeePercentage is a paid mutator transaction binding the contract method 0xd8a5e936.
//
// Solidity: function setProtocolFeePercentage(uint256 _protocolFeePercentage) returns()
func (_AvaLido *AvaLidoSession) SetProtocolFeePercentage(_protocolFeePercentage *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.SetProtocolFeePercentage(&_AvaLido.TransactOpts, _protocolFeePercentage)
}

// SetProtocolFeePercentage is a paid mutator transaction binding the contract method 0xd8a5e936.
//
// Solidity: function setProtocolFeePercentage(uint256 _protocolFeePercentage) returns()
func (_AvaLido *AvaLidoTransactorSession) SetProtocolFeePercentage(_protocolFeePercentage *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.SetProtocolFeePercentage(&_AvaLido.TransactOpts, _protocolFeePercentage)
}

// SetProtocolFeeSplit is a paid mutator transaction binding the contract method 0x2659bc15.
//
// Solidity: function setProtocolFeeSplit(address[] paymentAddresses, uint256[] paymentSplit) returns()
func (_AvaLido *AvaLidoTransactor) SetProtocolFeeSplit(opts *bind.TransactOpts, paymentAddresses []common.Address, paymentSplit []*big.Int) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "setProtocolFeeSplit", paymentAddresses, paymentSplit)
}

// SetProtocolFeeSplit is a paid mutator transaction binding the contract method 0x2659bc15.
//
// Solidity: function setProtocolFeeSplit(address[] paymentAddresses, uint256[] paymentSplit) returns()
func (_AvaLido *AvaLidoSession) SetProtocolFeeSplit(paymentAddresses []common.Address, paymentSplit []*big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.SetProtocolFeeSplit(&_AvaLido.TransactOpts, paymentAddresses, paymentSplit)
}

// SetProtocolFeeSplit is a paid mutator transaction binding the contract method 0x2659bc15.
//
// Solidity: function setProtocolFeeSplit(address[] paymentAddresses, uint256[] paymentSplit) returns()
func (_AvaLido *AvaLidoTransactorSession) SetProtocolFeeSplit(paymentAddresses []common.Address, paymentSplit []*big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.SetProtocolFeeSplit(&_AvaLido.TransactOpts, paymentAddresses, paymentSplit)
}

// SetRewardTreasuryAddress is a paid mutator transaction binding the contract method 0xcb1045d0.
//
// Solidity: function setRewardTreasuryAddress(address _address) returns()
func (_AvaLido *AvaLidoTransactor) SetRewardTreasuryAddress(opts *bind.TransactOpts, _address common.Address) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "setRewardTreasuryAddress", _address)
}

// SetRewardTreasuryAddress is a paid mutator transaction binding the contract method 0xcb1045d0.
//
// Solidity: function setRewardTreasuryAddress(address _address) returns()
func (_AvaLido *AvaLidoSession) SetRewardTreasuryAddress(_address common.Address) (*types.Transaction, error) {
	return _AvaLido.Contract.SetRewardTreasuryAddress(&_AvaLido.TransactOpts, _address)
}

// SetRewardTreasuryAddress is a paid mutator transaction binding the contract method 0xcb1045d0.
//
// Solidity: function setRewardTreasuryAddress(address _address) returns()
func (_AvaLido *AvaLidoTransactorSession) SetRewardTreasuryAddress(_address common.Address) (*types.Transaction, error) {
	return _AvaLido.Contract.SetRewardTreasuryAddress(&_AvaLido.TransactOpts, _address)
}

// SetStakePeriod is a paid mutator transaction binding the contract method 0x1e6b4c6f.
//
// Solidity: function setStakePeriod(uint256 _stakePeriod) returns()
func (_AvaLido *AvaLidoTransactor) SetStakePeriod(opts *bind.TransactOpts, _stakePeriod *big.Int) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "setStakePeriod", _stakePeriod)
}

// SetStakePeriod is a paid mutator transaction binding the contract method 0x1e6b4c6f.
//
// Solidity: function setStakePeriod(uint256 _stakePeriod) returns()
func (_AvaLido *AvaLidoSession) SetStakePeriod(_stakePeriod *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.SetStakePeriod(&_AvaLido.TransactOpts, _stakePeriod)
}

// SetStakePeriod is a paid mutator transaction binding the contract method 0x1e6b4c6f.
//
// Solidity: function setStakePeriod(uint256 _stakePeriod) returns()
func (_AvaLido *AvaLidoTransactorSession) SetStakePeriod(_stakePeriod *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.SetStakePeriod(&_AvaLido.TransactOpts, _stakePeriod)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_AvaLido *AvaLidoTransactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_AvaLido *AvaLidoSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.Transfer(&_AvaLido.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_AvaLido *AvaLidoTransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.Transfer(&_AvaLido.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_AvaLido *AvaLidoTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _AvaLido.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_AvaLido *AvaLidoSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.TransferFrom(&_AvaLido.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_AvaLido *AvaLidoTransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _AvaLido.Contract.TransferFrom(&_AvaLido.TransactOpts, from, to, amount)
}

// AvaLidoApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the AvaLido contract.
type AvaLidoApprovalIterator struct {
	Event *AvaLidoApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AvaLidoApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AvaLidoApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AvaLidoApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AvaLidoApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AvaLidoApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AvaLidoApproval represents a Approval event raised by the AvaLido contract.
type AvaLidoApproval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_AvaLido *AvaLidoFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*AvaLidoApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _AvaLido.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &AvaLidoApprovalIterator{contract: _AvaLido.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_AvaLido *AvaLidoFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *AvaLidoApproval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _AvaLido.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AvaLidoApproval)
				if err := _AvaLido.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_AvaLido *AvaLidoFilterer) ParseApproval(log types.Log) (*AvaLidoApproval, error) {
	event := new(AvaLidoApproval)
	if err := _AvaLido.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AvaLidoClaimEventIterator is returned from FilterClaimEvent and is used to iterate over the raw logs and unpacked data for ClaimEvent events raised by the AvaLido contract.
type AvaLidoClaimEventIterator struct {
	Event *AvaLidoClaimEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AvaLidoClaimEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AvaLidoClaimEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AvaLidoClaimEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AvaLidoClaimEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AvaLidoClaimEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AvaLidoClaimEvent represents a ClaimEvent event raised by the AvaLido contract.
type AvaLidoClaimEvent struct {
	From         common.Address
	ClaimAmount  *big.Int
	FinalClaim   bool
	RequestIndex *big.Int
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterClaimEvent is a free log retrieval operation binding the contract event 0x30694308508a999b8c8335a05cfb5919eb0bd4d9415c29592c8f558145dbfaa5.
//
// Solidity: event ClaimEvent(address indexed from, uint256 claimAmount, bool indexed finalClaim, uint256 requestIndex)
func (_AvaLido *AvaLidoFilterer) FilterClaimEvent(opts *bind.FilterOpts, from []common.Address, finalClaim []bool) (*AvaLidoClaimEventIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	var finalClaimRule []interface{}
	for _, finalClaimItem := range finalClaim {
		finalClaimRule = append(finalClaimRule, finalClaimItem)
	}

	logs, sub, err := _AvaLido.contract.FilterLogs(opts, "ClaimEvent", fromRule, finalClaimRule)
	if err != nil {
		return nil, err
	}
	return &AvaLidoClaimEventIterator{contract: _AvaLido.contract, event: "ClaimEvent", logs: logs, sub: sub}, nil
}

// WatchClaimEvent is a free log subscription operation binding the contract event 0x30694308508a999b8c8335a05cfb5919eb0bd4d9415c29592c8f558145dbfaa5.
//
// Solidity: event ClaimEvent(address indexed from, uint256 claimAmount, bool indexed finalClaim, uint256 requestIndex)
func (_AvaLido *AvaLidoFilterer) WatchClaimEvent(opts *bind.WatchOpts, sink chan<- *AvaLidoClaimEvent, from []common.Address, finalClaim []bool) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	var finalClaimRule []interface{}
	for _, finalClaimItem := range finalClaim {
		finalClaimRule = append(finalClaimRule, finalClaimItem)
	}

	logs, sub, err := _AvaLido.contract.WatchLogs(opts, "ClaimEvent", fromRule, finalClaimRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AvaLidoClaimEvent)
				if err := _AvaLido.contract.UnpackLog(event, "ClaimEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseClaimEvent is a log parse operation binding the contract event 0x30694308508a999b8c8335a05cfb5919eb0bd4d9415c29592c8f558145dbfaa5.
//
// Solidity: event ClaimEvent(address indexed from, uint256 claimAmount, bool indexed finalClaim, uint256 requestIndex)
func (_AvaLido *AvaLidoFilterer) ParseClaimEvent(log types.Log) (*AvaLidoClaimEvent, error) {
	event := new(AvaLidoClaimEvent)
	if err := _AvaLido.contract.UnpackLog(event, "ClaimEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AvaLidoDepositEventIterator is returned from FilterDepositEvent and is used to iterate over the raw logs and unpacked data for DepositEvent events raised by the AvaLido contract.
type AvaLidoDepositEventIterator struct {
	Event *AvaLidoDepositEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AvaLidoDepositEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AvaLidoDepositEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AvaLidoDepositEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AvaLidoDepositEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AvaLidoDepositEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AvaLidoDepositEvent represents a DepositEvent event raised by the AvaLido contract.
type AvaLidoDepositEvent struct {
	From      common.Address
	Amount    *big.Int
	Timestamp *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterDepositEvent is a free log retrieval operation binding the contract event 0xad40ae5dc69974ba932d08b0a608e89109412d41d04850f5196f144875ae2660.
//
// Solidity: event DepositEvent(address indexed from, uint256 amount, uint256 timestamp)
func (_AvaLido *AvaLidoFilterer) FilterDepositEvent(opts *bind.FilterOpts, from []common.Address) (*AvaLidoDepositEventIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _AvaLido.contract.FilterLogs(opts, "DepositEvent", fromRule)
	if err != nil {
		return nil, err
	}
	return &AvaLidoDepositEventIterator{contract: _AvaLido.contract, event: "DepositEvent", logs: logs, sub: sub}, nil
}

// WatchDepositEvent is a free log subscription operation binding the contract event 0xad40ae5dc69974ba932d08b0a608e89109412d41d04850f5196f144875ae2660.
//
// Solidity: event DepositEvent(address indexed from, uint256 amount, uint256 timestamp)
func (_AvaLido *AvaLidoFilterer) WatchDepositEvent(opts *bind.WatchOpts, sink chan<- *AvaLidoDepositEvent, from []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _AvaLido.contract.WatchLogs(opts, "DepositEvent", fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AvaLidoDepositEvent)
				if err := _AvaLido.contract.UnpackLog(event, "DepositEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDepositEvent is a log parse operation binding the contract event 0xad40ae5dc69974ba932d08b0a608e89109412d41d04850f5196f144875ae2660.
//
// Solidity: event DepositEvent(address indexed from, uint256 amount, uint256 timestamp)
func (_AvaLido *AvaLidoFilterer) ParseDepositEvent(log types.Log) (*AvaLidoDepositEvent, error) {
	event := new(AvaLidoDepositEvent)
	if err := _AvaLido.contract.UnpackLog(event, "DepositEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AvaLidoInitializedIterator is returned from FilterInitialized and is used to iterate over the raw logs and unpacked data for Initialized events raised by the AvaLido contract.
type AvaLidoInitializedIterator struct {
	Event *AvaLidoInitialized // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AvaLidoInitializedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AvaLidoInitialized)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AvaLidoInitialized)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AvaLidoInitializedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AvaLidoInitializedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AvaLidoInitialized represents a Initialized event raised by the AvaLido contract.
type AvaLidoInitialized struct {
	Version uint8
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInitialized is a free log retrieval operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_AvaLido *AvaLidoFilterer) FilterInitialized(opts *bind.FilterOpts) (*AvaLidoInitializedIterator, error) {

	logs, sub, err := _AvaLido.contract.FilterLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return &AvaLidoInitializedIterator{contract: _AvaLido.contract, event: "Initialized", logs: logs, sub: sub}, nil
}

// WatchInitialized is a free log subscription operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_AvaLido *AvaLidoFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *AvaLidoInitialized) (event.Subscription, error) {

	logs, sub, err := _AvaLido.contract.WatchLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AvaLidoInitialized)
				if err := _AvaLido.contract.UnpackLog(event, "Initialized", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInitialized is a log parse operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_AvaLido *AvaLidoFilterer) ParseInitialized(log types.Log) (*AvaLidoInitialized, error) {
	event := new(AvaLidoInitialized)
	if err := _AvaLido.contract.UnpackLog(event, "Initialized", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AvaLidoPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the AvaLido contract.
type AvaLidoPausedIterator struct {
	Event *AvaLidoPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AvaLidoPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AvaLidoPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AvaLidoPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AvaLidoPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AvaLidoPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AvaLidoPaused represents a Paused event raised by the AvaLido contract.
type AvaLidoPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_AvaLido *AvaLidoFilterer) FilterPaused(opts *bind.FilterOpts) (*AvaLidoPausedIterator, error) {

	logs, sub, err := _AvaLido.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &AvaLidoPausedIterator{contract: _AvaLido.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_AvaLido *AvaLidoFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *AvaLidoPaused) (event.Subscription, error) {

	logs, sub, err := _AvaLido.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AvaLidoPaused)
				if err := _AvaLido.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_AvaLido *AvaLidoFilterer) ParsePaused(log types.Log) (*AvaLidoPaused, error) {
	event := new(AvaLidoPaused)
	if err := _AvaLido.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AvaLidoProtocolFeeEventIterator is returned from FilterProtocolFeeEvent and is used to iterate over the raw logs and unpacked data for ProtocolFeeEvent events raised by the AvaLido contract.
type AvaLidoProtocolFeeEventIterator struct {
	Event *AvaLidoProtocolFeeEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AvaLidoProtocolFeeEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AvaLidoProtocolFeeEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AvaLidoProtocolFeeEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AvaLidoProtocolFeeEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AvaLidoProtocolFeeEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AvaLidoProtocolFeeEvent represents a ProtocolFeeEvent event raised by the AvaLido contract.
type AvaLidoProtocolFeeEvent struct {
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterProtocolFeeEvent is a free log retrieval operation binding the contract event 0x77bb62f6d632f13698ee0dfd8902692281a720e3bd4e18f03b96f3ba43ec5c25.
//
// Solidity: event ProtocolFeeEvent(uint256 amount)
func (_AvaLido *AvaLidoFilterer) FilterProtocolFeeEvent(opts *bind.FilterOpts) (*AvaLidoProtocolFeeEventIterator, error) {

	logs, sub, err := _AvaLido.contract.FilterLogs(opts, "ProtocolFeeEvent")
	if err != nil {
		return nil, err
	}
	return &AvaLidoProtocolFeeEventIterator{contract: _AvaLido.contract, event: "ProtocolFeeEvent", logs: logs, sub: sub}, nil
}

// WatchProtocolFeeEvent is a free log subscription operation binding the contract event 0x77bb62f6d632f13698ee0dfd8902692281a720e3bd4e18f03b96f3ba43ec5c25.
//
// Solidity: event ProtocolFeeEvent(uint256 amount)
func (_AvaLido *AvaLidoFilterer) WatchProtocolFeeEvent(opts *bind.WatchOpts, sink chan<- *AvaLidoProtocolFeeEvent) (event.Subscription, error) {

	logs, sub, err := _AvaLido.contract.WatchLogs(opts, "ProtocolFeeEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AvaLidoProtocolFeeEvent)
				if err := _AvaLido.contract.UnpackLog(event, "ProtocolFeeEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProtocolFeeEvent is a log parse operation binding the contract event 0x77bb62f6d632f13698ee0dfd8902692281a720e3bd4e18f03b96f3ba43ec5c25.
//
// Solidity: event ProtocolFeeEvent(uint256 amount)
func (_AvaLido *AvaLidoFilterer) ParseProtocolFeeEvent(log types.Log) (*AvaLidoProtocolFeeEvent, error) {
	event := new(AvaLidoProtocolFeeEvent)
	if err := _AvaLido.contract.UnpackLog(event, "ProtocolFeeEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AvaLidoRequestFullyFilledEventIterator is returned from FilterRequestFullyFilledEvent and is used to iterate over the raw logs and unpacked data for RequestFullyFilledEvent events raised by the AvaLido contract.
type AvaLidoRequestFullyFilledEventIterator struct {
	Event *AvaLidoRequestFullyFilledEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AvaLidoRequestFullyFilledEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AvaLidoRequestFullyFilledEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AvaLidoRequestFullyFilledEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AvaLidoRequestFullyFilledEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AvaLidoRequestFullyFilledEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AvaLidoRequestFullyFilledEvent represents a RequestFullyFilledEvent event raised by the AvaLido contract.
type AvaLidoRequestFullyFilledEvent struct {
	RequestedAmount *big.Int
	Timestamp       *big.Int
	RequestIndex    *big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterRequestFullyFilledEvent is a free log retrieval operation binding the contract event 0x6c09cd6b64ed10fcbd787eb4226ec81ab34e3db928a77faef8d22bc10ebe82ed.
//
// Solidity: event RequestFullyFilledEvent(uint256 indexed requestedAmount, uint256 timestamp, uint256 requestIndex)
func (_AvaLido *AvaLidoFilterer) FilterRequestFullyFilledEvent(opts *bind.FilterOpts, requestedAmount []*big.Int) (*AvaLidoRequestFullyFilledEventIterator, error) {

	var requestedAmountRule []interface{}
	for _, requestedAmountItem := range requestedAmount {
		requestedAmountRule = append(requestedAmountRule, requestedAmountItem)
	}

	logs, sub, err := _AvaLido.contract.FilterLogs(opts, "RequestFullyFilledEvent", requestedAmountRule)
	if err != nil {
		return nil, err
	}
	return &AvaLidoRequestFullyFilledEventIterator{contract: _AvaLido.contract, event: "RequestFullyFilledEvent", logs: logs, sub: sub}, nil
}

// WatchRequestFullyFilledEvent is a free log subscription operation binding the contract event 0x6c09cd6b64ed10fcbd787eb4226ec81ab34e3db928a77faef8d22bc10ebe82ed.
//
// Solidity: event RequestFullyFilledEvent(uint256 indexed requestedAmount, uint256 timestamp, uint256 requestIndex)
func (_AvaLido *AvaLidoFilterer) WatchRequestFullyFilledEvent(opts *bind.WatchOpts, sink chan<- *AvaLidoRequestFullyFilledEvent, requestedAmount []*big.Int) (event.Subscription, error) {

	var requestedAmountRule []interface{}
	for _, requestedAmountItem := range requestedAmount {
		requestedAmountRule = append(requestedAmountRule, requestedAmountItem)
	}

	logs, sub, err := _AvaLido.contract.WatchLogs(opts, "RequestFullyFilledEvent", requestedAmountRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AvaLidoRequestFullyFilledEvent)
				if err := _AvaLido.contract.UnpackLog(event, "RequestFullyFilledEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestFullyFilledEvent is a log parse operation binding the contract event 0x6c09cd6b64ed10fcbd787eb4226ec81ab34e3db928a77faef8d22bc10ebe82ed.
//
// Solidity: event RequestFullyFilledEvent(uint256 indexed requestedAmount, uint256 timestamp, uint256 requestIndex)
func (_AvaLido *AvaLidoFilterer) ParseRequestFullyFilledEvent(log types.Log) (*AvaLidoRequestFullyFilledEvent, error) {
	event := new(AvaLidoRequestFullyFilledEvent)
	if err := _AvaLido.contract.UnpackLog(event, "RequestFullyFilledEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AvaLidoRequestPartiallyFilledEventIterator is returned from FilterRequestPartiallyFilledEvent and is used to iterate over the raw logs and unpacked data for RequestPartiallyFilledEvent events raised by the AvaLido contract.
type AvaLidoRequestPartiallyFilledEventIterator struct {
	Event *AvaLidoRequestPartiallyFilledEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AvaLidoRequestPartiallyFilledEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AvaLidoRequestPartiallyFilledEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AvaLidoRequestPartiallyFilledEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AvaLidoRequestPartiallyFilledEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AvaLidoRequestPartiallyFilledEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AvaLidoRequestPartiallyFilledEvent represents a RequestPartiallyFilledEvent event raised by the AvaLido contract.
type AvaLidoRequestPartiallyFilledEvent struct {
	FillAmount   *big.Int
	Timestamp    *big.Int
	RequestIndex *big.Int
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterRequestPartiallyFilledEvent is a free log retrieval operation binding the contract event 0xdc0903a14c2c2526071b103c0305417a977225da3764984a90de4c9b8195cac5.
//
// Solidity: event RequestPartiallyFilledEvent(uint256 indexed fillAmount, uint256 timestamp, uint256 requestIndex)
func (_AvaLido *AvaLidoFilterer) FilterRequestPartiallyFilledEvent(opts *bind.FilterOpts, fillAmount []*big.Int) (*AvaLidoRequestPartiallyFilledEventIterator, error) {

	var fillAmountRule []interface{}
	for _, fillAmountItem := range fillAmount {
		fillAmountRule = append(fillAmountRule, fillAmountItem)
	}

	logs, sub, err := _AvaLido.contract.FilterLogs(opts, "RequestPartiallyFilledEvent", fillAmountRule)
	if err != nil {
		return nil, err
	}
	return &AvaLidoRequestPartiallyFilledEventIterator{contract: _AvaLido.contract, event: "RequestPartiallyFilledEvent", logs: logs, sub: sub}, nil
}

// WatchRequestPartiallyFilledEvent is a free log subscription operation binding the contract event 0xdc0903a14c2c2526071b103c0305417a977225da3764984a90de4c9b8195cac5.
//
// Solidity: event RequestPartiallyFilledEvent(uint256 indexed fillAmount, uint256 timestamp, uint256 requestIndex)
func (_AvaLido *AvaLidoFilterer) WatchRequestPartiallyFilledEvent(opts *bind.WatchOpts, sink chan<- *AvaLidoRequestPartiallyFilledEvent, fillAmount []*big.Int) (event.Subscription, error) {

	var fillAmountRule []interface{}
	for _, fillAmountItem := range fillAmount {
		fillAmountRule = append(fillAmountRule, fillAmountItem)
	}

	logs, sub, err := _AvaLido.contract.WatchLogs(opts, "RequestPartiallyFilledEvent", fillAmountRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AvaLidoRequestPartiallyFilledEvent)
				if err := _AvaLido.contract.UnpackLog(event, "RequestPartiallyFilledEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestPartiallyFilledEvent is a log parse operation binding the contract event 0xdc0903a14c2c2526071b103c0305417a977225da3764984a90de4c9b8195cac5.
//
// Solidity: event RequestPartiallyFilledEvent(uint256 indexed fillAmount, uint256 timestamp, uint256 requestIndex)
func (_AvaLido *AvaLidoFilterer) ParseRequestPartiallyFilledEvent(log types.Log) (*AvaLidoRequestPartiallyFilledEvent, error) {
	event := new(AvaLidoRequestPartiallyFilledEvent)
	if err := _AvaLido.contract.UnpackLog(event, "RequestPartiallyFilledEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AvaLidoRewardsCollectedEventIterator is returned from FilterRewardsCollectedEvent and is used to iterate over the raw logs and unpacked data for RewardsCollectedEvent events raised by the AvaLido contract.
type AvaLidoRewardsCollectedEventIterator struct {
	Event *AvaLidoRewardsCollectedEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AvaLidoRewardsCollectedEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AvaLidoRewardsCollectedEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AvaLidoRewardsCollectedEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AvaLidoRewardsCollectedEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AvaLidoRewardsCollectedEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AvaLidoRewardsCollectedEvent represents a RewardsCollectedEvent event raised by the AvaLido contract.
type AvaLidoRewardsCollectedEvent struct {
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRewardsCollectedEvent is a free log retrieval operation binding the contract event 0x4f085349488b0a9bbaba55c0dce4ef2ebfc933ff64bdfe6ff3d4b27fdb467706.
//
// Solidity: event RewardsCollectedEvent(uint256 amount)
func (_AvaLido *AvaLidoFilterer) FilterRewardsCollectedEvent(opts *bind.FilterOpts) (*AvaLidoRewardsCollectedEventIterator, error) {

	logs, sub, err := _AvaLido.contract.FilterLogs(opts, "RewardsCollectedEvent")
	if err != nil {
		return nil, err
	}
	return &AvaLidoRewardsCollectedEventIterator{contract: _AvaLido.contract, event: "RewardsCollectedEvent", logs: logs, sub: sub}, nil
}

// WatchRewardsCollectedEvent is a free log subscription operation binding the contract event 0x4f085349488b0a9bbaba55c0dce4ef2ebfc933ff64bdfe6ff3d4b27fdb467706.
//
// Solidity: event RewardsCollectedEvent(uint256 amount)
func (_AvaLido *AvaLidoFilterer) WatchRewardsCollectedEvent(opts *bind.WatchOpts, sink chan<- *AvaLidoRewardsCollectedEvent) (event.Subscription, error) {

	logs, sub, err := _AvaLido.contract.WatchLogs(opts, "RewardsCollectedEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AvaLidoRewardsCollectedEvent)
				if err := _AvaLido.contract.UnpackLog(event, "RewardsCollectedEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRewardsCollectedEvent is a log parse operation binding the contract event 0x4f085349488b0a9bbaba55c0dce4ef2ebfc933ff64bdfe6ff3d4b27fdb467706.
//
// Solidity: event RewardsCollectedEvent(uint256 amount)
func (_AvaLido *AvaLidoFilterer) ParseRewardsCollectedEvent(log types.Log) (*AvaLidoRewardsCollectedEvent, error) {
	event := new(AvaLidoRewardsCollectedEvent)
	if err := _AvaLido.contract.UnpackLog(event, "RewardsCollectedEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AvaLidoRoleAdminChangedIterator is returned from FilterRoleAdminChanged and is used to iterate over the raw logs and unpacked data for RoleAdminChanged events raised by the AvaLido contract.
type AvaLidoRoleAdminChangedIterator struct {
	Event *AvaLidoRoleAdminChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AvaLidoRoleAdminChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AvaLidoRoleAdminChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AvaLidoRoleAdminChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AvaLidoRoleAdminChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AvaLidoRoleAdminChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AvaLidoRoleAdminChanged represents a RoleAdminChanged event raised by the AvaLido contract.
type AvaLidoRoleAdminChanged struct {
	Role              [32]byte
	PreviousAdminRole [32]byte
	NewAdminRole      [32]byte
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRoleAdminChanged is a free log retrieval operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_AvaLido *AvaLidoFilterer) FilterRoleAdminChanged(opts *bind.FilterOpts, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (*AvaLidoRoleAdminChangedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _AvaLido.contract.FilterLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return &AvaLidoRoleAdminChangedIterator{contract: _AvaLido.contract, event: "RoleAdminChanged", logs: logs, sub: sub}, nil
}

// WatchRoleAdminChanged is a free log subscription operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_AvaLido *AvaLidoFilterer) WatchRoleAdminChanged(opts *bind.WatchOpts, sink chan<- *AvaLidoRoleAdminChanged, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _AvaLido.contract.WatchLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AvaLidoRoleAdminChanged)
				if err := _AvaLido.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleAdminChanged is a log parse operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_AvaLido *AvaLidoFilterer) ParseRoleAdminChanged(log types.Log) (*AvaLidoRoleAdminChanged, error) {
	event := new(AvaLidoRoleAdminChanged)
	if err := _AvaLido.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AvaLidoRoleGrantedIterator is returned from FilterRoleGranted and is used to iterate over the raw logs and unpacked data for RoleGranted events raised by the AvaLido contract.
type AvaLidoRoleGrantedIterator struct {
	Event *AvaLidoRoleGranted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AvaLidoRoleGrantedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AvaLidoRoleGranted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AvaLidoRoleGranted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AvaLidoRoleGrantedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AvaLidoRoleGrantedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AvaLidoRoleGranted represents a RoleGranted event raised by the AvaLido contract.
type AvaLidoRoleGranted struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleGranted is a free log retrieval operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_AvaLido *AvaLidoFilterer) FilterRoleGranted(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*AvaLidoRoleGrantedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _AvaLido.contract.FilterLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &AvaLidoRoleGrantedIterator{contract: _AvaLido.contract, event: "RoleGranted", logs: logs, sub: sub}, nil
}

// WatchRoleGranted is a free log subscription operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_AvaLido *AvaLidoFilterer) WatchRoleGranted(opts *bind.WatchOpts, sink chan<- *AvaLidoRoleGranted, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _AvaLido.contract.WatchLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AvaLidoRoleGranted)
				if err := _AvaLido.contract.UnpackLog(event, "RoleGranted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleGranted is a log parse operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_AvaLido *AvaLidoFilterer) ParseRoleGranted(log types.Log) (*AvaLidoRoleGranted, error) {
	event := new(AvaLidoRoleGranted)
	if err := _AvaLido.contract.UnpackLog(event, "RoleGranted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AvaLidoRoleRevokedIterator is returned from FilterRoleRevoked and is used to iterate over the raw logs and unpacked data for RoleRevoked events raised by the AvaLido contract.
type AvaLidoRoleRevokedIterator struct {
	Event *AvaLidoRoleRevoked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AvaLidoRoleRevokedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AvaLidoRoleRevoked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AvaLidoRoleRevoked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AvaLidoRoleRevokedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AvaLidoRoleRevokedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AvaLidoRoleRevoked represents a RoleRevoked event raised by the AvaLido contract.
type AvaLidoRoleRevoked struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleRevoked is a free log retrieval operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_AvaLido *AvaLidoFilterer) FilterRoleRevoked(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*AvaLidoRoleRevokedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _AvaLido.contract.FilterLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &AvaLidoRoleRevokedIterator{contract: _AvaLido.contract, event: "RoleRevoked", logs: logs, sub: sub}, nil
}

// WatchRoleRevoked is a free log subscription operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_AvaLido *AvaLidoFilterer) WatchRoleRevoked(opts *bind.WatchOpts, sink chan<- *AvaLidoRoleRevoked, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _AvaLido.contract.WatchLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AvaLidoRoleRevoked)
				if err := _AvaLido.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleRevoked is a log parse operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_AvaLido *AvaLidoFilterer) ParseRoleRevoked(log types.Log) (*AvaLidoRoleRevoked, error) {
	event := new(AvaLidoRoleRevoked)
	if err := _AvaLido.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AvaLidoTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the AvaLido contract.
type AvaLidoTransferIterator struct {
	Event *AvaLidoTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AvaLidoTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AvaLidoTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AvaLidoTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AvaLidoTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AvaLidoTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AvaLidoTransfer represents a Transfer event raised by the AvaLido contract.
type AvaLidoTransfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_AvaLido *AvaLidoFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*AvaLidoTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _AvaLido.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &AvaLidoTransferIterator{contract: _AvaLido.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_AvaLido *AvaLidoFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *AvaLidoTransfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _AvaLido.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AvaLidoTransfer)
				if err := _AvaLido.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_AvaLido *AvaLidoFilterer) ParseTransfer(log types.Log) (*AvaLidoTransfer, error) {
	event := new(AvaLidoTransfer)
	if err := _AvaLido.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AvaLidoUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the AvaLido contract.
type AvaLidoUnpausedIterator struct {
	Event *AvaLidoUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AvaLidoUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AvaLidoUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AvaLidoUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AvaLidoUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AvaLidoUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AvaLidoUnpaused represents a Unpaused event raised by the AvaLido contract.
type AvaLidoUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_AvaLido *AvaLidoFilterer) FilterUnpaused(opts *bind.FilterOpts) (*AvaLidoUnpausedIterator, error) {

	logs, sub, err := _AvaLido.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &AvaLidoUnpausedIterator{contract: _AvaLido.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_AvaLido *AvaLidoFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *AvaLidoUnpaused) (event.Subscription, error) {

	logs, sub, err := _AvaLido.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AvaLidoUnpaused)
				if err := _AvaLido.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_AvaLido *AvaLidoFilterer) ParseUnpaused(log types.Log) (*AvaLidoUnpaused, error) {
	event := new(AvaLidoUnpaused)
	if err := _AvaLido.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AvaLidoWithdrawRequestSubmittedEventIterator is returned from FilterWithdrawRequestSubmittedEvent and is used to iterate over the raw logs and unpacked data for WithdrawRequestSubmittedEvent events raised by the AvaLido contract.
type AvaLidoWithdrawRequestSubmittedEventIterator struct {
	Event *AvaLidoWithdrawRequestSubmittedEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AvaLidoWithdrawRequestSubmittedEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AvaLidoWithdrawRequestSubmittedEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AvaLidoWithdrawRequestSubmittedEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AvaLidoWithdrawRequestSubmittedEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AvaLidoWithdrawRequestSubmittedEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AvaLidoWithdrawRequestSubmittedEvent represents a WithdrawRequestSubmittedEvent event raised by the AvaLido contract.
type AvaLidoWithdrawRequestSubmittedEvent struct {
	From         common.Address
	AvaxAmount   *big.Int
	StAvaxAmount *big.Int
	Timestamp    *big.Int
	RequestIndex *big.Int
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterWithdrawRequestSubmittedEvent is a free log retrieval operation binding the contract event 0xdae9f04ebd508b8d6ff61ab1601937224910e223f2a01713eab68e3d4aeb10ef.
//
// Solidity: event WithdrawRequestSubmittedEvent(address indexed from, uint256 avaxAmount, uint256 stAvaxAmount, uint256 timestamp, uint256 requestIndex)
func (_AvaLido *AvaLidoFilterer) FilterWithdrawRequestSubmittedEvent(opts *bind.FilterOpts, from []common.Address) (*AvaLidoWithdrawRequestSubmittedEventIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _AvaLido.contract.FilterLogs(opts, "WithdrawRequestSubmittedEvent", fromRule)
	if err != nil {
		return nil, err
	}
	return &AvaLidoWithdrawRequestSubmittedEventIterator{contract: _AvaLido.contract, event: "WithdrawRequestSubmittedEvent", logs: logs, sub: sub}, nil
}

// WatchWithdrawRequestSubmittedEvent is a free log subscription operation binding the contract event 0xdae9f04ebd508b8d6ff61ab1601937224910e223f2a01713eab68e3d4aeb10ef.
//
// Solidity: event WithdrawRequestSubmittedEvent(address indexed from, uint256 avaxAmount, uint256 stAvaxAmount, uint256 timestamp, uint256 requestIndex)
func (_AvaLido *AvaLidoFilterer) WatchWithdrawRequestSubmittedEvent(opts *bind.WatchOpts, sink chan<- *AvaLidoWithdrawRequestSubmittedEvent, from []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _AvaLido.contract.WatchLogs(opts, "WithdrawRequestSubmittedEvent", fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AvaLidoWithdrawRequestSubmittedEvent)
				if err := _AvaLido.contract.UnpackLog(event, "WithdrawRequestSubmittedEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawRequestSubmittedEvent is a log parse operation binding the contract event 0xdae9f04ebd508b8d6ff61ab1601937224910e223f2a01713eab68e3d4aeb10ef.
//
// Solidity: event WithdrawRequestSubmittedEvent(address indexed from, uint256 avaxAmount, uint256 stAvaxAmount, uint256 timestamp, uint256 requestIndex)
func (_AvaLido *AvaLidoFilterer) ParseWithdrawRequestSubmittedEvent(log types.Log) (*AvaLidoWithdrawRequestSubmittedEvent, error) {
	event := new(AvaLidoWithdrawRequestSubmittedEvent)
	if err := _AvaLido.contract.UnpackLog(event, "WithdrawRequestSubmittedEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ContextMetaData contains all meta data concerning the Context contract.
var ContextMetaData = &bind.MetaData{
	ABI: "[]",
}

// ContextABI is the input ABI used to generate the binding from.
// Deprecated: Use ContextMetaData.ABI instead.
var ContextABI = ContextMetaData.ABI

// Context is an auto generated Go binding around an Ethereum contract.
type Context struct {
	ContextCaller     // Read-only binding to the contract
	ContextTransactor // Write-only binding to the contract
	ContextFilterer   // Log filterer for contract events
}

// ContextCaller is an auto generated read-only Go binding around an Ethereum contract.
type ContextCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ContextTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ContextFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ContextSession struct {
	Contract     *Context          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ContextCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ContextCallerSession struct {
	Contract *ContextCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// ContextTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ContextTransactorSession struct {
	Contract     *ContextTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// ContextRaw is an auto generated low-level Go binding around an Ethereum contract.
type ContextRaw struct {
	Contract *Context // Generic contract binding to access the raw methods on
}

// ContextCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ContextCallerRaw struct {
	Contract *ContextCaller // Generic read-only contract binding to access the raw methods on
}

// ContextTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ContextTransactorRaw struct {
	Contract *ContextTransactor // Generic write-only contract binding to access the raw methods on
}

// NewContext creates a new instance of Context, bound to a specific deployed contract.
func NewContext(address common.Address, backend bind.ContractBackend) (*Context, error) {
	contract, err := bindContext(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Context{ContextCaller: ContextCaller{contract: contract}, ContextTransactor: ContextTransactor{contract: contract}, ContextFilterer: ContextFilterer{contract: contract}}, nil
}

// NewContextCaller creates a new read-only instance of Context, bound to a specific deployed contract.
func NewContextCaller(address common.Address, caller bind.ContractCaller) (*ContextCaller, error) {
	contract, err := bindContext(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ContextCaller{contract: contract}, nil
}

// NewContextTransactor creates a new write-only instance of Context, bound to a specific deployed contract.
func NewContextTransactor(address common.Address, transactor bind.ContractTransactor) (*ContextTransactor, error) {
	contract, err := bindContext(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ContextTransactor{contract: contract}, nil
}

// NewContextFilterer creates a new log filterer instance of Context, bound to a specific deployed contract.
func NewContextFilterer(address common.Address, filterer bind.ContractFilterer) (*ContextFilterer, error) {
	contract, err := bindContext(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ContextFilterer{contract: contract}, nil
}

// bindContext binds a generic wrapper to an already deployed contract.
func bindContext(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ContextABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Context *ContextRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Context.Contract.ContextCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Context *ContextRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Context.Contract.ContextTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Context *ContextRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Context.Contract.ContextTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Context *ContextCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Context.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Context *ContextTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Context.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Context *ContextTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Context.Contract.contract.Transact(opts, method, params...)
}

// ContextUpgradeableMetaData contains all meta data concerning the ContextUpgradeable contract.
var ContextUpgradeableMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"}]",
}

// ContextUpgradeableABI is the input ABI used to generate the binding from.
// Deprecated: Use ContextUpgradeableMetaData.ABI instead.
var ContextUpgradeableABI = ContextUpgradeableMetaData.ABI

// ContextUpgradeable is an auto generated Go binding around an Ethereum contract.
type ContextUpgradeable struct {
	ContextUpgradeableCaller     // Read-only binding to the contract
	ContextUpgradeableTransactor // Write-only binding to the contract
	ContextUpgradeableFilterer   // Log filterer for contract events
}

// ContextUpgradeableCaller is an auto generated read-only Go binding around an Ethereum contract.
type ContextUpgradeableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextUpgradeableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ContextUpgradeableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextUpgradeableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ContextUpgradeableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ContextUpgradeableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ContextUpgradeableSession struct {
	Contract     *ContextUpgradeable // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// ContextUpgradeableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ContextUpgradeableCallerSession struct {
	Contract *ContextUpgradeableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// ContextUpgradeableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ContextUpgradeableTransactorSession struct {
	Contract     *ContextUpgradeableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// ContextUpgradeableRaw is an auto generated low-level Go binding around an Ethereum contract.
type ContextUpgradeableRaw struct {
	Contract *ContextUpgradeable // Generic contract binding to access the raw methods on
}

// ContextUpgradeableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ContextUpgradeableCallerRaw struct {
	Contract *ContextUpgradeableCaller // Generic read-only contract binding to access the raw methods on
}

// ContextUpgradeableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ContextUpgradeableTransactorRaw struct {
	Contract *ContextUpgradeableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewContextUpgradeable creates a new instance of ContextUpgradeable, bound to a specific deployed contract.
func NewContextUpgradeable(address common.Address, backend bind.ContractBackend) (*ContextUpgradeable, error) {
	contract, err := bindContextUpgradeable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ContextUpgradeable{ContextUpgradeableCaller: ContextUpgradeableCaller{contract: contract}, ContextUpgradeableTransactor: ContextUpgradeableTransactor{contract: contract}, ContextUpgradeableFilterer: ContextUpgradeableFilterer{contract: contract}}, nil
}

// NewContextUpgradeableCaller creates a new read-only instance of ContextUpgradeable, bound to a specific deployed contract.
func NewContextUpgradeableCaller(address common.Address, caller bind.ContractCaller) (*ContextUpgradeableCaller, error) {
	contract, err := bindContextUpgradeable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ContextUpgradeableCaller{contract: contract}, nil
}

// NewContextUpgradeableTransactor creates a new write-only instance of ContextUpgradeable, bound to a specific deployed contract.
func NewContextUpgradeableTransactor(address common.Address, transactor bind.ContractTransactor) (*ContextUpgradeableTransactor, error) {
	contract, err := bindContextUpgradeable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ContextUpgradeableTransactor{contract: contract}, nil
}

// NewContextUpgradeableFilterer creates a new log filterer instance of ContextUpgradeable, bound to a specific deployed contract.
func NewContextUpgradeableFilterer(address common.Address, filterer bind.ContractFilterer) (*ContextUpgradeableFilterer, error) {
	contract, err := bindContextUpgradeable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ContextUpgradeableFilterer{contract: contract}, nil
}

// bindContextUpgradeable binds a generic wrapper to an already deployed contract.
func bindContextUpgradeable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ContextUpgradeableABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ContextUpgradeable *ContextUpgradeableRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ContextUpgradeable.Contract.ContextUpgradeableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ContextUpgradeable *ContextUpgradeableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ContextUpgradeable.Contract.ContextUpgradeableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ContextUpgradeable *ContextUpgradeableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ContextUpgradeable.Contract.ContextUpgradeableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ContextUpgradeable *ContextUpgradeableCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ContextUpgradeable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ContextUpgradeable *ContextUpgradeableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ContextUpgradeable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ContextUpgradeable *ContextUpgradeableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ContextUpgradeable.Contract.contract.Transact(opts, method, params...)
}

// ContextUpgradeableInitializedIterator is returned from FilterInitialized and is used to iterate over the raw logs and unpacked data for Initialized events raised by the ContextUpgradeable contract.
type ContextUpgradeableInitializedIterator struct {
	Event *ContextUpgradeableInitialized // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ContextUpgradeableInitializedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ContextUpgradeableInitialized)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ContextUpgradeableInitialized)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ContextUpgradeableInitializedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ContextUpgradeableInitializedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ContextUpgradeableInitialized represents a Initialized event raised by the ContextUpgradeable contract.
type ContextUpgradeableInitialized struct {
	Version uint8
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInitialized is a free log retrieval operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_ContextUpgradeable *ContextUpgradeableFilterer) FilterInitialized(opts *bind.FilterOpts) (*ContextUpgradeableInitializedIterator, error) {

	logs, sub, err := _ContextUpgradeable.contract.FilterLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return &ContextUpgradeableInitializedIterator{contract: _ContextUpgradeable.contract, event: "Initialized", logs: logs, sub: sub}, nil
}

// WatchInitialized is a free log subscription operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_ContextUpgradeable *ContextUpgradeableFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *ContextUpgradeableInitialized) (event.Subscription, error) {

	logs, sub, err := _ContextUpgradeable.contract.WatchLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ContextUpgradeableInitialized)
				if err := _ContextUpgradeable.contract.UnpackLog(event, "Initialized", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInitialized is a log parse operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_ContextUpgradeable *ContextUpgradeableFilterer) ParseInitialized(log types.Log) (*ContextUpgradeableInitialized, error) {
	event := new(ContextUpgradeableInitialized)
	if err := _ContextUpgradeable.contract.UnpackLog(event, "Initialized", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC165MetaData contains all meta data concerning the ERC165 contract.
var ERC165MetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"01ffc9a7": "supportsInterface(bytes4)",
	},
}

// ERC165ABI is the input ABI used to generate the binding from.
// Deprecated: Use ERC165MetaData.ABI instead.
var ERC165ABI = ERC165MetaData.ABI

// Deprecated: Use ERC165MetaData.Sigs instead.
// ERC165FuncSigs maps the 4-byte function signature to its string representation.
var ERC165FuncSigs = ERC165MetaData.Sigs

// ERC165 is an auto generated Go binding around an Ethereum contract.
type ERC165 struct {
	ERC165Caller     // Read-only binding to the contract
	ERC165Transactor // Write-only binding to the contract
	ERC165Filterer   // Log filterer for contract events
}

// ERC165Caller is an auto generated read-only Go binding around an Ethereum contract.
type ERC165Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC165Transactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC165Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC165Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC165Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC165Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC165Session struct {
	Contract     *ERC165           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC165CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC165CallerSession struct {
	Contract *ERC165Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// ERC165TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC165TransactorSession struct {
	Contract     *ERC165Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC165Raw is an auto generated low-level Go binding around an Ethereum contract.
type ERC165Raw struct {
	Contract *ERC165 // Generic contract binding to access the raw methods on
}

// ERC165CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC165CallerRaw struct {
	Contract *ERC165Caller // Generic read-only contract binding to access the raw methods on
}

// ERC165TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC165TransactorRaw struct {
	Contract *ERC165Transactor // Generic write-only contract binding to access the raw methods on
}

// NewERC165 creates a new instance of ERC165, bound to a specific deployed contract.
func NewERC165(address common.Address, backend bind.ContractBackend) (*ERC165, error) {
	contract, err := bindERC165(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC165{ERC165Caller: ERC165Caller{contract: contract}, ERC165Transactor: ERC165Transactor{contract: contract}, ERC165Filterer: ERC165Filterer{contract: contract}}, nil
}

// NewERC165Caller creates a new read-only instance of ERC165, bound to a specific deployed contract.
func NewERC165Caller(address common.Address, caller bind.ContractCaller) (*ERC165Caller, error) {
	contract, err := bindERC165(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC165Caller{contract: contract}, nil
}

// NewERC165Transactor creates a new write-only instance of ERC165, bound to a specific deployed contract.
func NewERC165Transactor(address common.Address, transactor bind.ContractTransactor) (*ERC165Transactor, error) {
	contract, err := bindERC165(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC165Transactor{contract: contract}, nil
}

// NewERC165Filterer creates a new log filterer instance of ERC165, bound to a specific deployed contract.
func NewERC165Filterer(address common.Address, filterer bind.ContractFilterer) (*ERC165Filterer, error) {
	contract, err := bindERC165(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC165Filterer{contract: contract}, nil
}

// bindERC165 binds a generic wrapper to an already deployed contract.
func bindERC165(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC165ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC165 *ERC165Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC165.Contract.ERC165Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC165 *ERC165Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC165.Contract.ERC165Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC165 *ERC165Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC165.Contract.ERC165Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC165 *ERC165CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC165.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC165 *ERC165TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC165.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC165 *ERC165TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC165.Contract.contract.Transact(opts, method, params...)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ERC165 *ERC165Caller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _ERC165.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ERC165 *ERC165Session) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _ERC165.Contract.SupportsInterface(&_ERC165.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_ERC165 *ERC165CallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _ERC165.Contract.SupportsInterface(&_ERC165.CallOpts, interfaceId)
}

// ERC20UpgradeableMetaData contains all meta data concerning the ERC20Upgradeable contract.
var ERC20UpgradeableMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"dd62ed3e": "allowance(address,address)",
		"095ea7b3": "approve(address,uint256)",
		"70a08231": "balanceOf(address)",
		"313ce567": "decimals()",
		"a457c2d7": "decreaseAllowance(address,uint256)",
		"39509351": "increaseAllowance(address,uint256)",
		"06fdde03": "name()",
		"95d89b41": "symbol()",
		"18160ddd": "totalSupply()",
		"a9059cbb": "transfer(address,uint256)",
		"23b872dd": "transferFrom(address,address,uint256)",
	},
	Bin: "0x608060405234801561001057600080fd5b50610864806100206000396000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c80633950935111610071578063395093511461012357806370a082311461013657806395d89b411461015f578063a457c2d714610167578063a9059cbb1461017a578063dd62ed3e1461018d57600080fd5b806306fdde03146100ae578063095ea7b3146100cc57806318160ddd146100ef57806323b872dd14610101578063313ce56714610114575b600080fd5b6100b66101a0565b6040516100c391906106a1565b60405180910390f35b6100df6100da366004610712565b610232565b60405190151581526020016100c3565b6035545b6040519081526020016100c3565b6100df61010f36600461073c565b61024a565b604051601281526020016100c3565b6100df610131366004610712565b61026e565b6100f3610144366004610778565b6001600160a01b031660009081526033602052604090205490565b6100b6610290565b6100df610175366004610712565b61029f565b6100df610188366004610712565b61031f565b6100f361019b36600461079a565b61032d565b6060603680546101af906107cd565b80601f01602080910402602001604051908101604052809291908181526020018280546101db906107cd565b80156102285780601f106101fd57610100808354040283529160200191610228565b820191906000526020600020905b81548152906001019060200180831161020b57829003601f168201915b5050505050905090565b600033610240818585610358565b5060019392505050565b60003361025885828561047c565b6102638585856104f6565b506001949350505050565b600033610240818585610281838361032d565b61028b9190610808565b610358565b6060603780546101af906107cd565b600033816102ad828661032d565b9050838110156103125760405162461bcd60e51b815260206004820152602560248201527f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77604482015264207a65726f60d81b60648201526084015b60405180910390fd5b6102638286868403610358565b6000336102408185856104f6565b6001600160a01b03918216600090815260346020908152604080832093909416825291909152205490565b6001600160a01b0383166103ba5760405162461bcd60e51b8152602060048201526024808201527f45524332303a20617070726f76652066726f6d20746865207a65726f206164646044820152637265737360e01b6064820152608401610309565b6001600160a01b03821661041b5760405162461bcd60e51b815260206004820152602260248201527f45524332303a20617070726f766520746f20746865207a65726f206164647265604482015261737360f01b6064820152608401610309565b6001600160a01b0383811660008181526034602090815260408083209487168084529482529182902085905590518481527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a3505050565b6000610488848461032d565b905060001981146104f057818110156104e35760405162461bcd60e51b815260206004820152601d60248201527f45524332303a20696e73756666696369656e7420616c6c6f77616e63650000006044820152606401610309565b6104f08484848403610358565b50505050565b6001600160a01b03831661055a5760405162461bcd60e51b815260206004820152602560248201527f45524332303a207472616e736665722066726f6d20746865207a65726f206164604482015264647265737360d81b6064820152608401610309565b6001600160a01b0382166105bc5760405162461bcd60e51b815260206004820152602360248201527f45524332303a207472616e7366657220746f20746865207a65726f206164647260448201526265737360e81b6064820152608401610309565b6001600160a01b038316600090815260336020526040902054818110156106345760405162461bcd60e51b815260206004820152602660248201527f45524332303a207472616e7366657220616d6f756e7420657863656564732062604482015265616c616e636560d01b6064820152608401610309565b6001600160a01b0380851660008181526033602052604080822086860390559286168082529083902080548601905591517fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef906106949086815260200190565b60405180910390a36104f0565b600060208083528351808285015260005b818110156106ce578581018301518582016040015282016106b2565b818111156106e0576000604083870101525b50601f01601f1916929092016040019392505050565b80356001600160a01b038116811461070d57600080fd5b919050565b6000806040838503121561072557600080fd5b61072e836106f6565b946020939093013593505050565b60008060006060848603121561075157600080fd5b61075a846106f6565b9250610768602085016106f6565b9150604084013590509250925092565b60006020828403121561078a57600080fd5b610793826106f6565b9392505050565b600080604083850312156107ad57600080fd5b6107b6836106f6565b91506107c4602084016106f6565b90509250929050565b600181811c908216806107e157607f821691505b6020821081141561080257634e487b7160e01b600052602260045260246000fd5b50919050565b6000821982111561082957634e487b7160e01b600052601160045260246000fd5b50019056fea26469706673582212200b2a6948eea6b19f70b0832523494e698ecad3e94ec61519e03a19e6134d0a9d64736f6c634300080a0033",
}

// ERC20UpgradeableABI is the input ABI used to generate the binding from.
// Deprecated: Use ERC20UpgradeableMetaData.ABI instead.
var ERC20UpgradeableABI = ERC20UpgradeableMetaData.ABI

// Deprecated: Use ERC20UpgradeableMetaData.Sigs instead.
// ERC20UpgradeableFuncSigs maps the 4-byte function signature to its string representation.
var ERC20UpgradeableFuncSigs = ERC20UpgradeableMetaData.Sigs

// ERC20UpgradeableBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ERC20UpgradeableMetaData.Bin instead.
var ERC20UpgradeableBin = ERC20UpgradeableMetaData.Bin

// DeployERC20Upgradeable deploys a new Ethereum contract, binding an instance of ERC20Upgradeable to it.
func DeployERC20Upgradeable(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ERC20Upgradeable, error) {
	parsed, err := ERC20UpgradeableMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ERC20UpgradeableBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ERC20Upgradeable{ERC20UpgradeableCaller: ERC20UpgradeableCaller{contract: contract}, ERC20UpgradeableTransactor: ERC20UpgradeableTransactor{contract: contract}, ERC20UpgradeableFilterer: ERC20UpgradeableFilterer{contract: contract}}, nil
}

// ERC20Upgradeable is an auto generated Go binding around an Ethereum contract.
type ERC20Upgradeable struct {
	ERC20UpgradeableCaller     // Read-only binding to the contract
	ERC20UpgradeableTransactor // Write-only binding to the contract
	ERC20UpgradeableFilterer   // Log filterer for contract events
}

// ERC20UpgradeableCaller is an auto generated read-only Go binding around an Ethereum contract.
type ERC20UpgradeableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20UpgradeableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC20UpgradeableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20UpgradeableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC20UpgradeableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20UpgradeableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC20UpgradeableSession struct {
	Contract     *ERC20Upgradeable // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC20UpgradeableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC20UpgradeableCallerSession struct {
	Contract *ERC20UpgradeableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// ERC20UpgradeableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC20UpgradeableTransactorSession struct {
	Contract     *ERC20UpgradeableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// ERC20UpgradeableRaw is an auto generated low-level Go binding around an Ethereum contract.
type ERC20UpgradeableRaw struct {
	Contract *ERC20Upgradeable // Generic contract binding to access the raw methods on
}

// ERC20UpgradeableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC20UpgradeableCallerRaw struct {
	Contract *ERC20UpgradeableCaller // Generic read-only contract binding to access the raw methods on
}

// ERC20UpgradeableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC20UpgradeableTransactorRaw struct {
	Contract *ERC20UpgradeableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewERC20Upgradeable creates a new instance of ERC20Upgradeable, bound to a specific deployed contract.
func NewERC20Upgradeable(address common.Address, backend bind.ContractBackend) (*ERC20Upgradeable, error) {
	contract, err := bindERC20Upgradeable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC20Upgradeable{ERC20UpgradeableCaller: ERC20UpgradeableCaller{contract: contract}, ERC20UpgradeableTransactor: ERC20UpgradeableTransactor{contract: contract}, ERC20UpgradeableFilterer: ERC20UpgradeableFilterer{contract: contract}}, nil
}

// NewERC20UpgradeableCaller creates a new read-only instance of ERC20Upgradeable, bound to a specific deployed contract.
func NewERC20UpgradeableCaller(address common.Address, caller bind.ContractCaller) (*ERC20UpgradeableCaller, error) {
	contract, err := bindERC20Upgradeable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20UpgradeableCaller{contract: contract}, nil
}

// NewERC20UpgradeableTransactor creates a new write-only instance of ERC20Upgradeable, bound to a specific deployed contract.
func NewERC20UpgradeableTransactor(address common.Address, transactor bind.ContractTransactor) (*ERC20UpgradeableTransactor, error) {
	contract, err := bindERC20Upgradeable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20UpgradeableTransactor{contract: contract}, nil
}

// NewERC20UpgradeableFilterer creates a new log filterer instance of ERC20Upgradeable, bound to a specific deployed contract.
func NewERC20UpgradeableFilterer(address common.Address, filterer bind.ContractFilterer) (*ERC20UpgradeableFilterer, error) {
	contract, err := bindERC20Upgradeable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC20UpgradeableFilterer{contract: contract}, nil
}

// bindERC20Upgradeable binds a generic wrapper to an already deployed contract.
func bindERC20Upgradeable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC20UpgradeableABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20Upgradeable *ERC20UpgradeableRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20Upgradeable.Contract.ERC20UpgradeableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20Upgradeable *ERC20UpgradeableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Upgradeable.Contract.ERC20UpgradeableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20Upgradeable *ERC20UpgradeableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20Upgradeable.Contract.ERC20UpgradeableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20Upgradeable *ERC20UpgradeableCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20Upgradeable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20Upgradeable *ERC20UpgradeableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Upgradeable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20Upgradeable *ERC20UpgradeableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20Upgradeable.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20Upgradeable *ERC20UpgradeableCaller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Upgradeable.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20Upgradeable *ERC20UpgradeableSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _ERC20Upgradeable.Contract.Allowance(&_ERC20Upgradeable.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_ERC20Upgradeable *ERC20UpgradeableCallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _ERC20Upgradeable.Contract.Allowance(&_ERC20Upgradeable.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20Upgradeable *ERC20UpgradeableCaller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Upgradeable.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20Upgradeable *ERC20UpgradeableSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _ERC20Upgradeable.Contract.BalanceOf(&_ERC20Upgradeable.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_ERC20Upgradeable *ERC20UpgradeableCallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _ERC20Upgradeable.Contract.BalanceOf(&_ERC20Upgradeable.CallOpts, account)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20Upgradeable *ERC20UpgradeableCaller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _ERC20Upgradeable.contract.Call(opts, &out, "decimals")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20Upgradeable *ERC20UpgradeableSession) Decimals() (uint8, error) {
	return _ERC20Upgradeable.Contract.Decimals(&_ERC20Upgradeable.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_ERC20Upgradeable *ERC20UpgradeableCallerSession) Decimals() (uint8, error) {
	return _ERC20Upgradeable.Contract.Decimals(&_ERC20Upgradeable.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20Upgradeable *ERC20UpgradeableCaller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _ERC20Upgradeable.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20Upgradeable *ERC20UpgradeableSession) Name() (string, error) {
	return _ERC20Upgradeable.Contract.Name(&_ERC20Upgradeable.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_ERC20Upgradeable *ERC20UpgradeableCallerSession) Name() (string, error) {
	return _ERC20Upgradeable.Contract.Name(&_ERC20Upgradeable.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20Upgradeable *ERC20UpgradeableCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _ERC20Upgradeable.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20Upgradeable *ERC20UpgradeableSession) Symbol() (string, error) {
	return _ERC20Upgradeable.Contract.Symbol(&_ERC20Upgradeable.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_ERC20Upgradeable *ERC20UpgradeableCallerSession) Symbol() (string, error) {
	return _ERC20Upgradeable.Contract.Symbol(&_ERC20Upgradeable.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20Upgradeable *ERC20UpgradeableCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Upgradeable.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20Upgradeable *ERC20UpgradeableSession) TotalSupply() (*big.Int, error) {
	return _ERC20Upgradeable.Contract.TotalSupply(&_ERC20Upgradeable.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_ERC20Upgradeable *ERC20UpgradeableCallerSession) TotalSupply() (*big.Int, error) {
	return _ERC20Upgradeable.Contract.TotalSupply(&_ERC20Upgradeable.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20Upgradeable *ERC20UpgradeableTransactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Upgradeable.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20Upgradeable *ERC20UpgradeableSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Upgradeable.Contract.Approve(&_ERC20Upgradeable.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_ERC20Upgradeable *ERC20UpgradeableTransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Upgradeable.Contract.Approve(&_ERC20Upgradeable.TransactOpts, spender, amount)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20Upgradeable *ERC20UpgradeableTransactor) DecreaseAllowance(opts *bind.TransactOpts, spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Upgradeable.contract.Transact(opts, "decreaseAllowance", spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20Upgradeable *ERC20UpgradeableSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Upgradeable.Contract.DecreaseAllowance(&_ERC20Upgradeable.TransactOpts, spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_ERC20Upgradeable *ERC20UpgradeableTransactorSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Upgradeable.Contract.DecreaseAllowance(&_ERC20Upgradeable.TransactOpts, spender, subtractedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20Upgradeable *ERC20UpgradeableTransactor) IncreaseAllowance(opts *bind.TransactOpts, spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Upgradeable.contract.Transact(opts, "increaseAllowance", spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20Upgradeable *ERC20UpgradeableSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Upgradeable.Contract.IncreaseAllowance(&_ERC20Upgradeable.TransactOpts, spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_ERC20Upgradeable *ERC20UpgradeableTransactorSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _ERC20Upgradeable.Contract.IncreaseAllowance(&_ERC20Upgradeable.TransactOpts, spender, addedValue)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20Upgradeable *ERC20UpgradeableTransactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Upgradeable.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20Upgradeable *ERC20UpgradeableSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Upgradeable.Contract.Transfer(&_ERC20Upgradeable.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_ERC20Upgradeable *ERC20UpgradeableTransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Upgradeable.Contract.Transfer(&_ERC20Upgradeable.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20Upgradeable *ERC20UpgradeableTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Upgradeable.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20Upgradeable *ERC20UpgradeableSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Upgradeable.Contract.TransferFrom(&_ERC20Upgradeable.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_ERC20Upgradeable *ERC20UpgradeableTransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Upgradeable.Contract.TransferFrom(&_ERC20Upgradeable.TransactOpts, from, to, amount)
}

// ERC20UpgradeableApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the ERC20Upgradeable contract.
type ERC20UpgradeableApprovalIterator struct {
	Event *ERC20UpgradeableApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20UpgradeableApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20UpgradeableApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20UpgradeableApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20UpgradeableApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20UpgradeableApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20UpgradeableApproval represents a Approval event raised by the ERC20Upgradeable contract.
type ERC20UpgradeableApproval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20Upgradeable *ERC20UpgradeableFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*ERC20UpgradeableApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _ERC20Upgradeable.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &ERC20UpgradeableApprovalIterator{contract: _ERC20Upgradeable.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20Upgradeable *ERC20UpgradeableFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *ERC20UpgradeableApproval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _ERC20Upgradeable.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20UpgradeableApproval)
				if err := _ERC20Upgradeable.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_ERC20Upgradeable *ERC20UpgradeableFilterer) ParseApproval(log types.Log) (*ERC20UpgradeableApproval, error) {
	event := new(ERC20UpgradeableApproval)
	if err := _ERC20Upgradeable.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20UpgradeableInitializedIterator is returned from FilterInitialized and is used to iterate over the raw logs and unpacked data for Initialized events raised by the ERC20Upgradeable contract.
type ERC20UpgradeableInitializedIterator struct {
	Event *ERC20UpgradeableInitialized // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20UpgradeableInitializedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20UpgradeableInitialized)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20UpgradeableInitialized)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20UpgradeableInitializedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20UpgradeableInitializedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20UpgradeableInitialized represents a Initialized event raised by the ERC20Upgradeable contract.
type ERC20UpgradeableInitialized struct {
	Version uint8
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInitialized is a free log retrieval operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_ERC20Upgradeable *ERC20UpgradeableFilterer) FilterInitialized(opts *bind.FilterOpts) (*ERC20UpgradeableInitializedIterator, error) {

	logs, sub, err := _ERC20Upgradeable.contract.FilterLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return &ERC20UpgradeableInitializedIterator{contract: _ERC20Upgradeable.contract, event: "Initialized", logs: logs, sub: sub}, nil
}

// WatchInitialized is a free log subscription operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_ERC20Upgradeable *ERC20UpgradeableFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *ERC20UpgradeableInitialized) (event.Subscription, error) {

	logs, sub, err := _ERC20Upgradeable.contract.WatchLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20UpgradeableInitialized)
				if err := _ERC20Upgradeable.contract.UnpackLog(event, "Initialized", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInitialized is a log parse operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_ERC20Upgradeable *ERC20UpgradeableFilterer) ParseInitialized(log types.Log) (*ERC20UpgradeableInitialized, error) {
	event := new(ERC20UpgradeableInitialized)
	if err := _ERC20Upgradeable.contract.UnpackLog(event, "Initialized", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20UpgradeableTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the ERC20Upgradeable contract.
type ERC20UpgradeableTransferIterator struct {
	Event *ERC20UpgradeableTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20UpgradeableTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20UpgradeableTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20UpgradeableTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20UpgradeableTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20UpgradeableTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20UpgradeableTransfer represents a Transfer event raised by the ERC20Upgradeable contract.
type ERC20UpgradeableTransfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20Upgradeable *ERC20UpgradeableFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*ERC20UpgradeableTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _ERC20Upgradeable.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &ERC20UpgradeableTransferIterator{contract: _ERC20Upgradeable.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20Upgradeable *ERC20UpgradeableFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *ERC20UpgradeableTransfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _ERC20Upgradeable.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20UpgradeableTransfer)
				if err := _ERC20Upgradeable.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_ERC20Upgradeable *ERC20UpgradeableFilterer) ParseTransfer(log types.Log) (*ERC20UpgradeableTransfer, error) {
	event := new(ERC20UpgradeableTransfer)
	if err := _ERC20Upgradeable.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// EmptyMetaData contains all meta data concerning the Empty contract.
var EmptyMetaData = &bind.MetaData{
	ABI: "[]",
}

// EmptyABI is the input ABI used to generate the binding from.
// Deprecated: Use EmptyMetaData.ABI instead.
var EmptyABI = EmptyMetaData.ABI

// Empty is an auto generated Go binding around an Ethereum contract.
type Empty struct {
	EmptyCaller     // Read-only binding to the contract
	EmptyTransactor // Write-only binding to the contract
	EmptyFilterer   // Log filterer for contract events
}

// EmptyCaller is an auto generated read-only Go binding around an Ethereum contract.
type EmptyCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EmptyTransactor is an auto generated write-only Go binding around an Ethereum contract.
type EmptyTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EmptyFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type EmptyFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EmptySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type EmptySession struct {
	Contract     *Empty            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// EmptyCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type EmptyCallerSession struct {
	Contract *EmptyCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// EmptyTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type EmptyTransactorSession struct {
	Contract     *EmptyTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// EmptyRaw is an auto generated low-level Go binding around an Ethereum contract.
type EmptyRaw struct {
	Contract *Empty // Generic contract binding to access the raw methods on
}

// EmptyCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type EmptyCallerRaw struct {
	Contract *EmptyCaller // Generic read-only contract binding to access the raw methods on
}

// EmptyTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type EmptyTransactorRaw struct {
	Contract *EmptyTransactor // Generic write-only contract binding to access the raw methods on
}

// NewEmpty creates a new instance of Empty, bound to a specific deployed contract.
func NewEmpty(address common.Address, backend bind.ContractBackend) (*Empty, error) {
	contract, err := bindEmpty(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Empty{EmptyCaller: EmptyCaller{contract: contract}, EmptyTransactor: EmptyTransactor{contract: contract}, EmptyFilterer: EmptyFilterer{contract: contract}}, nil
}

// NewEmptyCaller creates a new read-only instance of Empty, bound to a specific deployed contract.
func NewEmptyCaller(address common.Address, caller bind.ContractCaller) (*EmptyCaller, error) {
	contract, err := bindEmpty(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &EmptyCaller{contract: contract}, nil
}

// NewEmptyTransactor creates a new write-only instance of Empty, bound to a specific deployed contract.
func NewEmptyTransactor(address common.Address, transactor bind.ContractTransactor) (*EmptyTransactor, error) {
	contract, err := bindEmpty(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &EmptyTransactor{contract: contract}, nil
}

// NewEmptyFilterer creates a new log filterer instance of Empty, bound to a specific deployed contract.
func NewEmptyFilterer(address common.Address, filterer bind.ContractFilterer) (*EmptyFilterer, error) {
	contract, err := bindEmpty(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &EmptyFilterer{contract: contract}, nil
}

// bindEmpty binds a generic wrapper to an already deployed contract.
func bindEmpty(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(EmptyABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Empty *EmptyRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Empty.Contract.EmptyCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Empty *EmptyRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Empty.Contract.EmptyTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Empty *EmptyRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Empty.Contract.EmptyTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Empty *EmptyCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Empty.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Empty *EmptyTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Empty.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Empty *EmptyTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Empty.Contract.contract.Transact(opts, method, params...)
}

// EnumerableSetMetaData contains all meta data concerning the EnumerableSet contract.
var EnumerableSetMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c834205b34d85701a5bb52d241be6f5720007e48d932a2def3525df1142f7a2164736f6c634300080a0033",
}

// EnumerableSetABI is the input ABI used to generate the binding from.
// Deprecated: Use EnumerableSetMetaData.ABI instead.
var EnumerableSetABI = EnumerableSetMetaData.ABI

// EnumerableSetBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use EnumerableSetMetaData.Bin instead.
var EnumerableSetBin = EnumerableSetMetaData.Bin

// DeployEnumerableSet deploys a new Ethereum contract, binding an instance of EnumerableSet to it.
func DeployEnumerableSet(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *EnumerableSet, error) {
	parsed, err := EnumerableSetMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(EnumerableSetBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &EnumerableSet{EnumerableSetCaller: EnumerableSetCaller{contract: contract}, EnumerableSetTransactor: EnumerableSetTransactor{contract: contract}, EnumerableSetFilterer: EnumerableSetFilterer{contract: contract}}, nil
}

// EnumerableSet is an auto generated Go binding around an Ethereum contract.
type EnumerableSet struct {
	EnumerableSetCaller     // Read-only binding to the contract
	EnumerableSetTransactor // Write-only binding to the contract
	EnumerableSetFilterer   // Log filterer for contract events
}

// EnumerableSetCaller is an auto generated read-only Go binding around an Ethereum contract.
type EnumerableSetCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EnumerableSetTransactor is an auto generated write-only Go binding around an Ethereum contract.
type EnumerableSetTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EnumerableSetFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type EnumerableSetFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EnumerableSetSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type EnumerableSetSession struct {
	Contract     *EnumerableSet    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// EnumerableSetCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type EnumerableSetCallerSession struct {
	Contract *EnumerableSetCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// EnumerableSetTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type EnumerableSetTransactorSession struct {
	Contract     *EnumerableSetTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// EnumerableSetRaw is an auto generated low-level Go binding around an Ethereum contract.
type EnumerableSetRaw struct {
	Contract *EnumerableSet // Generic contract binding to access the raw methods on
}

// EnumerableSetCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type EnumerableSetCallerRaw struct {
	Contract *EnumerableSetCaller // Generic read-only contract binding to access the raw methods on
}

// EnumerableSetTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type EnumerableSetTransactorRaw struct {
	Contract *EnumerableSetTransactor // Generic write-only contract binding to access the raw methods on
}

// NewEnumerableSet creates a new instance of EnumerableSet, bound to a specific deployed contract.
func NewEnumerableSet(address common.Address, backend bind.ContractBackend) (*EnumerableSet, error) {
	contract, err := bindEnumerableSet(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &EnumerableSet{EnumerableSetCaller: EnumerableSetCaller{contract: contract}, EnumerableSetTransactor: EnumerableSetTransactor{contract: contract}, EnumerableSetFilterer: EnumerableSetFilterer{contract: contract}}, nil
}

// NewEnumerableSetCaller creates a new read-only instance of EnumerableSet, bound to a specific deployed contract.
func NewEnumerableSetCaller(address common.Address, caller bind.ContractCaller) (*EnumerableSetCaller, error) {
	contract, err := bindEnumerableSet(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &EnumerableSetCaller{contract: contract}, nil
}

// NewEnumerableSetTransactor creates a new write-only instance of EnumerableSet, bound to a specific deployed contract.
func NewEnumerableSetTransactor(address common.Address, transactor bind.ContractTransactor) (*EnumerableSetTransactor, error) {
	contract, err := bindEnumerableSet(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &EnumerableSetTransactor{contract: contract}, nil
}

// NewEnumerableSetFilterer creates a new log filterer instance of EnumerableSet, bound to a specific deployed contract.
func NewEnumerableSetFilterer(address common.Address, filterer bind.ContractFilterer) (*EnumerableSetFilterer, error) {
	contract, err := bindEnumerableSet(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &EnumerableSetFilterer{contract: contract}, nil
}

// bindEnumerableSet binds a generic wrapper to an already deployed contract.
func bindEnumerableSet(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(EnumerableSetABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_EnumerableSet *EnumerableSetRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _EnumerableSet.Contract.EnumerableSetCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_EnumerableSet *EnumerableSetRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _EnumerableSet.Contract.EnumerableSetTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_EnumerableSet *EnumerableSetRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _EnumerableSet.Contract.EnumerableSetTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_EnumerableSet *EnumerableSetCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _EnumerableSet.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_EnumerableSet *EnumerableSetTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _EnumerableSet.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_EnumerableSet *EnumerableSetTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _EnumerableSet.Contract.contract.Transact(opts, method, params...)
}

// IAccessControlMetaData contains all meta data concerning the IAccessControl contract.
var IAccessControlMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"248a9ca3": "getRoleAdmin(bytes32)",
		"2f2ff15d": "grantRole(bytes32,address)",
		"91d14854": "hasRole(bytes32,address)",
		"36568abe": "renounceRole(bytes32,address)",
		"d547741f": "revokeRole(bytes32,address)",
	},
}

// IAccessControlABI is the input ABI used to generate the binding from.
// Deprecated: Use IAccessControlMetaData.ABI instead.
var IAccessControlABI = IAccessControlMetaData.ABI

// Deprecated: Use IAccessControlMetaData.Sigs instead.
// IAccessControlFuncSigs maps the 4-byte function signature to its string representation.
var IAccessControlFuncSigs = IAccessControlMetaData.Sigs

// IAccessControl is an auto generated Go binding around an Ethereum contract.
type IAccessControl struct {
	IAccessControlCaller     // Read-only binding to the contract
	IAccessControlTransactor // Write-only binding to the contract
	IAccessControlFilterer   // Log filterer for contract events
}

// IAccessControlCaller is an auto generated read-only Go binding around an Ethereum contract.
type IAccessControlCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAccessControlTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IAccessControlTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAccessControlFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IAccessControlFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAccessControlSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IAccessControlSession struct {
	Contract     *IAccessControl   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IAccessControlCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IAccessControlCallerSession struct {
	Contract *IAccessControlCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// IAccessControlTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IAccessControlTransactorSession struct {
	Contract     *IAccessControlTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// IAccessControlRaw is an auto generated low-level Go binding around an Ethereum contract.
type IAccessControlRaw struct {
	Contract *IAccessControl // Generic contract binding to access the raw methods on
}

// IAccessControlCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IAccessControlCallerRaw struct {
	Contract *IAccessControlCaller // Generic read-only contract binding to access the raw methods on
}

// IAccessControlTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IAccessControlTransactorRaw struct {
	Contract *IAccessControlTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIAccessControl creates a new instance of IAccessControl, bound to a specific deployed contract.
func NewIAccessControl(address common.Address, backend bind.ContractBackend) (*IAccessControl, error) {
	contract, err := bindIAccessControl(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IAccessControl{IAccessControlCaller: IAccessControlCaller{contract: contract}, IAccessControlTransactor: IAccessControlTransactor{contract: contract}, IAccessControlFilterer: IAccessControlFilterer{contract: contract}}, nil
}

// NewIAccessControlCaller creates a new read-only instance of IAccessControl, bound to a specific deployed contract.
func NewIAccessControlCaller(address common.Address, caller bind.ContractCaller) (*IAccessControlCaller, error) {
	contract, err := bindIAccessControl(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IAccessControlCaller{contract: contract}, nil
}

// NewIAccessControlTransactor creates a new write-only instance of IAccessControl, bound to a specific deployed contract.
func NewIAccessControlTransactor(address common.Address, transactor bind.ContractTransactor) (*IAccessControlTransactor, error) {
	contract, err := bindIAccessControl(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IAccessControlTransactor{contract: contract}, nil
}

// NewIAccessControlFilterer creates a new log filterer instance of IAccessControl, bound to a specific deployed contract.
func NewIAccessControlFilterer(address common.Address, filterer bind.ContractFilterer) (*IAccessControlFilterer, error) {
	contract, err := bindIAccessControl(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IAccessControlFilterer{contract: contract}, nil
}

// bindIAccessControl binds a generic wrapper to an already deployed contract.
func bindIAccessControl(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IAccessControlABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAccessControl *IAccessControlRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAccessControl.Contract.IAccessControlCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAccessControl *IAccessControlRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAccessControl.Contract.IAccessControlTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAccessControl *IAccessControlRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAccessControl.Contract.IAccessControlTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAccessControl *IAccessControlCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAccessControl.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAccessControl *IAccessControlTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAccessControl.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAccessControl *IAccessControlTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAccessControl.Contract.contract.Transact(opts, method, params...)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_IAccessControl *IAccessControlCaller) GetRoleAdmin(opts *bind.CallOpts, role [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _IAccessControl.contract.Call(opts, &out, "getRoleAdmin", role)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_IAccessControl *IAccessControlSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _IAccessControl.Contract.GetRoleAdmin(&_IAccessControl.CallOpts, role)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_IAccessControl *IAccessControlCallerSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _IAccessControl.Contract.GetRoleAdmin(&_IAccessControl.CallOpts, role)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_IAccessControl *IAccessControlCaller) HasRole(opts *bind.CallOpts, role [32]byte, account common.Address) (bool, error) {
	var out []interface{}
	err := _IAccessControl.contract.Call(opts, &out, "hasRole", role, account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_IAccessControl *IAccessControlSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _IAccessControl.Contract.HasRole(&_IAccessControl.CallOpts, role, account)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_IAccessControl *IAccessControlCallerSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _IAccessControl.Contract.HasRole(&_IAccessControl.CallOpts, role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_IAccessControl *IAccessControlTransactor) GrantRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _IAccessControl.contract.Transact(opts, "grantRole", role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_IAccessControl *IAccessControlSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _IAccessControl.Contract.GrantRole(&_IAccessControl.TransactOpts, role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_IAccessControl *IAccessControlTransactorSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _IAccessControl.Contract.GrantRole(&_IAccessControl.TransactOpts, role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_IAccessControl *IAccessControlTransactor) RenounceRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _IAccessControl.contract.Transact(opts, "renounceRole", role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_IAccessControl *IAccessControlSession) RenounceRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _IAccessControl.Contract.RenounceRole(&_IAccessControl.TransactOpts, role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_IAccessControl *IAccessControlTransactorSession) RenounceRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _IAccessControl.Contract.RenounceRole(&_IAccessControl.TransactOpts, role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_IAccessControl *IAccessControlTransactor) RevokeRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _IAccessControl.contract.Transact(opts, "revokeRole", role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_IAccessControl *IAccessControlSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _IAccessControl.Contract.RevokeRole(&_IAccessControl.TransactOpts, role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_IAccessControl *IAccessControlTransactorSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _IAccessControl.Contract.RevokeRole(&_IAccessControl.TransactOpts, role, account)
}

// IAccessControlRoleAdminChangedIterator is returned from FilterRoleAdminChanged and is used to iterate over the raw logs and unpacked data for RoleAdminChanged events raised by the IAccessControl contract.
type IAccessControlRoleAdminChangedIterator struct {
	Event *IAccessControlRoleAdminChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAccessControlRoleAdminChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAccessControlRoleAdminChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAccessControlRoleAdminChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAccessControlRoleAdminChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAccessControlRoleAdminChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAccessControlRoleAdminChanged represents a RoleAdminChanged event raised by the IAccessControl contract.
type IAccessControlRoleAdminChanged struct {
	Role              [32]byte
	PreviousAdminRole [32]byte
	NewAdminRole      [32]byte
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRoleAdminChanged is a free log retrieval operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_IAccessControl *IAccessControlFilterer) FilterRoleAdminChanged(opts *bind.FilterOpts, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (*IAccessControlRoleAdminChangedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _IAccessControl.contract.FilterLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return &IAccessControlRoleAdminChangedIterator{contract: _IAccessControl.contract, event: "RoleAdminChanged", logs: logs, sub: sub}, nil
}

// WatchRoleAdminChanged is a free log subscription operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_IAccessControl *IAccessControlFilterer) WatchRoleAdminChanged(opts *bind.WatchOpts, sink chan<- *IAccessControlRoleAdminChanged, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _IAccessControl.contract.WatchLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAccessControlRoleAdminChanged)
				if err := _IAccessControl.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleAdminChanged is a log parse operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_IAccessControl *IAccessControlFilterer) ParseRoleAdminChanged(log types.Log) (*IAccessControlRoleAdminChanged, error) {
	event := new(IAccessControlRoleAdminChanged)
	if err := _IAccessControl.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAccessControlRoleGrantedIterator is returned from FilterRoleGranted and is used to iterate over the raw logs and unpacked data for RoleGranted events raised by the IAccessControl contract.
type IAccessControlRoleGrantedIterator struct {
	Event *IAccessControlRoleGranted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAccessControlRoleGrantedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAccessControlRoleGranted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAccessControlRoleGranted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAccessControlRoleGrantedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAccessControlRoleGrantedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAccessControlRoleGranted represents a RoleGranted event raised by the IAccessControl contract.
type IAccessControlRoleGranted struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleGranted is a free log retrieval operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_IAccessControl *IAccessControlFilterer) FilterRoleGranted(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*IAccessControlRoleGrantedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IAccessControl.contract.FilterLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &IAccessControlRoleGrantedIterator{contract: _IAccessControl.contract, event: "RoleGranted", logs: logs, sub: sub}, nil
}

// WatchRoleGranted is a free log subscription operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_IAccessControl *IAccessControlFilterer) WatchRoleGranted(opts *bind.WatchOpts, sink chan<- *IAccessControlRoleGranted, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IAccessControl.contract.WatchLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAccessControlRoleGranted)
				if err := _IAccessControl.contract.UnpackLog(event, "RoleGranted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleGranted is a log parse operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_IAccessControl *IAccessControlFilterer) ParseRoleGranted(log types.Log) (*IAccessControlRoleGranted, error) {
	event := new(IAccessControlRoleGranted)
	if err := _IAccessControl.contract.UnpackLog(event, "RoleGranted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAccessControlRoleRevokedIterator is returned from FilterRoleRevoked and is used to iterate over the raw logs and unpacked data for RoleRevoked events raised by the IAccessControl contract.
type IAccessControlRoleRevokedIterator struct {
	Event *IAccessControlRoleRevoked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAccessControlRoleRevokedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAccessControlRoleRevoked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAccessControlRoleRevoked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAccessControlRoleRevokedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAccessControlRoleRevokedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAccessControlRoleRevoked represents a RoleRevoked event raised by the IAccessControl contract.
type IAccessControlRoleRevoked struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleRevoked is a free log retrieval operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_IAccessControl *IAccessControlFilterer) FilterRoleRevoked(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*IAccessControlRoleRevokedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IAccessControl.contract.FilterLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &IAccessControlRoleRevokedIterator{contract: _IAccessControl.contract, event: "RoleRevoked", logs: logs, sub: sub}, nil
}

// WatchRoleRevoked is a free log subscription operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_IAccessControl *IAccessControlFilterer) WatchRoleRevoked(opts *bind.WatchOpts, sink chan<- *IAccessControlRoleRevoked, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IAccessControl.contract.WatchLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAccessControlRoleRevoked)
				if err := _IAccessControl.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleRevoked is a log parse operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_IAccessControl *IAccessControlFilterer) ParseRoleRevoked(log types.Log) (*IAccessControlRoleRevoked, error) {
	event := new(IAccessControlRoleRevoked)
	if err := _IAccessControl.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAccessControlEnumerableMetaData contains all meta data concerning the IAccessControlEnumerable contract.
var IAccessControlEnumerableMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"248a9ca3": "getRoleAdmin(bytes32)",
		"9010d07c": "getRoleMember(bytes32,uint256)",
		"ca15c873": "getRoleMemberCount(bytes32)",
		"2f2ff15d": "grantRole(bytes32,address)",
		"91d14854": "hasRole(bytes32,address)",
		"36568abe": "renounceRole(bytes32,address)",
		"d547741f": "revokeRole(bytes32,address)",
	},
}

// IAccessControlEnumerableABI is the input ABI used to generate the binding from.
// Deprecated: Use IAccessControlEnumerableMetaData.ABI instead.
var IAccessControlEnumerableABI = IAccessControlEnumerableMetaData.ABI

// Deprecated: Use IAccessControlEnumerableMetaData.Sigs instead.
// IAccessControlEnumerableFuncSigs maps the 4-byte function signature to its string representation.
var IAccessControlEnumerableFuncSigs = IAccessControlEnumerableMetaData.Sigs

// IAccessControlEnumerable is an auto generated Go binding around an Ethereum contract.
type IAccessControlEnumerable struct {
	IAccessControlEnumerableCaller     // Read-only binding to the contract
	IAccessControlEnumerableTransactor // Write-only binding to the contract
	IAccessControlEnumerableFilterer   // Log filterer for contract events
}

// IAccessControlEnumerableCaller is an auto generated read-only Go binding around an Ethereum contract.
type IAccessControlEnumerableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAccessControlEnumerableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IAccessControlEnumerableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAccessControlEnumerableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IAccessControlEnumerableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IAccessControlEnumerableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IAccessControlEnumerableSession struct {
	Contract     *IAccessControlEnumerable // Generic contract binding to set the session for
	CallOpts     bind.CallOpts             // Call options to use throughout this session
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// IAccessControlEnumerableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IAccessControlEnumerableCallerSession struct {
	Contract *IAccessControlEnumerableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                   // Call options to use throughout this session
}

// IAccessControlEnumerableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IAccessControlEnumerableTransactorSession struct {
	Contract     *IAccessControlEnumerableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                   // Transaction auth options to use throughout this session
}

// IAccessControlEnumerableRaw is an auto generated low-level Go binding around an Ethereum contract.
type IAccessControlEnumerableRaw struct {
	Contract *IAccessControlEnumerable // Generic contract binding to access the raw methods on
}

// IAccessControlEnumerableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IAccessControlEnumerableCallerRaw struct {
	Contract *IAccessControlEnumerableCaller // Generic read-only contract binding to access the raw methods on
}

// IAccessControlEnumerableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IAccessControlEnumerableTransactorRaw struct {
	Contract *IAccessControlEnumerableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIAccessControlEnumerable creates a new instance of IAccessControlEnumerable, bound to a specific deployed contract.
func NewIAccessControlEnumerable(address common.Address, backend bind.ContractBackend) (*IAccessControlEnumerable, error) {
	contract, err := bindIAccessControlEnumerable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IAccessControlEnumerable{IAccessControlEnumerableCaller: IAccessControlEnumerableCaller{contract: contract}, IAccessControlEnumerableTransactor: IAccessControlEnumerableTransactor{contract: contract}, IAccessControlEnumerableFilterer: IAccessControlEnumerableFilterer{contract: contract}}, nil
}

// NewIAccessControlEnumerableCaller creates a new read-only instance of IAccessControlEnumerable, bound to a specific deployed contract.
func NewIAccessControlEnumerableCaller(address common.Address, caller bind.ContractCaller) (*IAccessControlEnumerableCaller, error) {
	contract, err := bindIAccessControlEnumerable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IAccessControlEnumerableCaller{contract: contract}, nil
}

// NewIAccessControlEnumerableTransactor creates a new write-only instance of IAccessControlEnumerable, bound to a specific deployed contract.
func NewIAccessControlEnumerableTransactor(address common.Address, transactor bind.ContractTransactor) (*IAccessControlEnumerableTransactor, error) {
	contract, err := bindIAccessControlEnumerable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IAccessControlEnumerableTransactor{contract: contract}, nil
}

// NewIAccessControlEnumerableFilterer creates a new log filterer instance of IAccessControlEnumerable, bound to a specific deployed contract.
func NewIAccessControlEnumerableFilterer(address common.Address, filterer bind.ContractFilterer) (*IAccessControlEnumerableFilterer, error) {
	contract, err := bindIAccessControlEnumerable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IAccessControlEnumerableFilterer{contract: contract}, nil
}

// bindIAccessControlEnumerable binds a generic wrapper to an already deployed contract.
func bindIAccessControlEnumerable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IAccessControlEnumerableABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAccessControlEnumerable *IAccessControlEnumerableRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAccessControlEnumerable.Contract.IAccessControlEnumerableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAccessControlEnumerable *IAccessControlEnumerableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAccessControlEnumerable.Contract.IAccessControlEnumerableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAccessControlEnumerable *IAccessControlEnumerableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAccessControlEnumerable.Contract.IAccessControlEnumerableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IAccessControlEnumerable *IAccessControlEnumerableCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IAccessControlEnumerable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IAccessControlEnumerable *IAccessControlEnumerableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IAccessControlEnumerable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IAccessControlEnumerable *IAccessControlEnumerableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IAccessControlEnumerable.Contract.contract.Transact(opts, method, params...)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_IAccessControlEnumerable *IAccessControlEnumerableCaller) GetRoleAdmin(opts *bind.CallOpts, role [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _IAccessControlEnumerable.contract.Call(opts, &out, "getRoleAdmin", role)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_IAccessControlEnumerable *IAccessControlEnumerableSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _IAccessControlEnumerable.Contract.GetRoleAdmin(&_IAccessControlEnumerable.CallOpts, role)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_IAccessControlEnumerable *IAccessControlEnumerableCallerSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _IAccessControlEnumerable.Contract.GetRoleAdmin(&_IAccessControlEnumerable.CallOpts, role)
}

// GetRoleMember is a free data retrieval call binding the contract method 0x9010d07c.
//
// Solidity: function getRoleMember(bytes32 role, uint256 index) view returns(address)
func (_IAccessControlEnumerable *IAccessControlEnumerableCaller) GetRoleMember(opts *bind.CallOpts, role [32]byte, index *big.Int) (common.Address, error) {
	var out []interface{}
	err := _IAccessControlEnumerable.contract.Call(opts, &out, "getRoleMember", role, index)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetRoleMember is a free data retrieval call binding the contract method 0x9010d07c.
//
// Solidity: function getRoleMember(bytes32 role, uint256 index) view returns(address)
func (_IAccessControlEnumerable *IAccessControlEnumerableSession) GetRoleMember(role [32]byte, index *big.Int) (common.Address, error) {
	return _IAccessControlEnumerable.Contract.GetRoleMember(&_IAccessControlEnumerable.CallOpts, role, index)
}

// GetRoleMember is a free data retrieval call binding the contract method 0x9010d07c.
//
// Solidity: function getRoleMember(bytes32 role, uint256 index) view returns(address)
func (_IAccessControlEnumerable *IAccessControlEnumerableCallerSession) GetRoleMember(role [32]byte, index *big.Int) (common.Address, error) {
	return _IAccessControlEnumerable.Contract.GetRoleMember(&_IAccessControlEnumerable.CallOpts, role, index)
}

// GetRoleMemberCount is a free data retrieval call binding the contract method 0xca15c873.
//
// Solidity: function getRoleMemberCount(bytes32 role) view returns(uint256)
func (_IAccessControlEnumerable *IAccessControlEnumerableCaller) GetRoleMemberCount(opts *bind.CallOpts, role [32]byte) (*big.Int, error) {
	var out []interface{}
	err := _IAccessControlEnumerable.contract.Call(opts, &out, "getRoleMemberCount", role)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetRoleMemberCount is a free data retrieval call binding the contract method 0xca15c873.
//
// Solidity: function getRoleMemberCount(bytes32 role) view returns(uint256)
func (_IAccessControlEnumerable *IAccessControlEnumerableSession) GetRoleMemberCount(role [32]byte) (*big.Int, error) {
	return _IAccessControlEnumerable.Contract.GetRoleMemberCount(&_IAccessControlEnumerable.CallOpts, role)
}

// GetRoleMemberCount is a free data retrieval call binding the contract method 0xca15c873.
//
// Solidity: function getRoleMemberCount(bytes32 role) view returns(uint256)
func (_IAccessControlEnumerable *IAccessControlEnumerableCallerSession) GetRoleMemberCount(role [32]byte) (*big.Int, error) {
	return _IAccessControlEnumerable.Contract.GetRoleMemberCount(&_IAccessControlEnumerable.CallOpts, role)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_IAccessControlEnumerable *IAccessControlEnumerableCaller) HasRole(opts *bind.CallOpts, role [32]byte, account common.Address) (bool, error) {
	var out []interface{}
	err := _IAccessControlEnumerable.contract.Call(opts, &out, "hasRole", role, account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_IAccessControlEnumerable *IAccessControlEnumerableSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _IAccessControlEnumerable.Contract.HasRole(&_IAccessControlEnumerable.CallOpts, role, account)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_IAccessControlEnumerable *IAccessControlEnumerableCallerSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _IAccessControlEnumerable.Contract.HasRole(&_IAccessControlEnumerable.CallOpts, role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_IAccessControlEnumerable *IAccessControlEnumerableTransactor) GrantRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _IAccessControlEnumerable.contract.Transact(opts, "grantRole", role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_IAccessControlEnumerable *IAccessControlEnumerableSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _IAccessControlEnumerable.Contract.GrantRole(&_IAccessControlEnumerable.TransactOpts, role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_IAccessControlEnumerable *IAccessControlEnumerableTransactorSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _IAccessControlEnumerable.Contract.GrantRole(&_IAccessControlEnumerable.TransactOpts, role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_IAccessControlEnumerable *IAccessControlEnumerableTransactor) RenounceRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _IAccessControlEnumerable.contract.Transact(opts, "renounceRole", role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_IAccessControlEnumerable *IAccessControlEnumerableSession) RenounceRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _IAccessControlEnumerable.Contract.RenounceRole(&_IAccessControlEnumerable.TransactOpts, role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_IAccessControlEnumerable *IAccessControlEnumerableTransactorSession) RenounceRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _IAccessControlEnumerable.Contract.RenounceRole(&_IAccessControlEnumerable.TransactOpts, role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_IAccessControlEnumerable *IAccessControlEnumerableTransactor) RevokeRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _IAccessControlEnumerable.contract.Transact(opts, "revokeRole", role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_IAccessControlEnumerable *IAccessControlEnumerableSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _IAccessControlEnumerable.Contract.RevokeRole(&_IAccessControlEnumerable.TransactOpts, role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_IAccessControlEnumerable *IAccessControlEnumerableTransactorSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _IAccessControlEnumerable.Contract.RevokeRole(&_IAccessControlEnumerable.TransactOpts, role, account)
}

// IAccessControlEnumerableRoleAdminChangedIterator is returned from FilterRoleAdminChanged and is used to iterate over the raw logs and unpacked data for RoleAdminChanged events raised by the IAccessControlEnumerable contract.
type IAccessControlEnumerableRoleAdminChangedIterator struct {
	Event *IAccessControlEnumerableRoleAdminChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAccessControlEnumerableRoleAdminChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAccessControlEnumerableRoleAdminChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAccessControlEnumerableRoleAdminChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAccessControlEnumerableRoleAdminChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAccessControlEnumerableRoleAdminChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAccessControlEnumerableRoleAdminChanged represents a RoleAdminChanged event raised by the IAccessControlEnumerable contract.
type IAccessControlEnumerableRoleAdminChanged struct {
	Role              [32]byte
	PreviousAdminRole [32]byte
	NewAdminRole      [32]byte
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRoleAdminChanged is a free log retrieval operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_IAccessControlEnumerable *IAccessControlEnumerableFilterer) FilterRoleAdminChanged(opts *bind.FilterOpts, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (*IAccessControlEnumerableRoleAdminChangedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _IAccessControlEnumerable.contract.FilterLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return &IAccessControlEnumerableRoleAdminChangedIterator{contract: _IAccessControlEnumerable.contract, event: "RoleAdminChanged", logs: logs, sub: sub}, nil
}

// WatchRoleAdminChanged is a free log subscription operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_IAccessControlEnumerable *IAccessControlEnumerableFilterer) WatchRoleAdminChanged(opts *bind.WatchOpts, sink chan<- *IAccessControlEnumerableRoleAdminChanged, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _IAccessControlEnumerable.contract.WatchLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAccessControlEnumerableRoleAdminChanged)
				if err := _IAccessControlEnumerable.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleAdminChanged is a log parse operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_IAccessControlEnumerable *IAccessControlEnumerableFilterer) ParseRoleAdminChanged(log types.Log) (*IAccessControlEnumerableRoleAdminChanged, error) {
	event := new(IAccessControlEnumerableRoleAdminChanged)
	if err := _IAccessControlEnumerable.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAccessControlEnumerableRoleGrantedIterator is returned from FilterRoleGranted and is used to iterate over the raw logs and unpacked data for RoleGranted events raised by the IAccessControlEnumerable contract.
type IAccessControlEnumerableRoleGrantedIterator struct {
	Event *IAccessControlEnumerableRoleGranted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAccessControlEnumerableRoleGrantedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAccessControlEnumerableRoleGranted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAccessControlEnumerableRoleGranted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAccessControlEnumerableRoleGrantedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAccessControlEnumerableRoleGrantedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAccessControlEnumerableRoleGranted represents a RoleGranted event raised by the IAccessControlEnumerable contract.
type IAccessControlEnumerableRoleGranted struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleGranted is a free log retrieval operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_IAccessControlEnumerable *IAccessControlEnumerableFilterer) FilterRoleGranted(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*IAccessControlEnumerableRoleGrantedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IAccessControlEnumerable.contract.FilterLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &IAccessControlEnumerableRoleGrantedIterator{contract: _IAccessControlEnumerable.contract, event: "RoleGranted", logs: logs, sub: sub}, nil
}

// WatchRoleGranted is a free log subscription operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_IAccessControlEnumerable *IAccessControlEnumerableFilterer) WatchRoleGranted(opts *bind.WatchOpts, sink chan<- *IAccessControlEnumerableRoleGranted, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IAccessControlEnumerable.contract.WatchLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAccessControlEnumerableRoleGranted)
				if err := _IAccessControlEnumerable.contract.UnpackLog(event, "RoleGranted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleGranted is a log parse operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_IAccessControlEnumerable *IAccessControlEnumerableFilterer) ParseRoleGranted(log types.Log) (*IAccessControlEnumerableRoleGranted, error) {
	event := new(IAccessControlEnumerableRoleGranted)
	if err := _IAccessControlEnumerable.contract.UnpackLog(event, "RoleGranted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IAccessControlEnumerableRoleRevokedIterator is returned from FilterRoleRevoked and is used to iterate over the raw logs and unpacked data for RoleRevoked events raised by the IAccessControlEnumerable contract.
type IAccessControlEnumerableRoleRevokedIterator struct {
	Event *IAccessControlEnumerableRoleRevoked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IAccessControlEnumerableRoleRevokedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IAccessControlEnumerableRoleRevoked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IAccessControlEnumerableRoleRevoked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IAccessControlEnumerableRoleRevokedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IAccessControlEnumerableRoleRevokedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IAccessControlEnumerableRoleRevoked represents a RoleRevoked event raised by the IAccessControlEnumerable contract.
type IAccessControlEnumerableRoleRevoked struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleRevoked is a free log retrieval operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_IAccessControlEnumerable *IAccessControlEnumerableFilterer) FilterRoleRevoked(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*IAccessControlEnumerableRoleRevokedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IAccessControlEnumerable.contract.FilterLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &IAccessControlEnumerableRoleRevokedIterator{contract: _IAccessControlEnumerable.contract, event: "RoleRevoked", logs: logs, sub: sub}, nil
}

// WatchRoleRevoked is a free log subscription operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_IAccessControlEnumerable *IAccessControlEnumerableFilterer) WatchRoleRevoked(opts *bind.WatchOpts, sink chan<- *IAccessControlEnumerableRoleRevoked, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _IAccessControlEnumerable.contract.WatchLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IAccessControlEnumerableRoleRevoked)
				if err := _IAccessControlEnumerable.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleRevoked is a log parse operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_IAccessControlEnumerable *IAccessControlEnumerableFilterer) ParseRoleRevoked(log types.Log) (*IAccessControlEnumerableRoleRevoked, error) {
	event := new(IAccessControlEnumerableRoleRevoked)
	if err := _IAccessControlEnumerable.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC165MetaData contains all meta data concerning the IERC165 contract.
var IERC165MetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"01ffc9a7": "supportsInterface(bytes4)",
	},
}

// IERC165ABI is the input ABI used to generate the binding from.
// Deprecated: Use IERC165MetaData.ABI instead.
var IERC165ABI = IERC165MetaData.ABI

// Deprecated: Use IERC165MetaData.Sigs instead.
// IERC165FuncSigs maps the 4-byte function signature to its string representation.
var IERC165FuncSigs = IERC165MetaData.Sigs

// IERC165 is an auto generated Go binding around an Ethereum contract.
type IERC165 struct {
	IERC165Caller     // Read-only binding to the contract
	IERC165Transactor // Write-only binding to the contract
	IERC165Filterer   // Log filterer for contract events
}

// IERC165Caller is an auto generated read-only Go binding around an Ethereum contract.
type IERC165Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC165Transactor is an auto generated write-only Go binding around an Ethereum contract.
type IERC165Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC165Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IERC165Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC165Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IERC165Session struct {
	Contract     *IERC165          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC165CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IERC165CallerSession struct {
	Contract *IERC165Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// IERC165TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IERC165TransactorSession struct {
	Contract     *IERC165Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// IERC165Raw is an auto generated low-level Go binding around an Ethereum contract.
type IERC165Raw struct {
	Contract *IERC165 // Generic contract binding to access the raw methods on
}

// IERC165CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IERC165CallerRaw struct {
	Contract *IERC165Caller // Generic read-only contract binding to access the raw methods on
}

// IERC165TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IERC165TransactorRaw struct {
	Contract *IERC165Transactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC165 creates a new instance of IERC165, bound to a specific deployed contract.
func NewIERC165(address common.Address, backend bind.ContractBackend) (*IERC165, error) {
	contract, err := bindIERC165(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC165{IERC165Caller: IERC165Caller{contract: contract}, IERC165Transactor: IERC165Transactor{contract: contract}, IERC165Filterer: IERC165Filterer{contract: contract}}, nil
}

// NewIERC165Caller creates a new read-only instance of IERC165, bound to a specific deployed contract.
func NewIERC165Caller(address common.Address, caller bind.ContractCaller) (*IERC165Caller, error) {
	contract, err := bindIERC165(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC165Caller{contract: contract}, nil
}

// NewIERC165Transactor creates a new write-only instance of IERC165, bound to a specific deployed contract.
func NewIERC165Transactor(address common.Address, transactor bind.ContractTransactor) (*IERC165Transactor, error) {
	contract, err := bindIERC165(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC165Transactor{contract: contract}, nil
}

// NewIERC165Filterer creates a new log filterer instance of IERC165, bound to a specific deployed contract.
func NewIERC165Filterer(address common.Address, filterer bind.ContractFilterer) (*IERC165Filterer, error) {
	contract, err := bindIERC165(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC165Filterer{contract: contract}, nil
}

// bindIERC165 binds a generic wrapper to an already deployed contract.
func bindIERC165(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IERC165ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC165 *IERC165Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC165.Contract.IERC165Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC165 *IERC165Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC165.Contract.IERC165Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC165 *IERC165Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC165.Contract.IERC165Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC165 *IERC165CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC165.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC165 *IERC165TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC165.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC165 *IERC165TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC165.Contract.contract.Transact(opts, method, params...)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC165 *IERC165Caller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _IERC165.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC165 *IERC165Session) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _IERC165.Contract.SupportsInterface(&_IERC165.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_IERC165 *IERC165CallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _IERC165.Contract.SupportsInterface(&_IERC165.CallOpts, interfaceId)
}

// IERC20MetaData contains all meta data concerning the IERC20 contract.
var IERC20MetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"dd62ed3e": "allowance(address,address)",
		"095ea7b3": "approve(address,uint256)",
		"70a08231": "balanceOf(address)",
		"18160ddd": "totalSupply()",
		"a9059cbb": "transfer(address,uint256)",
		"23b872dd": "transferFrom(address,address,uint256)",
	},
}

// IERC20ABI is the input ABI used to generate the binding from.
// Deprecated: Use IERC20MetaData.ABI instead.
var IERC20ABI = IERC20MetaData.ABI

// Deprecated: Use IERC20MetaData.Sigs instead.
// IERC20FuncSigs maps the 4-byte function signature to its string representation.
var IERC20FuncSigs = IERC20MetaData.Sigs

// IERC20 is an auto generated Go binding around an Ethereum contract.
type IERC20 struct {
	IERC20Caller     // Read-only binding to the contract
	IERC20Transactor // Write-only binding to the contract
	IERC20Filterer   // Log filterer for contract events
}

// IERC20Caller is an auto generated read-only Go binding around an Ethereum contract.
type IERC20Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20Transactor is an auto generated write-only Go binding around an Ethereum contract.
type IERC20Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IERC20Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IERC20Session struct {
	Contract     *IERC20           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IERC20CallerSession struct {
	Contract *IERC20Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// IERC20TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IERC20TransactorSession struct {
	Contract     *IERC20Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20Raw is an auto generated low-level Go binding around an Ethereum contract.
type IERC20Raw struct {
	Contract *IERC20 // Generic contract binding to access the raw methods on
}

// IERC20CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IERC20CallerRaw struct {
	Contract *IERC20Caller // Generic read-only contract binding to access the raw methods on
}

// IERC20TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IERC20TransactorRaw struct {
	Contract *IERC20Transactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC20 creates a new instance of IERC20, bound to a specific deployed contract.
func NewIERC20(address common.Address, backend bind.ContractBackend) (*IERC20, error) {
	contract, err := bindIERC20(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC20{IERC20Caller: IERC20Caller{contract: contract}, IERC20Transactor: IERC20Transactor{contract: contract}, IERC20Filterer: IERC20Filterer{contract: contract}}, nil
}

// NewIERC20Caller creates a new read-only instance of IERC20, bound to a specific deployed contract.
func NewIERC20Caller(address common.Address, caller bind.ContractCaller) (*IERC20Caller, error) {
	contract, err := bindIERC20(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20Caller{contract: contract}, nil
}

// NewIERC20Transactor creates a new write-only instance of IERC20, bound to a specific deployed contract.
func NewIERC20Transactor(address common.Address, transactor bind.ContractTransactor) (*IERC20Transactor, error) {
	contract, err := bindIERC20(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20Transactor{contract: contract}, nil
}

// NewIERC20Filterer creates a new log filterer instance of IERC20, bound to a specific deployed contract.
func NewIERC20Filterer(address common.Address, filterer bind.ContractFilterer) (*IERC20Filterer, error) {
	contract, err := bindIERC20(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC20Filterer{contract: contract}, nil
}

// bindIERC20 binds a generic wrapper to an already deployed contract.
func bindIERC20(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IERC20ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20 *IERC20Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20.Contract.IERC20Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20 *IERC20Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20.Contract.IERC20Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20 *IERC20Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20.Contract.IERC20Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20 *IERC20CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20 *IERC20TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20 *IERC20TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20 *IERC20Caller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20 *IERC20Session) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20.Contract.Allowance(&_IERC20.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20 *IERC20CallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20.Contract.Allowance(&_IERC20.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20 *IERC20Caller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20 *IERC20Session) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20.Contract.BalanceOf(&_IERC20.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20 *IERC20CallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20.Contract.BalanceOf(&_IERC20.CallOpts, account)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20 *IERC20Caller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IERC20.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20 *IERC20Session) TotalSupply() (*big.Int, error) {
	return _IERC20.Contract.TotalSupply(&_IERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20 *IERC20CallerSession) TotalSupply() (*big.Int, error) {
	return _IERC20.Contract.TotalSupply(&_IERC20.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20 *IERC20Transactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20 *IERC20Session) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Approve(&_IERC20.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20 *IERC20TransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Approve(&_IERC20.TransactOpts, spender, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20Transactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20Session) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Transfer(&_IERC20.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20TransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.Transfer(&_IERC20.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20Transactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20Session) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.TransferFrom(&_IERC20.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20 *IERC20TransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20.Contract.TransferFrom(&_IERC20.TransactOpts, from, to, amount)
}

// IERC20ApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the IERC20 contract.
type IERC20ApprovalIterator struct {
	Event *IERC20Approval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20ApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20Approval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20Approval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20ApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20ApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20Approval represents a Approval event raised by the IERC20 contract.
type IERC20Approval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20 *IERC20Filterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*IERC20ApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &IERC20ApprovalIterator{contract: _IERC20.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20 *IERC20Filterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *IERC20Approval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20Approval)
				if err := _IERC20.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20 *IERC20Filterer) ParseApproval(log types.Log) (*IERC20Approval, error) {
	event := new(IERC20Approval)
	if err := _IERC20.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20TransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the IERC20 contract.
type IERC20TransferIterator struct {
	Event *IERC20Transfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20TransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20Transfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20Transfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20TransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20TransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20Transfer represents a Transfer event raised by the IERC20 contract.
type IERC20Transfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20 *IERC20Filterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*IERC20TransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IERC20TransferIterator{contract: _IERC20.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20 *IERC20Filterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *IERC20Transfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20Transfer)
				if err := _IERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20 *IERC20Filterer) ParseTransfer(log types.Log) (*IERC20Transfer, error) {
	event := new(IERC20Transfer)
	if err := _IERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20MetadataUpgradeableMetaData contains all meta data concerning the IERC20MetadataUpgradeable contract.
var IERC20MetadataUpgradeableMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"dd62ed3e": "allowance(address,address)",
		"095ea7b3": "approve(address,uint256)",
		"70a08231": "balanceOf(address)",
		"313ce567": "decimals()",
		"06fdde03": "name()",
		"95d89b41": "symbol()",
		"18160ddd": "totalSupply()",
		"a9059cbb": "transfer(address,uint256)",
		"23b872dd": "transferFrom(address,address,uint256)",
	},
}

// IERC20MetadataUpgradeableABI is the input ABI used to generate the binding from.
// Deprecated: Use IERC20MetadataUpgradeableMetaData.ABI instead.
var IERC20MetadataUpgradeableABI = IERC20MetadataUpgradeableMetaData.ABI

// Deprecated: Use IERC20MetadataUpgradeableMetaData.Sigs instead.
// IERC20MetadataUpgradeableFuncSigs maps the 4-byte function signature to its string representation.
var IERC20MetadataUpgradeableFuncSigs = IERC20MetadataUpgradeableMetaData.Sigs

// IERC20MetadataUpgradeable is an auto generated Go binding around an Ethereum contract.
type IERC20MetadataUpgradeable struct {
	IERC20MetadataUpgradeableCaller     // Read-only binding to the contract
	IERC20MetadataUpgradeableTransactor // Write-only binding to the contract
	IERC20MetadataUpgradeableFilterer   // Log filterer for contract events
}

// IERC20MetadataUpgradeableCaller is an auto generated read-only Go binding around an Ethereum contract.
type IERC20MetadataUpgradeableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MetadataUpgradeableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IERC20MetadataUpgradeableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MetadataUpgradeableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IERC20MetadataUpgradeableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20MetadataUpgradeableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IERC20MetadataUpgradeableSession struct {
	Contract     *IERC20MetadataUpgradeable // Generic contract binding to set the session for
	CallOpts     bind.CallOpts              // Call options to use throughout this session
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// IERC20MetadataUpgradeableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IERC20MetadataUpgradeableCallerSession struct {
	Contract *IERC20MetadataUpgradeableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                    // Call options to use throughout this session
}

// IERC20MetadataUpgradeableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IERC20MetadataUpgradeableTransactorSession struct {
	Contract     *IERC20MetadataUpgradeableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                    // Transaction auth options to use throughout this session
}

// IERC20MetadataUpgradeableRaw is an auto generated low-level Go binding around an Ethereum contract.
type IERC20MetadataUpgradeableRaw struct {
	Contract *IERC20MetadataUpgradeable // Generic contract binding to access the raw methods on
}

// IERC20MetadataUpgradeableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IERC20MetadataUpgradeableCallerRaw struct {
	Contract *IERC20MetadataUpgradeableCaller // Generic read-only contract binding to access the raw methods on
}

// IERC20MetadataUpgradeableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IERC20MetadataUpgradeableTransactorRaw struct {
	Contract *IERC20MetadataUpgradeableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC20MetadataUpgradeable creates a new instance of IERC20MetadataUpgradeable, bound to a specific deployed contract.
func NewIERC20MetadataUpgradeable(address common.Address, backend bind.ContractBackend) (*IERC20MetadataUpgradeable, error) {
	contract, err := bindIERC20MetadataUpgradeable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataUpgradeable{IERC20MetadataUpgradeableCaller: IERC20MetadataUpgradeableCaller{contract: contract}, IERC20MetadataUpgradeableTransactor: IERC20MetadataUpgradeableTransactor{contract: contract}, IERC20MetadataUpgradeableFilterer: IERC20MetadataUpgradeableFilterer{contract: contract}}, nil
}

// NewIERC20MetadataUpgradeableCaller creates a new read-only instance of IERC20MetadataUpgradeable, bound to a specific deployed contract.
func NewIERC20MetadataUpgradeableCaller(address common.Address, caller bind.ContractCaller) (*IERC20MetadataUpgradeableCaller, error) {
	contract, err := bindIERC20MetadataUpgradeable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataUpgradeableCaller{contract: contract}, nil
}

// NewIERC20MetadataUpgradeableTransactor creates a new write-only instance of IERC20MetadataUpgradeable, bound to a specific deployed contract.
func NewIERC20MetadataUpgradeableTransactor(address common.Address, transactor bind.ContractTransactor) (*IERC20MetadataUpgradeableTransactor, error) {
	contract, err := bindIERC20MetadataUpgradeable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataUpgradeableTransactor{contract: contract}, nil
}

// NewIERC20MetadataUpgradeableFilterer creates a new log filterer instance of IERC20MetadataUpgradeable, bound to a specific deployed contract.
func NewIERC20MetadataUpgradeableFilterer(address common.Address, filterer bind.ContractFilterer) (*IERC20MetadataUpgradeableFilterer, error) {
	contract, err := bindIERC20MetadataUpgradeable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataUpgradeableFilterer{contract: contract}, nil
}

// bindIERC20MetadataUpgradeable binds a generic wrapper to an already deployed contract.
func bindIERC20MetadataUpgradeable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IERC20MetadataUpgradeableABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20MetadataUpgradeable.Contract.IERC20MetadataUpgradeableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20MetadataUpgradeable.Contract.IERC20MetadataUpgradeableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20MetadataUpgradeable.Contract.IERC20MetadataUpgradeableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20MetadataUpgradeable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20MetadataUpgradeable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20MetadataUpgradeable.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableCaller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20MetadataUpgradeable.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20MetadataUpgradeable.Contract.Allowance(&_IERC20MetadataUpgradeable.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableCallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20MetadataUpgradeable.Contract.Allowance(&_IERC20MetadataUpgradeable.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableCaller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20MetadataUpgradeable.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20MetadataUpgradeable.Contract.BalanceOf(&_IERC20MetadataUpgradeable.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableCallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20MetadataUpgradeable.Contract.BalanceOf(&_IERC20MetadataUpgradeable.CallOpts, account)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableCaller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _IERC20MetadataUpgradeable.contract.Call(opts, &out, "decimals")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableSession) Decimals() (uint8, error) {
	return _IERC20MetadataUpgradeable.Contract.Decimals(&_IERC20MetadataUpgradeable.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableCallerSession) Decimals() (uint8, error) {
	return _IERC20MetadataUpgradeable.Contract.Decimals(&_IERC20MetadataUpgradeable.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableCaller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _IERC20MetadataUpgradeable.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableSession) Name() (string, error) {
	return _IERC20MetadataUpgradeable.Contract.Name(&_IERC20MetadataUpgradeable.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableCallerSession) Name() (string, error) {
	return _IERC20MetadataUpgradeable.Contract.Name(&_IERC20MetadataUpgradeable.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _IERC20MetadataUpgradeable.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableSession) Symbol() (string, error) {
	return _IERC20MetadataUpgradeable.Contract.Symbol(&_IERC20MetadataUpgradeable.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableCallerSession) Symbol() (string, error) {
	return _IERC20MetadataUpgradeable.Contract.Symbol(&_IERC20MetadataUpgradeable.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IERC20MetadataUpgradeable.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableSession) TotalSupply() (*big.Int, error) {
	return _IERC20MetadataUpgradeable.Contract.TotalSupply(&_IERC20MetadataUpgradeable.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableCallerSession) TotalSupply() (*big.Int, error) {
	return _IERC20MetadataUpgradeable.Contract.TotalSupply(&_IERC20MetadataUpgradeable.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableTransactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20MetadataUpgradeable.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20MetadataUpgradeable.Contract.Approve(&_IERC20MetadataUpgradeable.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableTransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20MetadataUpgradeable.Contract.Approve(&_IERC20MetadataUpgradeable.TransactOpts, spender, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableTransactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20MetadataUpgradeable.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20MetadataUpgradeable.Contract.Transfer(&_IERC20MetadataUpgradeable.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableTransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20MetadataUpgradeable.Contract.Transfer(&_IERC20MetadataUpgradeable.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20MetadataUpgradeable.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20MetadataUpgradeable.Contract.TransferFrom(&_IERC20MetadataUpgradeable.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableTransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20MetadataUpgradeable.Contract.TransferFrom(&_IERC20MetadataUpgradeable.TransactOpts, from, to, amount)
}

// IERC20MetadataUpgradeableApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the IERC20MetadataUpgradeable contract.
type IERC20MetadataUpgradeableApprovalIterator struct {
	Event *IERC20MetadataUpgradeableApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20MetadataUpgradeableApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20MetadataUpgradeableApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20MetadataUpgradeableApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20MetadataUpgradeableApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20MetadataUpgradeableApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20MetadataUpgradeableApproval represents a Approval event raised by the IERC20MetadataUpgradeable contract.
type IERC20MetadataUpgradeableApproval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*IERC20MetadataUpgradeableApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20MetadataUpgradeable.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataUpgradeableApprovalIterator{contract: _IERC20MetadataUpgradeable.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *IERC20MetadataUpgradeableApproval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20MetadataUpgradeable.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20MetadataUpgradeableApproval)
				if err := _IERC20MetadataUpgradeable.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableFilterer) ParseApproval(log types.Log) (*IERC20MetadataUpgradeableApproval, error) {
	event := new(IERC20MetadataUpgradeableApproval)
	if err := _IERC20MetadataUpgradeable.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20MetadataUpgradeableTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the IERC20MetadataUpgradeable contract.
type IERC20MetadataUpgradeableTransferIterator struct {
	Event *IERC20MetadataUpgradeableTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20MetadataUpgradeableTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20MetadataUpgradeableTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20MetadataUpgradeableTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20MetadataUpgradeableTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20MetadataUpgradeableTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20MetadataUpgradeableTransfer represents a Transfer event raised by the IERC20MetadataUpgradeable contract.
type IERC20MetadataUpgradeableTransfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*IERC20MetadataUpgradeableTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20MetadataUpgradeable.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IERC20MetadataUpgradeableTransferIterator{contract: _IERC20MetadataUpgradeable.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *IERC20MetadataUpgradeableTransfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20MetadataUpgradeable.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20MetadataUpgradeableTransfer)
				if err := _IERC20MetadataUpgradeable.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20MetadataUpgradeable *IERC20MetadataUpgradeableFilterer) ParseTransfer(log types.Log) (*IERC20MetadataUpgradeableTransfer, error) {
	event := new(IERC20MetadataUpgradeableTransfer)
	if err := _IERC20MetadataUpgradeable.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20PermitMetaData contains all meta data concerning the IERC20Permit contract.
var IERC20PermitMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"3644e515": "DOMAIN_SEPARATOR()",
		"7ecebe00": "nonces(address)",
		"d505accf": "permit(address,address,uint256,uint256,uint8,bytes32,bytes32)",
	},
}

// IERC20PermitABI is the input ABI used to generate the binding from.
// Deprecated: Use IERC20PermitMetaData.ABI instead.
var IERC20PermitABI = IERC20PermitMetaData.ABI

// Deprecated: Use IERC20PermitMetaData.Sigs instead.
// IERC20PermitFuncSigs maps the 4-byte function signature to its string representation.
var IERC20PermitFuncSigs = IERC20PermitMetaData.Sigs

// IERC20Permit is an auto generated Go binding around an Ethereum contract.
type IERC20Permit struct {
	IERC20PermitCaller     // Read-only binding to the contract
	IERC20PermitTransactor // Write-only binding to the contract
	IERC20PermitFilterer   // Log filterer for contract events
}

// IERC20PermitCaller is an auto generated read-only Go binding around an Ethereum contract.
type IERC20PermitCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20PermitTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IERC20PermitTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20PermitFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IERC20PermitFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20PermitSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IERC20PermitSession struct {
	Contract     *IERC20Permit     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20PermitCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IERC20PermitCallerSession struct {
	Contract *IERC20PermitCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// IERC20PermitTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IERC20PermitTransactorSession struct {
	Contract     *IERC20PermitTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// IERC20PermitRaw is an auto generated low-level Go binding around an Ethereum contract.
type IERC20PermitRaw struct {
	Contract *IERC20Permit // Generic contract binding to access the raw methods on
}

// IERC20PermitCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IERC20PermitCallerRaw struct {
	Contract *IERC20PermitCaller // Generic read-only contract binding to access the raw methods on
}

// IERC20PermitTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IERC20PermitTransactorRaw struct {
	Contract *IERC20PermitTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC20Permit creates a new instance of IERC20Permit, bound to a specific deployed contract.
func NewIERC20Permit(address common.Address, backend bind.ContractBackend) (*IERC20Permit, error) {
	contract, err := bindIERC20Permit(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC20Permit{IERC20PermitCaller: IERC20PermitCaller{contract: contract}, IERC20PermitTransactor: IERC20PermitTransactor{contract: contract}, IERC20PermitFilterer: IERC20PermitFilterer{contract: contract}}, nil
}

// NewIERC20PermitCaller creates a new read-only instance of IERC20Permit, bound to a specific deployed contract.
func NewIERC20PermitCaller(address common.Address, caller bind.ContractCaller) (*IERC20PermitCaller, error) {
	contract, err := bindIERC20Permit(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20PermitCaller{contract: contract}, nil
}

// NewIERC20PermitTransactor creates a new write-only instance of IERC20Permit, bound to a specific deployed contract.
func NewIERC20PermitTransactor(address common.Address, transactor bind.ContractTransactor) (*IERC20PermitTransactor, error) {
	contract, err := bindIERC20Permit(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20PermitTransactor{contract: contract}, nil
}

// NewIERC20PermitFilterer creates a new log filterer instance of IERC20Permit, bound to a specific deployed contract.
func NewIERC20PermitFilterer(address common.Address, filterer bind.ContractFilterer) (*IERC20PermitFilterer, error) {
	contract, err := bindIERC20Permit(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC20PermitFilterer{contract: contract}, nil
}

// bindIERC20Permit binds a generic wrapper to an already deployed contract.
func bindIERC20Permit(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IERC20PermitABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Permit *IERC20PermitRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20Permit.Contract.IERC20PermitCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Permit *IERC20PermitRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Permit.Contract.IERC20PermitTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Permit *IERC20PermitRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Permit.Contract.IERC20PermitTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Permit *IERC20PermitCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20Permit.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Permit *IERC20PermitTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Permit.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Permit *IERC20PermitTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Permit.Contract.contract.Transact(opts, method, params...)
}

// DOMAINSEPARATOR is a free data retrieval call binding the contract method 0x3644e515.
//
// Solidity: function DOMAIN_SEPARATOR() view returns(bytes32)
func (_IERC20Permit *IERC20PermitCaller) DOMAINSEPARATOR(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _IERC20Permit.contract.Call(opts, &out, "DOMAIN_SEPARATOR")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// DOMAINSEPARATOR is a free data retrieval call binding the contract method 0x3644e515.
//
// Solidity: function DOMAIN_SEPARATOR() view returns(bytes32)
func (_IERC20Permit *IERC20PermitSession) DOMAINSEPARATOR() ([32]byte, error) {
	return _IERC20Permit.Contract.DOMAINSEPARATOR(&_IERC20Permit.CallOpts)
}

// DOMAINSEPARATOR is a free data retrieval call binding the contract method 0x3644e515.
//
// Solidity: function DOMAIN_SEPARATOR() view returns(bytes32)
func (_IERC20Permit *IERC20PermitCallerSession) DOMAINSEPARATOR() ([32]byte, error) {
	return _IERC20Permit.Contract.DOMAINSEPARATOR(&_IERC20Permit.CallOpts)
}

// Nonces is a free data retrieval call binding the contract method 0x7ecebe00.
//
// Solidity: function nonces(address owner) view returns(uint256)
func (_IERC20Permit *IERC20PermitCaller) Nonces(opts *bind.CallOpts, owner common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Permit.contract.Call(opts, &out, "nonces", owner)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Nonces is a free data retrieval call binding the contract method 0x7ecebe00.
//
// Solidity: function nonces(address owner) view returns(uint256)
func (_IERC20Permit *IERC20PermitSession) Nonces(owner common.Address) (*big.Int, error) {
	return _IERC20Permit.Contract.Nonces(&_IERC20Permit.CallOpts, owner)
}

// Nonces is a free data retrieval call binding the contract method 0x7ecebe00.
//
// Solidity: function nonces(address owner) view returns(uint256)
func (_IERC20Permit *IERC20PermitCallerSession) Nonces(owner common.Address) (*big.Int, error) {
	return _IERC20Permit.Contract.Nonces(&_IERC20Permit.CallOpts, owner)
}

// Permit is a paid mutator transaction binding the contract method 0xd505accf.
//
// Solidity: function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) returns()
func (_IERC20Permit *IERC20PermitTransactor) Permit(opts *bind.TransactOpts, owner common.Address, spender common.Address, value *big.Int, deadline *big.Int, v uint8, r [32]byte, s [32]byte) (*types.Transaction, error) {
	return _IERC20Permit.contract.Transact(opts, "permit", owner, spender, value, deadline, v, r, s)
}

// Permit is a paid mutator transaction binding the contract method 0xd505accf.
//
// Solidity: function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) returns()
func (_IERC20Permit *IERC20PermitSession) Permit(owner common.Address, spender common.Address, value *big.Int, deadline *big.Int, v uint8, r [32]byte, s [32]byte) (*types.Transaction, error) {
	return _IERC20Permit.Contract.Permit(&_IERC20Permit.TransactOpts, owner, spender, value, deadline, v, r, s)
}

// Permit is a paid mutator transaction binding the contract method 0xd505accf.
//
// Solidity: function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) returns()
func (_IERC20Permit *IERC20PermitTransactorSession) Permit(owner common.Address, spender common.Address, value *big.Int, deadline *big.Int, v uint8, r [32]byte, s [32]byte) (*types.Transaction, error) {
	return _IERC20Permit.Contract.Permit(&_IERC20Permit.TransactOpts, owner, spender, value, deadline, v, r, s)
}

// IERC20UpgradeableMetaData contains all meta data concerning the IERC20Upgradeable contract.
var IERC20UpgradeableMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"dd62ed3e": "allowance(address,address)",
		"095ea7b3": "approve(address,uint256)",
		"70a08231": "balanceOf(address)",
		"18160ddd": "totalSupply()",
		"a9059cbb": "transfer(address,uint256)",
		"23b872dd": "transferFrom(address,address,uint256)",
	},
}

// IERC20UpgradeableABI is the input ABI used to generate the binding from.
// Deprecated: Use IERC20UpgradeableMetaData.ABI instead.
var IERC20UpgradeableABI = IERC20UpgradeableMetaData.ABI

// Deprecated: Use IERC20UpgradeableMetaData.Sigs instead.
// IERC20UpgradeableFuncSigs maps the 4-byte function signature to its string representation.
var IERC20UpgradeableFuncSigs = IERC20UpgradeableMetaData.Sigs

// IERC20Upgradeable is an auto generated Go binding around an Ethereum contract.
type IERC20Upgradeable struct {
	IERC20UpgradeableCaller     // Read-only binding to the contract
	IERC20UpgradeableTransactor // Write-only binding to the contract
	IERC20UpgradeableFilterer   // Log filterer for contract events
}

// IERC20UpgradeableCaller is an auto generated read-only Go binding around an Ethereum contract.
type IERC20UpgradeableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20UpgradeableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IERC20UpgradeableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20UpgradeableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IERC20UpgradeableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20UpgradeableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IERC20UpgradeableSession struct {
	Contract     *IERC20Upgradeable // Generic contract binding to set the session for
	CallOpts     bind.CallOpts      // Call options to use throughout this session
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// IERC20UpgradeableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IERC20UpgradeableCallerSession struct {
	Contract *IERC20UpgradeableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts            // Call options to use throughout this session
}

// IERC20UpgradeableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IERC20UpgradeableTransactorSession struct {
	Contract     *IERC20UpgradeableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts            // Transaction auth options to use throughout this session
}

// IERC20UpgradeableRaw is an auto generated low-level Go binding around an Ethereum contract.
type IERC20UpgradeableRaw struct {
	Contract *IERC20Upgradeable // Generic contract binding to access the raw methods on
}

// IERC20UpgradeableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IERC20UpgradeableCallerRaw struct {
	Contract *IERC20UpgradeableCaller // Generic read-only contract binding to access the raw methods on
}

// IERC20UpgradeableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IERC20UpgradeableTransactorRaw struct {
	Contract *IERC20UpgradeableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC20Upgradeable creates a new instance of IERC20Upgradeable, bound to a specific deployed contract.
func NewIERC20Upgradeable(address common.Address, backend bind.ContractBackend) (*IERC20Upgradeable, error) {
	contract, err := bindIERC20Upgradeable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC20Upgradeable{IERC20UpgradeableCaller: IERC20UpgradeableCaller{contract: contract}, IERC20UpgradeableTransactor: IERC20UpgradeableTransactor{contract: contract}, IERC20UpgradeableFilterer: IERC20UpgradeableFilterer{contract: contract}}, nil
}

// NewIERC20UpgradeableCaller creates a new read-only instance of IERC20Upgradeable, bound to a specific deployed contract.
func NewIERC20UpgradeableCaller(address common.Address, caller bind.ContractCaller) (*IERC20UpgradeableCaller, error) {
	contract, err := bindIERC20Upgradeable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20UpgradeableCaller{contract: contract}, nil
}

// NewIERC20UpgradeableTransactor creates a new write-only instance of IERC20Upgradeable, bound to a specific deployed contract.
func NewIERC20UpgradeableTransactor(address common.Address, transactor bind.ContractTransactor) (*IERC20UpgradeableTransactor, error) {
	contract, err := bindIERC20Upgradeable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20UpgradeableTransactor{contract: contract}, nil
}

// NewIERC20UpgradeableFilterer creates a new log filterer instance of IERC20Upgradeable, bound to a specific deployed contract.
func NewIERC20UpgradeableFilterer(address common.Address, filterer bind.ContractFilterer) (*IERC20UpgradeableFilterer, error) {
	contract, err := bindIERC20Upgradeable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC20UpgradeableFilterer{contract: contract}, nil
}

// bindIERC20Upgradeable binds a generic wrapper to an already deployed contract.
func bindIERC20Upgradeable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IERC20UpgradeableABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Upgradeable *IERC20UpgradeableRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20Upgradeable.Contract.IERC20UpgradeableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Upgradeable *IERC20UpgradeableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Upgradeable.Contract.IERC20UpgradeableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Upgradeable *IERC20UpgradeableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Upgradeable.Contract.IERC20UpgradeableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Upgradeable *IERC20UpgradeableCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20Upgradeable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Upgradeable *IERC20UpgradeableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Upgradeable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Upgradeable *IERC20UpgradeableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Upgradeable.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20Upgradeable *IERC20UpgradeableCaller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Upgradeable.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20Upgradeable *IERC20UpgradeableSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20Upgradeable.Contract.Allowance(&_IERC20Upgradeable.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_IERC20Upgradeable *IERC20UpgradeableCallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _IERC20Upgradeable.Contract.Allowance(&_IERC20Upgradeable.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20Upgradeable *IERC20UpgradeableCaller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Upgradeable.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20Upgradeable *IERC20UpgradeableSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20Upgradeable.Contract.BalanceOf(&_IERC20Upgradeable.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_IERC20Upgradeable *IERC20UpgradeableCallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _IERC20Upgradeable.Contract.BalanceOf(&_IERC20Upgradeable.CallOpts, account)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20Upgradeable *IERC20UpgradeableCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Upgradeable.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20Upgradeable *IERC20UpgradeableSession) TotalSupply() (*big.Int, error) {
	return _IERC20Upgradeable.Contract.TotalSupply(&_IERC20Upgradeable.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_IERC20Upgradeable *IERC20UpgradeableCallerSession) TotalSupply() (*big.Int, error) {
	return _IERC20Upgradeable.Contract.TotalSupply(&_IERC20Upgradeable.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20Upgradeable *IERC20UpgradeableTransactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Upgradeable.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20Upgradeable *IERC20UpgradeableSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Upgradeable.Contract.Approve(&_IERC20Upgradeable.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_IERC20Upgradeable *IERC20UpgradeableTransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Upgradeable.Contract.Approve(&_IERC20Upgradeable.TransactOpts, spender, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20Upgradeable *IERC20UpgradeableTransactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Upgradeable.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20Upgradeable *IERC20UpgradeableSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Upgradeable.Contract.Transfer(&_IERC20Upgradeable.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_IERC20Upgradeable *IERC20UpgradeableTransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Upgradeable.Contract.Transfer(&_IERC20Upgradeable.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20Upgradeable *IERC20UpgradeableTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Upgradeable.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20Upgradeable *IERC20UpgradeableSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Upgradeable.Contract.TransferFrom(&_IERC20Upgradeable.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_IERC20Upgradeable *IERC20UpgradeableTransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Upgradeable.Contract.TransferFrom(&_IERC20Upgradeable.TransactOpts, from, to, amount)
}

// IERC20UpgradeableApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the IERC20Upgradeable contract.
type IERC20UpgradeableApprovalIterator struct {
	Event *IERC20UpgradeableApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20UpgradeableApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20UpgradeableApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20UpgradeableApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20UpgradeableApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20UpgradeableApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20UpgradeableApproval represents a Approval event raised by the IERC20Upgradeable contract.
type IERC20UpgradeableApproval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20Upgradeable *IERC20UpgradeableFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*IERC20UpgradeableApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20Upgradeable.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &IERC20UpgradeableApprovalIterator{contract: _IERC20Upgradeable.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20Upgradeable *IERC20UpgradeableFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *IERC20UpgradeableApproval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _IERC20Upgradeable.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20UpgradeableApproval)
				if err := _IERC20Upgradeable.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_IERC20Upgradeable *IERC20UpgradeableFilterer) ParseApproval(log types.Log) (*IERC20UpgradeableApproval, error) {
	event := new(IERC20UpgradeableApproval)
	if err := _IERC20Upgradeable.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20UpgradeableTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the IERC20Upgradeable contract.
type IERC20UpgradeableTransferIterator struct {
	Event *IERC20UpgradeableTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20UpgradeableTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20UpgradeableTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20UpgradeableTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20UpgradeableTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20UpgradeableTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20UpgradeableTransfer represents a Transfer event raised by the IERC20Upgradeable contract.
type IERC20UpgradeableTransfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20Upgradeable *IERC20UpgradeableFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*IERC20UpgradeableTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20Upgradeable.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IERC20UpgradeableTransferIterator{contract: _IERC20Upgradeable.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20Upgradeable *IERC20UpgradeableFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *IERC20UpgradeableTransfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20Upgradeable.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20UpgradeableTransfer)
				if err := _IERC20Upgradeable.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_IERC20Upgradeable *IERC20UpgradeableFilterer) ParseTransfer(log types.Log) (*IERC20UpgradeableTransfer, error) {
	event := new(IERC20UpgradeableTransfer)
	if err := _IERC20Upgradeable.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IMpcManagerMetaData contains all meta data concerning the IMpcManager contract.
var IMpcManagerMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"publicKeys\",\"type\":\"bytes[]\"},{\"internalType\":\"uint8\",\"name\":\"threshold\",\"type\":\"uint8\"}],\"name\":\"createGroup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"groupId\",\"type\":\"bytes32\"}],\"name\":\"getGroup\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"participants\",\"type\":\"bytes[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"publicKey\",\"type\":\"bytes\"}],\"name\":\"getGroupIdByKey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"groupId\",\"type\":\"bytes32\"}],\"name\":\"requestKeygen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"nodeID\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"requestStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"7612e8a2": "createGroup(bytes[],uint8)",
		"b567d4ba": "getGroup(bytes32)",
		"6962ef6a": "getGroupIdByKey(bytes)",
		"e661d90d": "requestKeygen(bytes32)",
		"89060b34": "requestStake(string,uint256,uint256,uint256)",
	},
}

// IMpcManagerABI is the input ABI used to generate the binding from.
// Deprecated: Use IMpcManagerMetaData.ABI instead.
var IMpcManagerABI = IMpcManagerMetaData.ABI

// Deprecated: Use IMpcManagerMetaData.Sigs instead.
// IMpcManagerFuncSigs maps the 4-byte function signature to its string representation.
var IMpcManagerFuncSigs = IMpcManagerMetaData.Sigs

// IMpcManager is an auto generated Go binding around an Ethereum contract.
type IMpcManager struct {
	IMpcManagerCaller     // Read-only binding to the contract
	IMpcManagerTransactor // Write-only binding to the contract
	IMpcManagerFilterer   // Log filterer for contract events
}

// IMpcManagerCaller is an auto generated read-only Go binding around an Ethereum contract.
type IMpcManagerCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IMpcManagerTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IMpcManagerTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IMpcManagerFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IMpcManagerFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IMpcManagerSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IMpcManagerSession struct {
	Contract     *IMpcManager      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IMpcManagerCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IMpcManagerCallerSession struct {
	Contract *IMpcManagerCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// IMpcManagerTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IMpcManagerTransactorSession struct {
	Contract     *IMpcManagerTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// IMpcManagerRaw is an auto generated low-level Go binding around an Ethereum contract.
type IMpcManagerRaw struct {
	Contract *IMpcManager // Generic contract binding to access the raw methods on
}

// IMpcManagerCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IMpcManagerCallerRaw struct {
	Contract *IMpcManagerCaller // Generic read-only contract binding to access the raw methods on
}

// IMpcManagerTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IMpcManagerTransactorRaw struct {
	Contract *IMpcManagerTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIMpcManager creates a new instance of IMpcManager, bound to a specific deployed contract.
func NewIMpcManager(address common.Address, backend bind.ContractBackend) (*IMpcManager, error) {
	contract, err := bindIMpcManager(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IMpcManager{IMpcManagerCaller: IMpcManagerCaller{contract: contract}, IMpcManagerTransactor: IMpcManagerTransactor{contract: contract}, IMpcManagerFilterer: IMpcManagerFilterer{contract: contract}}, nil
}

// NewIMpcManagerCaller creates a new read-only instance of IMpcManager, bound to a specific deployed contract.
func NewIMpcManagerCaller(address common.Address, caller bind.ContractCaller) (*IMpcManagerCaller, error) {
	contract, err := bindIMpcManager(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IMpcManagerCaller{contract: contract}, nil
}

// NewIMpcManagerTransactor creates a new write-only instance of IMpcManager, bound to a specific deployed contract.
func NewIMpcManagerTransactor(address common.Address, transactor bind.ContractTransactor) (*IMpcManagerTransactor, error) {
	contract, err := bindIMpcManager(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IMpcManagerTransactor{contract: contract}, nil
}

// NewIMpcManagerFilterer creates a new log filterer instance of IMpcManager, bound to a specific deployed contract.
func NewIMpcManagerFilterer(address common.Address, filterer bind.ContractFilterer) (*IMpcManagerFilterer, error) {
	contract, err := bindIMpcManager(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IMpcManagerFilterer{contract: contract}, nil
}

// bindIMpcManager binds a generic wrapper to an already deployed contract.
func bindIMpcManager(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IMpcManagerABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IMpcManager *IMpcManagerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IMpcManager.Contract.IMpcManagerCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IMpcManager *IMpcManagerRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IMpcManager.Contract.IMpcManagerTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IMpcManager *IMpcManagerRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IMpcManager.Contract.IMpcManagerTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IMpcManager *IMpcManagerCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IMpcManager.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IMpcManager *IMpcManagerTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IMpcManager.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IMpcManager *IMpcManagerTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IMpcManager.Contract.contract.Transact(opts, method, params...)
}

// GetGroup is a free data retrieval call binding the contract method 0xb567d4ba.
//
// Solidity: function getGroup(bytes32 groupId) view returns(bytes[] participants)
func (_IMpcManager *IMpcManagerCaller) GetGroup(opts *bind.CallOpts, groupId [32]byte) ([][]byte, error) {
	var out []interface{}
	err := _IMpcManager.contract.Call(opts, &out, "getGroup", groupId)

	if err != nil {
		return *new([][]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([][]byte)).(*[][]byte)

	return out0, err

}

// GetGroup is a free data retrieval call binding the contract method 0xb567d4ba.
//
// Solidity: function getGroup(bytes32 groupId) view returns(bytes[] participants)
func (_IMpcManager *IMpcManagerSession) GetGroup(groupId [32]byte) ([][]byte, error) {
	return _IMpcManager.Contract.GetGroup(&_IMpcManager.CallOpts, groupId)
}

// GetGroup is a free data retrieval call binding the contract method 0xb567d4ba.
//
// Solidity: function getGroup(bytes32 groupId) view returns(bytes[] participants)
func (_IMpcManager *IMpcManagerCallerSession) GetGroup(groupId [32]byte) ([][]byte, error) {
	return _IMpcManager.Contract.GetGroup(&_IMpcManager.CallOpts, groupId)
}

// GetGroupIdByKey is a free data retrieval call binding the contract method 0x6962ef6a.
//
// Solidity: function getGroupIdByKey(bytes publicKey) view returns(bytes32)
func (_IMpcManager *IMpcManagerCaller) GetGroupIdByKey(opts *bind.CallOpts, publicKey []byte) ([32]byte, error) {
	var out []interface{}
	err := _IMpcManager.contract.Call(opts, &out, "getGroupIdByKey", publicKey)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetGroupIdByKey is a free data retrieval call binding the contract method 0x6962ef6a.
//
// Solidity: function getGroupIdByKey(bytes publicKey) view returns(bytes32)
func (_IMpcManager *IMpcManagerSession) GetGroupIdByKey(publicKey []byte) ([32]byte, error) {
	return _IMpcManager.Contract.GetGroupIdByKey(&_IMpcManager.CallOpts, publicKey)
}

// GetGroupIdByKey is a free data retrieval call binding the contract method 0x6962ef6a.
//
// Solidity: function getGroupIdByKey(bytes publicKey) view returns(bytes32)
func (_IMpcManager *IMpcManagerCallerSession) GetGroupIdByKey(publicKey []byte) ([32]byte, error) {
	return _IMpcManager.Contract.GetGroupIdByKey(&_IMpcManager.CallOpts, publicKey)
}

// CreateGroup is a paid mutator transaction binding the contract method 0x7612e8a2.
//
// Solidity: function createGroup(bytes[] publicKeys, uint8 threshold) returns()
func (_IMpcManager *IMpcManagerTransactor) CreateGroup(opts *bind.TransactOpts, publicKeys [][]byte, threshold uint8) (*types.Transaction, error) {
	return _IMpcManager.contract.Transact(opts, "createGroup", publicKeys, threshold)
}

// CreateGroup is a paid mutator transaction binding the contract method 0x7612e8a2.
//
// Solidity: function createGroup(bytes[] publicKeys, uint8 threshold) returns()
func (_IMpcManager *IMpcManagerSession) CreateGroup(publicKeys [][]byte, threshold uint8) (*types.Transaction, error) {
	return _IMpcManager.Contract.CreateGroup(&_IMpcManager.TransactOpts, publicKeys, threshold)
}

// CreateGroup is a paid mutator transaction binding the contract method 0x7612e8a2.
//
// Solidity: function createGroup(bytes[] publicKeys, uint8 threshold) returns()
func (_IMpcManager *IMpcManagerTransactorSession) CreateGroup(publicKeys [][]byte, threshold uint8) (*types.Transaction, error) {
	return _IMpcManager.Contract.CreateGroup(&_IMpcManager.TransactOpts, publicKeys, threshold)
}

// RequestKeygen is a paid mutator transaction binding the contract method 0xe661d90d.
//
// Solidity: function requestKeygen(bytes32 groupId) returns()
func (_IMpcManager *IMpcManagerTransactor) RequestKeygen(opts *bind.TransactOpts, groupId [32]byte) (*types.Transaction, error) {
	return _IMpcManager.contract.Transact(opts, "requestKeygen", groupId)
}

// RequestKeygen is a paid mutator transaction binding the contract method 0xe661d90d.
//
// Solidity: function requestKeygen(bytes32 groupId) returns()
func (_IMpcManager *IMpcManagerSession) RequestKeygen(groupId [32]byte) (*types.Transaction, error) {
	return _IMpcManager.Contract.RequestKeygen(&_IMpcManager.TransactOpts, groupId)
}

// RequestKeygen is a paid mutator transaction binding the contract method 0xe661d90d.
//
// Solidity: function requestKeygen(bytes32 groupId) returns()
func (_IMpcManager *IMpcManagerTransactorSession) RequestKeygen(groupId [32]byte) (*types.Transaction, error) {
	return _IMpcManager.Contract.RequestKeygen(&_IMpcManager.TransactOpts, groupId)
}

// RequestStake is a paid mutator transaction binding the contract method 0x89060b34.
//
// Solidity: function requestStake(string nodeID, uint256 amount, uint256 startTime, uint256 endTime) payable returns()
func (_IMpcManager *IMpcManagerTransactor) RequestStake(opts *bind.TransactOpts, nodeID string, amount *big.Int, startTime *big.Int, endTime *big.Int) (*types.Transaction, error) {
	return _IMpcManager.contract.Transact(opts, "requestStake", nodeID, amount, startTime, endTime)
}

// RequestStake is a paid mutator transaction binding the contract method 0x89060b34.
//
// Solidity: function requestStake(string nodeID, uint256 amount, uint256 startTime, uint256 endTime) payable returns()
func (_IMpcManager *IMpcManagerSession) RequestStake(nodeID string, amount *big.Int, startTime *big.Int, endTime *big.Int) (*types.Transaction, error) {
	return _IMpcManager.Contract.RequestStake(&_IMpcManager.TransactOpts, nodeID, amount, startTime, endTime)
}

// RequestStake is a paid mutator transaction binding the contract method 0x89060b34.
//
// Solidity: function requestStake(string nodeID, uint256 amount, uint256 startTime, uint256 endTime) payable returns()
func (_IMpcManager *IMpcManagerTransactorSession) RequestStake(nodeID string, amount *big.Int, startTime *big.Int, endTime *big.Int) (*types.Transaction, error) {
	return _IMpcManager.Contract.RequestStake(&_IMpcManager.TransactOpts, nodeID, amount, startTime, endTime)
}

// ITreasuryMetaData contains all meta data concerning the ITreasury contract.
var ITreasuryMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"379607f5": "claim(uint256)",
	},
}

// ITreasuryABI is the input ABI used to generate the binding from.
// Deprecated: Use ITreasuryMetaData.ABI instead.
var ITreasuryABI = ITreasuryMetaData.ABI

// Deprecated: Use ITreasuryMetaData.Sigs instead.
// ITreasuryFuncSigs maps the 4-byte function signature to its string representation.
var ITreasuryFuncSigs = ITreasuryMetaData.Sigs

// ITreasury is an auto generated Go binding around an Ethereum contract.
type ITreasury struct {
	ITreasuryCaller     // Read-only binding to the contract
	ITreasuryTransactor // Write-only binding to the contract
	ITreasuryFilterer   // Log filterer for contract events
}

// ITreasuryCaller is an auto generated read-only Go binding around an Ethereum contract.
type ITreasuryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ITreasuryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ITreasuryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ITreasuryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ITreasuryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ITreasurySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ITreasurySession struct {
	Contract     *ITreasury        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ITreasuryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ITreasuryCallerSession struct {
	Contract *ITreasuryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// ITreasuryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ITreasuryTransactorSession struct {
	Contract     *ITreasuryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// ITreasuryRaw is an auto generated low-level Go binding around an Ethereum contract.
type ITreasuryRaw struct {
	Contract *ITreasury // Generic contract binding to access the raw methods on
}

// ITreasuryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ITreasuryCallerRaw struct {
	Contract *ITreasuryCaller // Generic read-only contract binding to access the raw methods on
}

// ITreasuryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ITreasuryTransactorRaw struct {
	Contract *ITreasuryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewITreasury creates a new instance of ITreasury, bound to a specific deployed contract.
func NewITreasury(address common.Address, backend bind.ContractBackend) (*ITreasury, error) {
	contract, err := bindITreasury(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ITreasury{ITreasuryCaller: ITreasuryCaller{contract: contract}, ITreasuryTransactor: ITreasuryTransactor{contract: contract}, ITreasuryFilterer: ITreasuryFilterer{contract: contract}}, nil
}

// NewITreasuryCaller creates a new read-only instance of ITreasury, bound to a specific deployed contract.
func NewITreasuryCaller(address common.Address, caller bind.ContractCaller) (*ITreasuryCaller, error) {
	contract, err := bindITreasury(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ITreasuryCaller{contract: contract}, nil
}

// NewITreasuryTransactor creates a new write-only instance of ITreasury, bound to a specific deployed contract.
func NewITreasuryTransactor(address common.Address, transactor bind.ContractTransactor) (*ITreasuryTransactor, error) {
	contract, err := bindITreasury(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ITreasuryTransactor{contract: contract}, nil
}

// NewITreasuryFilterer creates a new log filterer instance of ITreasury, bound to a specific deployed contract.
func NewITreasuryFilterer(address common.Address, filterer bind.ContractFilterer) (*ITreasuryFilterer, error) {
	contract, err := bindITreasury(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ITreasuryFilterer{contract: contract}, nil
}

// bindITreasury binds a generic wrapper to an already deployed contract.
func bindITreasury(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ITreasuryABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ITreasury *ITreasuryRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ITreasury.Contract.ITreasuryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ITreasury *ITreasuryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ITreasury.Contract.ITreasuryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ITreasury *ITreasuryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ITreasury.Contract.ITreasuryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ITreasury *ITreasuryCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ITreasury.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ITreasury *ITreasuryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ITreasury.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ITreasury *ITreasuryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ITreasury.Contract.contract.Transact(opts, method, params...)
}

// Claim is a paid mutator transaction binding the contract method 0x379607f5.
//
// Solidity: function claim(uint256 amount) returns()
func (_ITreasury *ITreasuryTransactor) Claim(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) {
	return _ITreasury.contract.Transact(opts, "claim", amount)
}

// Claim is a paid mutator transaction binding the contract method 0x379607f5.
//
// Solidity: function claim(uint256 amount) returns()
func (_ITreasury *ITreasurySession) Claim(amount *big.Int) (*types.Transaction, error) {
	return _ITreasury.Contract.Claim(&_ITreasury.TransactOpts, amount)
}

// Claim is a paid mutator transaction binding the contract method 0x379607f5.
//
// Solidity: function claim(uint256 amount) returns()
func (_ITreasury *ITreasuryTransactorSession) Claim(amount *big.Int) (*types.Transaction, error) {
	return _ITreasury.Contract.Claim(&_ITreasury.TransactOpts, amount)
}

// IValidatorSelectorMetaData contains all meta data concerning the IValidatorSelector contract.
var IValidatorSelectorMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"selectValidatorsForStake\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"6194697d": "selectValidatorsForStake(uint256)",
	},
}

// IValidatorSelectorABI is the input ABI used to generate the binding from.
// Deprecated: Use IValidatorSelectorMetaData.ABI instead.
var IValidatorSelectorABI = IValidatorSelectorMetaData.ABI

// Deprecated: Use IValidatorSelectorMetaData.Sigs instead.
// IValidatorSelectorFuncSigs maps the 4-byte function signature to its string representation.
var IValidatorSelectorFuncSigs = IValidatorSelectorMetaData.Sigs

// IValidatorSelector is an auto generated Go binding around an Ethereum contract.
type IValidatorSelector struct {
	IValidatorSelectorCaller     // Read-only binding to the contract
	IValidatorSelectorTransactor // Write-only binding to the contract
	IValidatorSelectorFilterer   // Log filterer for contract events
}

// IValidatorSelectorCaller is an auto generated read-only Go binding around an Ethereum contract.
type IValidatorSelectorCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IValidatorSelectorTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IValidatorSelectorTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IValidatorSelectorFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IValidatorSelectorFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IValidatorSelectorSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IValidatorSelectorSession struct {
	Contract     *IValidatorSelector // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// IValidatorSelectorCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IValidatorSelectorCallerSession struct {
	Contract *IValidatorSelectorCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// IValidatorSelectorTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IValidatorSelectorTransactorSession struct {
	Contract     *IValidatorSelectorTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// IValidatorSelectorRaw is an auto generated low-level Go binding around an Ethereum contract.
type IValidatorSelectorRaw struct {
	Contract *IValidatorSelector // Generic contract binding to access the raw methods on
}

// IValidatorSelectorCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IValidatorSelectorCallerRaw struct {
	Contract *IValidatorSelectorCaller // Generic read-only contract binding to access the raw methods on
}

// IValidatorSelectorTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IValidatorSelectorTransactorRaw struct {
	Contract *IValidatorSelectorTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIValidatorSelector creates a new instance of IValidatorSelector, bound to a specific deployed contract.
func NewIValidatorSelector(address common.Address, backend bind.ContractBackend) (*IValidatorSelector, error) {
	contract, err := bindIValidatorSelector(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IValidatorSelector{IValidatorSelectorCaller: IValidatorSelectorCaller{contract: contract}, IValidatorSelectorTransactor: IValidatorSelectorTransactor{contract: contract}, IValidatorSelectorFilterer: IValidatorSelectorFilterer{contract: contract}}, nil
}

// NewIValidatorSelectorCaller creates a new read-only instance of IValidatorSelector, bound to a specific deployed contract.
func NewIValidatorSelectorCaller(address common.Address, caller bind.ContractCaller) (*IValidatorSelectorCaller, error) {
	contract, err := bindIValidatorSelector(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IValidatorSelectorCaller{contract: contract}, nil
}

// NewIValidatorSelectorTransactor creates a new write-only instance of IValidatorSelector, bound to a specific deployed contract.
func NewIValidatorSelectorTransactor(address common.Address, transactor bind.ContractTransactor) (*IValidatorSelectorTransactor, error) {
	contract, err := bindIValidatorSelector(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IValidatorSelectorTransactor{contract: contract}, nil
}

// NewIValidatorSelectorFilterer creates a new log filterer instance of IValidatorSelector, bound to a specific deployed contract.
func NewIValidatorSelectorFilterer(address common.Address, filterer bind.ContractFilterer) (*IValidatorSelectorFilterer, error) {
	contract, err := bindIValidatorSelector(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IValidatorSelectorFilterer{contract: contract}, nil
}

// bindIValidatorSelector binds a generic wrapper to an already deployed contract.
func bindIValidatorSelector(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IValidatorSelectorABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IValidatorSelector *IValidatorSelectorRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IValidatorSelector.Contract.IValidatorSelectorCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IValidatorSelector *IValidatorSelectorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IValidatorSelector.Contract.IValidatorSelectorTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IValidatorSelector *IValidatorSelectorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IValidatorSelector.Contract.IValidatorSelectorTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IValidatorSelector *IValidatorSelectorCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IValidatorSelector.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IValidatorSelector *IValidatorSelectorTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IValidatorSelector.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IValidatorSelector *IValidatorSelectorTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IValidatorSelector.Contract.contract.Transact(opts, method, params...)
}

// SelectValidatorsForStake is a free data retrieval call binding the contract method 0x6194697d.
//
// Solidity: function selectValidatorsForStake(uint256 amount) view returns(string[], uint256[], uint256)
func (_IValidatorSelector *IValidatorSelectorCaller) SelectValidatorsForStake(opts *bind.CallOpts, amount *big.Int) ([]string, []*big.Int, *big.Int, error) {
	var out []interface{}
	err := _IValidatorSelector.contract.Call(opts, &out, "selectValidatorsForStake", amount)

	if err != nil {
		return *new([]string), *new([]*big.Int), *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new([]string)).(*[]string)
	out1 := *abi.ConvertType(out[1], new([]*big.Int)).(*[]*big.Int)
	out2 := *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)

	return out0, out1, out2, err

}

// SelectValidatorsForStake is a free data retrieval call binding the contract method 0x6194697d.
//
// Solidity: function selectValidatorsForStake(uint256 amount) view returns(string[], uint256[], uint256)
func (_IValidatorSelector *IValidatorSelectorSession) SelectValidatorsForStake(amount *big.Int) ([]string, []*big.Int, *big.Int, error) {
	return _IValidatorSelector.Contract.SelectValidatorsForStake(&_IValidatorSelector.CallOpts, amount)
}

// SelectValidatorsForStake is a free data retrieval call binding the contract method 0x6194697d.
//
// Solidity: function selectValidatorsForStake(uint256 amount) view returns(string[], uint256[], uint256)
func (_IValidatorSelector *IValidatorSelectorCallerSession) SelectValidatorsForStake(amount *big.Int) ([]string, []*big.Int, *big.Int, error) {
	return _IValidatorSelector.Contract.SelectValidatorsForStake(&_IValidatorSelector.CallOpts, amount)
}

// InitializableMetaData contains all meta data concerning the Initializable contract.
var InitializableMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"}]",
}

// InitializableABI is the input ABI used to generate the binding from.
// Deprecated: Use InitializableMetaData.ABI instead.
var InitializableABI = InitializableMetaData.ABI

// Initializable is an auto generated Go binding around an Ethereum contract.
type Initializable struct {
	InitializableCaller     // Read-only binding to the contract
	InitializableTransactor // Write-only binding to the contract
	InitializableFilterer   // Log filterer for contract events
}

// InitializableCaller is an auto generated read-only Go binding around an Ethereum contract.
type InitializableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// InitializableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type InitializableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// InitializableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type InitializableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// InitializableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type InitializableSession struct {
	Contract     *Initializable    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// InitializableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type InitializableCallerSession struct {
	Contract *InitializableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// InitializableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type InitializableTransactorSession struct {
	Contract     *InitializableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// InitializableRaw is an auto generated low-level Go binding around an Ethereum contract.
type InitializableRaw struct {
	Contract *Initializable // Generic contract binding to access the raw methods on
}

// InitializableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type InitializableCallerRaw struct {
	Contract *InitializableCaller // Generic read-only contract binding to access the raw methods on
}

// InitializableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type InitializableTransactorRaw struct {
	Contract *InitializableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewInitializable creates a new instance of Initializable, bound to a specific deployed contract.
func NewInitializable(address common.Address, backend bind.ContractBackend) (*Initializable, error) {
	contract, err := bindInitializable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Initializable{InitializableCaller: InitializableCaller{contract: contract}, InitializableTransactor: InitializableTransactor{contract: contract}, InitializableFilterer: InitializableFilterer{contract: contract}}, nil
}

// NewInitializableCaller creates a new read-only instance of Initializable, bound to a specific deployed contract.
func NewInitializableCaller(address common.Address, caller bind.ContractCaller) (*InitializableCaller, error) {
	contract, err := bindInitializable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &InitializableCaller{contract: contract}, nil
}

// NewInitializableTransactor creates a new write-only instance of Initializable, bound to a specific deployed contract.
func NewInitializableTransactor(address common.Address, transactor bind.ContractTransactor) (*InitializableTransactor, error) {
	contract, err := bindInitializable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &InitializableTransactor{contract: contract}, nil
}

// NewInitializableFilterer creates a new log filterer instance of Initializable, bound to a specific deployed contract.
func NewInitializableFilterer(address common.Address, filterer bind.ContractFilterer) (*InitializableFilterer, error) {
	contract, err := bindInitializable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &InitializableFilterer{contract: contract}, nil
}

// bindInitializable binds a generic wrapper to an already deployed contract.
func bindInitializable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(InitializableABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Initializable *InitializableRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Initializable.Contract.InitializableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Initializable *InitializableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Initializable.Contract.InitializableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Initializable *InitializableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Initializable.Contract.InitializableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Initializable *InitializableCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Initializable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Initializable *InitializableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Initializable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Initializable *InitializableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Initializable.Contract.contract.Transact(opts, method, params...)
}

// InitializableInitializedIterator is returned from FilterInitialized and is used to iterate over the raw logs and unpacked data for Initialized events raised by the Initializable contract.
type InitializableInitializedIterator struct {
	Event *InitializableInitialized // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *InitializableInitializedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(InitializableInitialized)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(InitializableInitialized)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *InitializableInitializedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *InitializableInitializedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// InitializableInitialized represents a Initialized event raised by the Initializable contract.
type InitializableInitialized struct {
	Version uint8
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInitialized is a free log retrieval operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_Initializable *InitializableFilterer) FilterInitialized(opts *bind.FilterOpts) (*InitializableInitializedIterator, error) {

	logs, sub, err := _Initializable.contract.FilterLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return &InitializableInitializedIterator{contract: _Initializable.contract, event: "Initialized", logs: logs, sub: sub}, nil
}

// WatchInitialized is a free log subscription operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_Initializable *InitializableFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *InitializableInitialized) (event.Subscription, error) {

	logs, sub, err := _Initializable.contract.WatchLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(InitializableInitialized)
				if err := _Initializable.contract.UnpackLog(event, "Initialized", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInitialized is a log parse operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_Initializable *InitializableFilterer) ParseInitialized(log types.Log) (*InitializableInitialized, error) {
	event := new(InitializableInitialized)
	if err := _Initializable.contract.UnpackLog(event, "Initialized", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MathMetaData contains all meta data concerning the Math contract.
var MathMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220f53006ada7460d156d219df947a97301416393f35dd580f6aba9044d24e40c5d64736f6c634300080a0033",
}

// MathABI is the input ABI used to generate the binding from.
// Deprecated: Use MathMetaData.ABI instead.
var MathABI = MathMetaData.ABI

// MathBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use MathMetaData.Bin instead.
var MathBin = MathMetaData.Bin

// DeployMath deploys a new Ethereum contract, binding an instance of Math to it.
func DeployMath(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Math, error) {
	parsed, err := MathMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(MathBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Math{MathCaller: MathCaller{contract: contract}, MathTransactor: MathTransactor{contract: contract}, MathFilterer: MathFilterer{contract: contract}}, nil
}

// Math is an auto generated Go binding around an Ethereum contract.
type Math struct {
	MathCaller     // Read-only binding to the contract
	MathTransactor // Write-only binding to the contract
	MathFilterer   // Log filterer for contract events
}

// MathCaller is an auto generated read-only Go binding around an Ethereum contract.
type MathCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MathTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MathTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MathFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MathFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MathSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MathSession struct {
	Contract     *Math             // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MathCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MathCallerSession struct {
	Contract *MathCaller   // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// MathTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MathTransactorSession struct {
	Contract     *MathTransactor   // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MathRaw is an auto generated low-level Go binding around an Ethereum contract.
type MathRaw struct {
	Contract *Math // Generic contract binding to access the raw methods on
}

// MathCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MathCallerRaw struct {
	Contract *MathCaller // Generic read-only contract binding to access the raw methods on
}

// MathTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MathTransactorRaw struct {
	Contract *MathTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMath creates a new instance of Math, bound to a specific deployed contract.
func NewMath(address common.Address, backend bind.ContractBackend) (*Math, error) {
	contract, err := bindMath(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Math{MathCaller: MathCaller{contract: contract}, MathTransactor: MathTransactor{contract: contract}, MathFilterer: MathFilterer{contract: contract}}, nil
}

// NewMathCaller creates a new read-only instance of Math, bound to a specific deployed contract.
func NewMathCaller(address common.Address, caller bind.ContractCaller) (*MathCaller, error) {
	contract, err := bindMath(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MathCaller{contract: contract}, nil
}

// NewMathTransactor creates a new write-only instance of Math, bound to a specific deployed contract.
func NewMathTransactor(address common.Address, transactor bind.ContractTransactor) (*MathTransactor, error) {
	contract, err := bindMath(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MathTransactor{contract: contract}, nil
}

// NewMathFilterer creates a new log filterer instance of Math, bound to a specific deployed contract.
func NewMathFilterer(address common.Address, filterer bind.ContractFilterer) (*MathFilterer, error) {
	contract, err := bindMath(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MathFilterer{contract: contract}, nil
}

// bindMath binds a generic wrapper to an already deployed contract.
func bindMath(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(MathABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Math *MathRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Math.Contract.MathCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Math *MathRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Math.Contract.MathTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Math *MathRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Math.Contract.MathTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Math *MathCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Math.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Math *MathTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Math.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Math *MathTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Math.Contract.contract.Transact(opts, method, params...)
}

// PausableMetaData contains all meta data concerning the Pausable contract.
var PausableMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"5c975abb": "paused()",
	},
}

// PausableABI is the input ABI used to generate the binding from.
// Deprecated: Use PausableMetaData.ABI instead.
var PausableABI = PausableMetaData.ABI

// Deprecated: Use PausableMetaData.Sigs instead.
// PausableFuncSigs maps the 4-byte function signature to its string representation.
var PausableFuncSigs = PausableMetaData.Sigs

// Pausable is an auto generated Go binding around an Ethereum contract.
type Pausable struct {
	PausableCaller     // Read-only binding to the contract
	PausableTransactor // Write-only binding to the contract
	PausableFilterer   // Log filterer for contract events
}

// PausableCaller is an auto generated read-only Go binding around an Ethereum contract.
type PausableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PausableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PausableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PausableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PausableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PausableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PausableSession struct {
	Contract     *Pausable         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PausableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PausableCallerSession struct {
	Contract *PausableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// PausableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PausableTransactorSession struct {
	Contract     *PausableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// PausableRaw is an auto generated low-level Go binding around an Ethereum contract.
type PausableRaw struct {
	Contract *Pausable // Generic contract binding to access the raw methods on
}

// PausableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PausableCallerRaw struct {
	Contract *PausableCaller // Generic read-only contract binding to access the raw methods on
}

// PausableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PausableTransactorRaw struct {
	Contract *PausableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPausable creates a new instance of Pausable, bound to a specific deployed contract.
func NewPausable(address common.Address, backend bind.ContractBackend) (*Pausable, error) {
	contract, err := bindPausable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Pausable{PausableCaller: PausableCaller{contract: contract}, PausableTransactor: PausableTransactor{contract: contract}, PausableFilterer: PausableFilterer{contract: contract}}, nil
}

// NewPausableCaller creates a new read-only instance of Pausable, bound to a specific deployed contract.
func NewPausableCaller(address common.Address, caller bind.ContractCaller) (*PausableCaller, error) {
	contract, err := bindPausable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PausableCaller{contract: contract}, nil
}

// NewPausableTransactor creates a new write-only instance of Pausable, bound to a specific deployed contract.
func NewPausableTransactor(address common.Address, transactor bind.ContractTransactor) (*PausableTransactor, error) {
	contract, err := bindPausable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PausableTransactor{contract: contract}, nil
}

// NewPausableFilterer creates a new log filterer instance of Pausable, bound to a specific deployed contract.
func NewPausableFilterer(address common.Address, filterer bind.ContractFilterer) (*PausableFilterer, error) {
	contract, err := bindPausable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PausableFilterer{contract: contract}, nil
}

// bindPausable binds a generic wrapper to an already deployed contract.
func bindPausable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(PausableABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Pausable *PausableRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Pausable.Contract.PausableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Pausable *PausableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pausable.Contract.PausableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Pausable *PausableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Pausable.Contract.PausableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Pausable *PausableCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Pausable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Pausable *PausableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Pausable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Pausable *PausableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Pausable.Contract.contract.Transact(opts, method, params...)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_Pausable *PausableCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _Pausable.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_Pausable *PausableSession) Paused() (bool, error) {
	return _Pausable.Contract.Paused(&_Pausable.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_Pausable *PausableCallerSession) Paused() (bool, error) {
	return _Pausable.Contract.Paused(&_Pausable.CallOpts)
}

// PausablePausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the Pausable contract.
type PausablePausedIterator struct {
	Event *PausablePaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PausablePausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PausablePaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PausablePaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PausablePausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PausablePausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PausablePaused represents a Paused event raised by the Pausable contract.
type PausablePaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_Pausable *PausableFilterer) FilterPaused(opts *bind.FilterOpts) (*PausablePausedIterator, error) {

	logs, sub, err := _Pausable.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &PausablePausedIterator{contract: _Pausable.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_Pausable *PausableFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *PausablePaused) (event.Subscription, error) {

	logs, sub, err := _Pausable.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PausablePaused)
				if err := _Pausable.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_Pausable *PausableFilterer) ParsePaused(log types.Log) (*PausablePaused, error) {
	event := new(PausablePaused)
	if err := _Pausable.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PausableUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the Pausable contract.
type PausableUnpausedIterator struct {
	Event *PausableUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PausableUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PausableUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PausableUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PausableUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PausableUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PausableUnpaused represents a Unpaused event raised by the Pausable contract.
type PausableUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_Pausable *PausableFilterer) FilterUnpaused(opts *bind.FilterOpts) (*PausableUnpausedIterator, error) {

	logs, sub, err := _Pausable.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &PausableUnpausedIterator{contract: _Pausable.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_Pausable *PausableFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *PausableUnpaused) (event.Subscription, error) {

	logs, sub, err := _Pausable.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PausableUnpaused)
				if err := _Pausable.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_Pausable *PausableFilterer) ParseUnpaused(log types.Log) (*PausableUnpaused, error) {
	event := new(PausableUnpaused)
	if err := _Pausable.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PayableAvaLidoMetaData contains all meta data concerning the PayableAvaLido contract.
var PayableAvaLidoMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"ClaimTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStakeAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoAvailableValidators\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProtocolStakedAmountTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooManyConcurrentUnstakeRequests\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"finalClaim\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestIndex\",\"type\":\"uint256\"}],\"name\":\"ClaimEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"DepositEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProtocolFeeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestIndex\",\"type\":\"uint256\"}],\"name\":\"RequestFullyFilledEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fillAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestIndex\",\"type\":\"uint256\"}],\"name\":\"RequestPartiallyFilledEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsCollectedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"avaxAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stAvaxAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestIndex\",\"type\":\"uint256\"}],\"name\":\"WithdrawRequestSubmittedEvent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountPendingAVAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountStakedAVAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalControlled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"avaxAmount\",\"type\":\"uint256\"}],\"name\":\"avaxToStAVAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimUnstakedPrincipals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateAVAXToStAVAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateStAVAXToAVAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lidoFeeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"authorFeeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"validatorSelectorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mpcManagerAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initiateStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxProtocolControlledAVAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxUnstakeRequests\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStakeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStakeBatchAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mpcManager\",\"outputs\":[{\"internalType\":\"contractIMpcManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"principalTreasury\",\"outputs\":[{\"internalType\":\"contractITreasury\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolControlledAVAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeeSplitter\",\"outputs\":[{\"internalType\":\"contractPaymentSplitter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestIndex\",\"type\":\"uint256\"}],\"name\":\"requestByIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"requestedAt\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"amountRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountFilled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stAVAXLocked\",\"type\":\"uint256\"}],\"internalType\":\"structUnstakeRequest\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stAVAXAmount\",\"type\":\"uint256\"}],\"name\":\"requestWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardTreasury\",\"outputs\":[{\"internalType\":\"contractITreasury\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxProtocolControlledAVAX\",\"type\":\"uint256\"}],\"name\":\"setMaxProtocolControlledAVAX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_maxUnstakeRequests\",\"type\":\"uint8\"}],\"name\":\"setMaxUnstakeRequests\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minStakeAmount\",\"type\":\"uint256\"}],\"name\":\"setMinStakeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minStakeBatchAmount\",\"type\":\"uint256\"}],\"name\":\"setMinStakeBatchAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setPrincipalTreasuryAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_protocolFeePercentage\",\"type\":\"uint256\"}],\"name\":\"setProtocolFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"paymentAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"paymentSplit\",\"type\":\"uint256[]\"}],\"name\":\"setProtocolFeeSplit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setRewardTreasuryAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakePeriod\",\"type\":\"uint256\"}],\"name\":\"setStakePeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalControlled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stAvaxAmount\",\"type\":\"uint256\"}],\"name\":\"stAVAXToAVAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"unstakeRequestCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unstakeRequests\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"requestedAt\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"amountRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountFilled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stAVAXLocked\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatorSelector\",\"outputs\":[{\"internalType\":\"contractIValidatorSelector\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
	Sigs: map[string]string{
		"a217fddf": "DEFAULT_ADMIN_ROLE()",
		"dd62ed3e": "allowance(address,address)",
		"7e1f1bfb": "amountPendingAVAX()",
		"873dfe34": "amountStakedAVAX()",
		"095ea7b3": "approve(address,uint256)",
		"85990de5": "avaxToStAVAX(uint256,uint256)",
		"70a08231": "balanceOf(address)",
		"c3490263": "claim(uint256,uint256)",
		"372500ab": "claimRewards()",
		"446ed20b": "claimUnstakedPrincipals()",
		"313ce567": "decimals()",
		"a457c2d7": "decreaseAllowance(address,uint256)",
		"d0e30db0": "deposit()",
		"9f94a9e3": "exchangeRateAVAXToStAVAX()",
		"67300041": "exchangeRateStAVAXToAVAX()",
		"248a9ca3": "getRoleAdmin(bytes32)",
		"9010d07c": "getRoleMember(bytes32,uint256)",
		"ca15c873": "getRoleMemberCount(bytes32)",
		"2f2ff15d": "grantRole(bytes32,address)",
		"91d14854": "hasRole(bytes32,address)",
		"39509351": "increaseAllowance(address,uint256)",
		"f8c8765e": "initialize(address,address,address,address)",
		"db4567d3": "initiateStake()",
		"53524303": "maxProtocolControlledAVAX()",
		"a7602c7e": "maxUnstakeRequests()",
		"f1887684": "minStakeAmount()",
		"ad1497fa": "minStakeBatchAmount()",
		"846b3c8b": "mpcManager()",
		"06fdde03": "name()",
		"8456cb59": "pause()",
		"5c975abb": "paused()",
		"1c0fc3f6": "principalTreasury()",
		"a23b4965": "protocolControlledAVAX()",
		"8e50e509": "protocolFeePercentage()",
		"9d7710a5": "protocolFeeSplitter()",
		"36568abe": "renounceRole(bytes32,address)",
		"3d3da6ef": "requestByIndex(uint256)",
		"9ee679e8": "requestWithdrawal(uint256)",
		"046f7da2": "resume()",
		"d547741f": "revokeRole(bytes32,address)",
		"c7c934a1": "rewardTreasury()",
		"818a8e4c": "setMaxProtocolControlledAVAX(uint256)",
		"1031eb9c": "setMaxUnstakeRequests(uint8)",
		"eb4af045": "setMinStakeAmount(uint256)",
		"262b1f9e": "setMinStakeBatchAmount(uint256)",
		"d1f8aaac": "setPrincipalTreasuryAddress(address)",
		"d8a5e936": "setProtocolFeePercentage(uint256)",
		"2659bc15": "setProtocolFeeSplit(address[],uint256[])",
		"cb1045d0": "setRewardTreasuryAddress(address)",
		"1e6b4c6f": "setStakePeriod(uint256)",
		"bc56684a": "stAVAXToAVAX(uint256,uint256)",
		"c1699a99": "stakePeriod()",
		"01ffc9a7": "supportsInterface(bytes4)",
		"95d89b41": "symbol()",
		"18160ddd": "totalSupply()",
		"a9059cbb": "transfer(address,uint256)",
		"23b872dd": "transferFrom(address,address,uint256)",
		"ad874808": "unstakeRequestCount(address)",
		"f87975af": "unstakeRequests(uint256)",
		"e039e3cc": "validatorSelector()",
	},
	Bin: "0x608060405234801561001057600080fd5b506000805460ff19169055600180556150468061002e6000396000f3fe608060405260043610620003e75760003560e01c80639010d07c1162000203578063c34902631162000117578063d8a5e93611620000ad578063eb4af0451162000078578063eb4af0451462000bbc578063f18876841462000be1578063f87975af1462000bf9578063f8c8765e1462000c5e57600080fd5b8063d8a5e9361462000b33578063db4567d31462000b58578063dd62ed3e1462000b70578063e039e3cc1462000b9557600080fd5b8063cb1045d011620000ee578063cb1045d01462000aba578063d0e30db01462000adf578063d1f8aaac1462000ae9578063d547741f1462000b0e57600080fd5b8063c34902631462000a4e578063c7c934a11462000a73578063ca15c8731462000a9557600080fd5b8063a23b49651162000199578063ad1497fa1162000164578063ad1497fa14620009c5578063ad87480814620009dd578063bc56684a1462000a11578063c1699a991462000a3657600080fd5b8063a23b49651462000947578063a457c2d7146200095f578063a7602c7e1462000984578063a9059cbb14620009a057600080fd5b80639d7710a511620001da5780639d7710a514620008d15780639ee679e814620008f35780639f94a9e31462000918578063a217fddf146200093057600080fd5b80639010d07c146200086f57806391d14854146200089457806395d89b4114620008b957600080fd5b8063372500ab11620002fb57806370a082311162000291578063846b3c8b116200025c578063846b3c8b14620007f857806385990de5146200081a578063873dfe34146200083f5780638e50e509146200085757600080fd5b806370a0823114620007695780637e1f1bfb14620007a3578063818a8e4c14620007bb5780638456cb5914620007e057600080fd5b8063446ed20b11620002d2578063446ed20b146200070757806353524303146200071f5780635c975abb146200073757806367300041146200075157600080fd5b8063372500ab146200064b5780633950935114620006635780633d3da6ef146200068857600080fd5b80631e6b4c6f116200037d5780632659bc1511620003485780632659bc1514620005b85780632f2ff15d14620005dd578063313ce567146200060257806336568abe146200062657600080fd5b80631e6b4c6f146200051557806323b872dd146200053a578063248a9ca3146200055f578063262b1f9e146200059357600080fd5b8063095ea7b311620003be578063095ea7b3146200046f5780631031eb9c146200049457806318160ddd14620004b95780631c0fc3f614620004da57600080fd5b806301ffc9a714620003f4578063046f7da2146200042e57806306fdde03146200044857600080fd5b36620003ef57005b600080fd5b3480156200040157600080fd5b50620004196200041336600462003549565b62000c83565b60405190151581526020015b60405180910390f35b3480156200043b57600080fd5b506200044662000cb1565b005b3480156200045557600080fd5b506200046062000cea565b604051620004259190620035d2565b3480156200047c57600080fd5b50620004196200048e366004620035ff565b62000d84565b348015620004a157600080fd5b5062000446620004b33660046200362c565b62000d9e565b348015620004c657600080fd5b506037545b60405190815260200162000425565b348015620004e757600080fd5b50607754620004fc906001600160a01b031681565b6040516001600160a01b03909116815260200162000425565b3480156200052257600080fd5b50620004466200053436600462003651565b62000dd0565b3480156200054757600080fd5b5062000419620005593660046200366b565b62000df1565b3480156200056c57600080fd5b50620004cb6200057e36600462003651565b60009081526067602052604090206001015490565b348015620005a057600080fd5b5062000446620005b236600462003651565b62000e1b565b348015620005c557600080fd5b5062000446620005d73660046200378e565b62000e3c565b348015620005ea57600080fd5b5062000446620005fc3660046200385b565b62000eb7565b3480156200060f57600080fd5b5060125b60405160ff909116815260200162000425565b3480156200063357600080fd5b5062000446620006453660046200385b565b62000ee5565b3480156200065857600080fd5b506200044662000f6b565b3480156200067057600080fd5b506200041962000682366004620035ff565b620010e9565b3480156200069557600080fd5b50620006ad620006a736600462003651565b62001111565b60405162000425919081516001600160a01b031681526020808301516001600160401b03169082015260408083015190820152606080830151908201526080808301519082015260a0918201519181019190915260c00190565b3480156200071457600080fd5b5062000446620011e4565b3480156200072c57600080fd5b50620004cb60735481565b3480156200074457600080fd5b5060005460ff1662000419565b3480156200075e57600080fd5b50620004cb620012d0565b3480156200077657600080fd5b50620004cb620007883660046200388a565b6001600160a01b031660009081526035602052604090205490565b348015620007b057600080fd5b50620004cb606c5481565b348015620007c857600080fd5b5062000446620007da36600462003651565b620012f4565b348015620007ed57600080fd5b506200044662001315565b3480156200080557600080fd5b50607654620004fc906001600160a01b031681565b3480156200082757600080fd5b50620004cb62000839366004620038a8565b6200134b565b3480156200084c57600080fd5b50620004cb606b5481565b3480156200086457600080fd5b50620004cb606f5481565b3480156200087c57600080fd5b50620004fc6200088e366004620038a8565b62001386565b348015620008a157600080fd5b5062000419620008b33660046200385b565b620013a0565b348015620008c657600080fd5b5062000460620013cb565b348015620008de57600080fd5b50606e54620004fc906001600160a01b031681565b3480156200090057600080fd5b50620004cb6200091236600462003651565b620013dc565b3480156200092557600080fd5b50620004cb62001696565b3480156200093d57600080fd5b50620004cb600081565b3480156200095457600080fd5b50620004cb620016b5565b3480156200096c57600080fd5b50620004196200097e366004620035ff565b620016c7565b3480156200099157600080fd5b50607454620006139060ff1681565b348015620009ad57600080fd5b5062000419620009bf366004620035ff565b62001753565b348015620009d257600080fd5b50620004cb60705481565b348015620009ea57600080fd5b5062000613620009fc3660046200388a565b606d6020526000908152604090205460ff1681565b34801562000a1e57600080fd5b50620004cb62000a30366004620038a8565b62001763565b34801562000a4357600080fd5b50620004cb60725481565b34801562000a5b57600080fd5b506200044662000a6d366004620038a8565b620017a1565b34801562000a8057600080fd5b50607854620004fc906001600160a01b031681565b34801562000aa257600080fd5b50620004cb62000ab436600462003651565b62001a75565b34801562000ac757600080fd5b506200044662000ad93660046200388a565b62001a8e565b6200044662001af4565b34801562000af657600080fd5b506200044662000b083660046200388a565b62001c0c565b34801562000b1b57600080fd5b506200044662000b2d3660046200385b565b62001c72565b34801562000b4057600080fd5b506200044662000b5236600462003651565b62001c9b565b34801562000b6557600080fd5b50620004cb62001cdc565b34801562000b7d57600080fd5b50620004cb62000b8f366004620038cb565b62001f4e565b34801562000ba257600080fd5b50607454620004fc9061010090046001600160a01b031681565b34801562000bc957600080fd5b506200044662000bdb36600462003651565b62001f79565b34801562000bee57600080fd5b50620004cb60715481565b34801562000c0657600080fd5b5062000c1e62000c1836600462003651565b62001f9a565b604080516001600160a01b0390971687526001600160401b039095166020870152938501929092526060840152608083015260a082015260c00162000425565b34801562000c6b57600080fd5b506200044662000c7d366004620038fa565b62001ff8565b60006001600160e01b03198216635a05180f60e01b148062000cab575062000cab8262002392565b92915050565b7fd76e3374742c17bd14ffaf46cd349ec292baf7d8425512fa8fe132557a4c967b62000cdd81620023c9565b62000ce7620023d5565b50565b60606038805462000cfb9062003957565b80601f016020809104026020016040519081016040528092919081815260200182805462000d299062003957565b801562000d7a5780601f1062000d4e5761010080835404028352916020019162000d7a565b820191906000526020600020905b81548152906001019060200180831162000d5c57829003601f168201915b5050505050905090565b60003362000d9481858562002429565b5060019392505050565b60008051602062004fd183398151915262000db981620023c9565b506074805460ff191660ff92909216919091179055565b60008051602062004fd183398151915262000deb81620023c9565b50607255565b60003362000e0185828562002551565b62000e0e858585620025d2565b60019150505b9392505050565b60008051602062004fd183398151915262000e3681620023c9565b50607055565b60008051602062004ff183398151915262000e5781620023c9565b828260405162000e679062003495565b62000e7492919062003994565b604051809103906000f08015801562000e91573d6000803e3d6000fd5b50606e80546001600160a01b0319166001600160a01b0392909216919091179055505050565b60008281526067602052604090206001015462000ed481620023c9565b62000ee0838362002785565b505050565b6001600160a01b038116331462000f5b5760405162461bcd60e51b815260206004820152602f60248201527f416363657373436f6e74726f6c3a2063616e206f6e6c792072656e6f756e636560448201526e103937b632b9903337b91039b2b63360891b60648201526084015b60405180910390fd5b62000f678282620027ab565b5050565b6078546001600160a01b0316318062000f815750565b60785460405163379607f560e01b8152600481018390526001600160a01b039091169063379607f590602401600060405180830381600087803b15801562000fc857600080fd5b505af115801562000fdd573d6000803e3d6000fd5b5050505060006064606f548362000ff5919062003a32565b62001001919062003a6a565b606e546040519192506001600160a01b03169082156108fc029083906000818181858888f193505050501580156200103d573d6000803e3d6000fd5b506040518181527f77bb62f6d632f13698ee0dfd8902692281a720e3bd4e18f03b96f3ba43ec5c259060200160405180910390a160006200107f828462003a8d565b90507f4f085349488b0a9bbaba55c0dce4ef2ebfc933ff64bdfe6ff3d4b27fdb46770681604051620010b391815260200190565b60405180910390a16000620010c882620027d1565b905080606c6000828254620010de919062003aa7565b909155505050505050565b60003362000d94818585620010ff838362001f4e565b6200110b919062003aa7565b62002429565b6200115d6040518060c0016040528060006001600160a01b0316815260200160006001600160401b03168152602001600081526020016000815260200160008152602001600081525090565b6069828154811062001173576200117362003ac2565b60009182526020918290206040805160c081018252600590930290910180546001600160a01b03811684526001600160401b03600160a01b9091041693830193909352600183015490820152600282015460608201526003820154608082015260049091015460a082015292915050565b6077546001600160a01b03163180620011fa5750565b606b5415806200120b575080606b54105b156200122a57604051630103be3b60e21b815260040160405180910390fd5b60775460405163379607f560e01b8152600481018390526001600160a01b039091169063379607f590602401600060405180830381600087803b1580156200127157600080fd5b505af115801562001286573d6000803e3d6000fd5b5050505080606b60008282546200129e919062003a8d565b9091555060009050620012b182620027d1565b905080606c6000828254620012c7919062003aa7565b90915550505050565b6000620012ef620012e0620016b5565b670de0b6b3a764000062001763565b905090565b60008051602062004fd18339815191526200130f81620023c9565b50607355565b7fd76e3374742c17bd14ffaf46cd349ec292baf7d8425512fa8fe132557a4c967b6200134181620023c9565b62000ce762002b16565b60006200135760375490565b158062001362575082155b156200137057508062000cab565b62000e14826200137f60375490565b8562002b56565b600082815260686020526040812062000e14908362002c0c565b60009182526067602090815260408084206001600160a01b0393909316845291905290205460ff1690565b60606039805462000cfb9062003957565b6000620013e862002c1a565b620013f262002c62565b816200141157604051630103be3b60e21b815260040160405180910390fd5b607454336000908152606d602052604090205460ff9182169116106200144a576040516376f6999760e11b815260040160405180910390fd5b336000908152606d60205260408120805460ff16916200146a8362003ad8565b91906101000a81548160ff021916908360ff1602179055505081620014a4336001600160a01b031660009081526035602052604090205490565b1015620014c457604051631e9acf1760e31b815260040160405180910390fd5b620014d1333084620025d2565b6000620014e8620014e1620016b5565b8462001763565b6040805160c0810182523381526001600160401b03428116602083019081529282018481526000606084018181526080850182815260a086018b81526069805460018181018355828752985160059091027f7fb4302e8e91f9110a6554c2c0a24601252c2a42c2220ca988efcfe399914308810180549b51909916600160a01b026001600160e01b0319909b166001600160a01b0392909216919091179990991790965593517f7fb4302e8e91f9110a6554c2c0a24601252c2a42c2220ca988efcfe39991430988015590517f7fb4302e8e91f9110a6554c2c0a24601252c2a42c2220ca988efcfe39991430a870155517f7fb4302e8e91f9110a6554c2c0a24601252c2a42c2220ca988efcfe39991430b86015590517f7fb4302e8e91f9110a6554c2c0a24601252c2a42c2220ca988efcfe39991430c9094019390935554929350909162001639919062003a8d565b6040805184815260208101879052428183015260608101839052905191925033917fdae9f04ebd508b8d6ff61ab1601937224910e223f2a01713eab68e3d4aeb10ef9181900360800190a29150506200169160018055565b919050565b6000620012ef620016a6620016b5565b670de0b6b3a76400006200134b565b600047606b54620012ef919062003aa7565b60003381620016d7828662001f4e565b905083811015620017395760405162461bcd60e51b815260206004820152602560248201527f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77604482015264207a65726f60d81b606482015260840162000f52565b62001748828686840362002429565b506001949350505050565b60003362000d94818585620025d2565b60006200176f60375490565b6200177d5750600062000cab565b826200178b57508062000cab565b62000e1482846200179b60375490565b62002b56565b620017ab62002c1a565b620017b562002c62565b6000620017c28362001111565b80519091506001600160a01b03163314620017f05760405163ea8e4eb560e01b815260040160405180910390fd5b8060800151816060015162001806919062003a8d565b821115620018275760405163a77cefcd60e01b815260040160405180910390fd5b478211156200184957604051631e9acf1760e31b815260040160405180910390fd5b81816080018181516200185d919062003aa7565b90525060698054829190859081106200187a576200187a62003ac2565b6000918252602080832084516005909302018054918501516001600160401b0316600160a01b026001600160e01b03199092166001600160a01b03909316929092171781556040808401516001830155606084015160028301556080840151600383015560a093840151600490920191909155918301519183015190916200190491859062002b56565b905062001912308262002cbe565b604051339084156108fc029085906000818181858888f1935050505015801562001940573d6000803e3d6000fd5b50604082015160808301511062001a2a57336000908152606d60205260408120805460ff1691620019718362003afb565b91906101000a81548160ff021916908360ff1602179055505060698481548110620019a057620019a062003ac2565b60009182526020822060059091020180546001600160e01b03191681556001808201839055600282018390556003820183905560049091019190915560405133907f30694308508a999b8c8335a05cfb5919eb0bd4d9415c29592c8f558145dbfaa59062001a1a9087908990918252602082015260400190565b60405180910390a3505062001a6b565b604080518481526020810186905260009133917f30694308508a999b8c8335a05cfb5919eb0bd4d9415c29592c8f558145dbfaa5910160405180910390a350505b62000f6760018055565b600081815260686020526040812062000cab9062002df6565b60008051602062004ff183398151915262001aa981620023c9565b6001600160a01b03821662001ad15760405163e6c4247b60e01b815260040160405180910390fd5b50607880546001600160a01b0319166001600160a01b0392909216919091179055565b62001afe62002c1a565b62001b0862002c62565b607154349081101562001b2e57604051630103be3b60e21b815260040160405180910390fd5b6073548162001b3c620016b5565b62001b48919062003aa7565b111562001b6857604051631027f1cd60e11b815260040160405180910390fd5b600062001b8c8262001b79620016b5565b62001b85919062003a8d565b836200134b565b905062001b9a338262002e01565b6040805183815242602082015233917fad40ae5dc69974ba932d08b0a608e89109412d41d04850f5196f144875ae2660910160405180910390a2600062001be183620027d1565b905080606c600082825462001bf7919062003aa7565b9091555050600180555062001c0a915050565b565b60008051602062004ff183398151915262001c2781620023c9565b6001600160a01b03821662001c4f5760405163e6c4247b60e01b815260040160405180910390fd5b50607780546001600160a01b0319166001600160a01b0392909216919091179055565b60008281526067602052604090206001015462001c8f81620023c9565b62000ee08383620027ab565b7f0fc26914248bb9568b0afb008dd993637f6fb6bdc9598c222c68a21e90ca53c162001cc781620023c9565b606482111562001cd657600080fd5b50606f55565b600062001ce862002c1a565b62001cf262002c62565b606c54158062001d055750607054606c54105b1562001d145750600062001f41565b607454606c54604051636194697d60e01b815260048101919091526000918291829161010090046001600160a01b031690636194697d90602401600060405180830381865afa15801562001d6c573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405262001d96919081019062003b7d565b92509250925082516000148062001dac57508151155b1562001dcb5760405163023ae0f360e11b815260040160405180910390fd5b600081606c5462001ddd919062003a8d565b905080606b600082825462001df3919062003aa7565b9091555050606c829055600062001e0d4261070862003aa7565b905060006072548262001e21919062003aa7565b905060005b865181101562001f375785818151811062001e455762001e4562003ac2565b60200260200101516000141562001e5c5762001f22565b60765486516001600160a01b03909116906389060b349088908490811062001e885762001e8862003ac2565b602002602001015189848151811062001ea55762001ea562003ac2565b602002602001015189858151811062001ec25762001ec262003ac2565b602002602001015187876040518663ffffffff1660e01b815260040162001eed949392919062003cc4565b6000604051808303818588803b15801562001f0757600080fd5b505af115801562001f1c573d6000803e3d6000fd5b50505050505b8062001f2e8162003cf5565b91505062001e26565b5091955050505050505b62001f4b60018055565b90565b6001600160a01b03918216600090815260366020908152604080832093909416825291909152205490565b60008051602062004fd183398151915262001f9481620023c9565b50607155565b6069818154811062001fab57600080fd5b6000918252602090912060059091020180546001820154600283015460038401546004909401546001600160a01b0384169550600160a01b9093046001600160401b031693919290919086565b600254610100900460ff1615808015620020195750600254600160ff909116105b80620020355750303b15801562002035575060025460ff166001145b6200209a5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b606482015260840162000f52565b6002805460ff191660011790558015620020be576002805461ff0019166101001790555b6200210b6040518060400160405280600b81526020016a0a6e8c2d6cac84082ac82b60ab1b815250604051806040016040528060068152602001650e6e882ac82b60d31b81525062002ec6565b6200211860003362002efc565b620021447fd76e3374742c17bd14ffaf46cd349ec292baf7d8425512fa8fe132557a4c967b3362002efc565b620021707f0fc26914248bb9568b0afb008dd993637f6fb6bdc9598c222c68a21e90ca53c13362002efc565b6200218b60008051602062004ff18339815191523362002efc565b620021b77f9fece4792c7ff5d25a4f6041da7db799a6228be21fcb6358ef0b12f1dd685cb63362002efc565b620021d260008051602062004fd18339815191523362002efc565b600a606f819055678ac7230489e8000060705567016345785d8a0000607155621275006072556074805469152d02c7e14af6800000607355607680546001600160a01b038781166001600160a01b0319909216919091179091558616610100026001600160a81b031990911617909117905560408051600280825260608201835260009260208301908036833701905050905085816000815181106200227c576200227c62003ac2565b60200260200101906001600160a01b031690816001600160a01b0316815250508481600181518110620022b357620022b362003ac2565b6001600160a01b0392909216602092830291909101820152604080516002808252606082018352600093919290918301908036833701905050905060508160008151811062002306576200230662003ac2565b6020026020010181815250506014816001815181106200232a576200232a62003ac2565b60200260200101818152505062002342828262000e3c565b505080156200238b576002805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b5050505050565b60006001600160e01b03198216637965db0b60e01b148062000cab57506301ffc9a760e01b6001600160e01b031983161462000cab565b62000ce7813362002f08565b620023df62002f6c565b6000805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b6001600160a01b0383166200248d5760405162461bcd60e51b8152602060048201526024808201527f45524332303a20617070726f76652066726f6d20746865207a65726f206164646044820152637265737360e01b606482015260840162000f52565b6001600160a01b038216620024f05760405162461bcd60e51b815260206004820152602260248201527f45524332303a20617070726f766520746f20746865207a65726f206164647265604482015261737360f01b606482015260840162000f52565b6001600160a01b0383811660008181526036602090815260408083209487168084529482529182902085905590518481527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a3505050565b60006200255f848462001f4e565b90506000198114620025cc5781811015620025bd5760405162461bcd60e51b815260206004820152601d60248201527f45524332303a20696e73756666696369656e7420616c6c6f77616e6365000000604482015260640162000f52565b620025cc848484840362002429565b50505050565b6001600160a01b038316620026385760405162461bcd60e51b815260206004820152602560248201527f45524332303a207472616e736665722066726f6d20746865207a65726f206164604482015264647265737360d81b606482015260840162000f52565b6001600160a01b0382166200269c5760405162461bcd60e51b815260206004820152602360248201527f45524332303a207472616e7366657220746f20746865207a65726f206164647260448201526265737360e81b606482015260840162000f52565b6001600160a01b03831660009081526035602052604090205481811015620027165760405162461bcd60e51b815260206004820152602660248201527f45524332303a207472616e7366657220616d6f756e7420657863656564732062604482015265616c616e636560d01b606482015260840162000f52565b6001600160a01b0380851660008181526035602052604080822086860390559286168082529083902080548601905591517fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef90620027779086815260200190565b60405180910390a3620025cc565b62002791828262002fb7565b600082815260686020526040902062000ee0908262003041565b620027b7828262003058565b600082815260686020526040902062000ee09082620030c2565b600081620027e157506000919050565b606a5460009083905b60695481101562002b0e5781620028015762002b0e565b62002896606982815481106200281b576200281b62003ac2565b60009182526020918290206040805160c081018252600590930290910180546001600160a01b03811684526001600160401b03600160a01b9091041693830193909352600183015490820152600282015460608201526003820154608082015260049091015460a08201526040810151606090910151101590565b15620028f55760405162461bcd60e51b815260206004820152602760248201527f496e76616c6964207374617465202d2066696c6c6564207265717565737420696044820152666e20717565756560c81b606482015260840162000f52565b606981815481106200290b576200290b62003ac2565b9060005260206000209060050201600101546069828154811062002933576200293362003ac2565b906000526020600020906005020160020154101562002aeb5760006069828154811062002964576200296462003ac2565b906000526020600020906005020160020154606983815481106200298c576200298c62003ac2565b906000526020600020906005020160010154620029aa919062003a8d565b90506000620029ba8285620030d9565b9050620029c8818662003aa7565b94508060698481548110620029e157620029e162003ac2565b9060005260206000209060050201600201600082825462002a03919062003aa7565b9250508190555062002a24606984815481106200281b576200281b62003ac2565b1562002aac5762002a3783600162003aa7565b606a55606980548490811062002a515762002a5162003ac2565b9060005260206000209060050201600101547f6c09cd6b64ed10fcbd787eb4226ec81ab34e3db928a77faef8d22bc10ebe82ed428560405162002a9e929190918252602082015260400190565b60405180910390a262002ae8565b604080514281526020810185905282917fdc0903a14c2c2526071b103c0305417a977225da3764984a90de4c9b8195cac5910160405180910390a25b50505b62002af7838662003a8d565b91508062002b058162003cf5565b915050620027ea565b509392505050565b62002b2062002c1a565b6000805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586200240c3390565b60008080600019858709858702925082811083820303915050806000141562002b965783828162002b8b5762002b8b62003a54565b049250505062000e14565b80841162002ba357600080fd5b60008486880960026001871981018816978890046003810283188082028403028082028403028082028403028082028403028082028403029081029092039091026000889003889004909101858311909403939093029303949094049190911702949350505050565b600062000e148383620030f1565b60005460ff161562001c0a5760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b604482015260640162000f52565b6002600154141562002cb75760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c00604482015260640162000f52565b6002600155565b6001600160a01b03821662002d205760405162461bcd60e51b815260206004820152602160248201527f45524332303a206275726e2066726f6d20746865207a65726f206164647265736044820152607360f81b606482015260840162000f52565b6001600160a01b0382166000908152603560205260409020548181101562002d965760405162461bcd60e51b815260206004820152602260248201527f45524332303a206275726e20616d6f756e7420657863656564732062616c616e604482015261636560f01b606482015260840162000f52565b6001600160a01b03831660008181526035602090815260408083208686039055603780548790039055518581529192917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef910160405180910390a3505050565b600062000cab825490565b6001600160a01b03821662002e595760405162461bcd60e51b815260206004820152601f60248201527f45524332303a206d696e7420746f20746865207a65726f206164647265737300604482015260640162000f52565b806037600082825462002e6d919062003aa7565b90915550506001600160a01b0382166000818152603560209081526040808320805486019055518481527fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef910160405180910390a35050565b600254610100900460ff1662002ef05760405162461bcd60e51b815260040162000f529062003d13565b62000f6782826200311e565b62000f67828262002785565b62002f148282620013a0565b62000f675762002f248162003173565b62002f3183602062003186565b60405160200162002f4492919062003d5e565b60408051601f198184030181529082905262461bcd60e51b825262000f5291600401620035d2565b60005460ff1662001c0a5760405162461bcd60e51b815260206004820152601460248201527314185d5cd8589b194e881b9bdd081c185d5cd95960621b604482015260640162000f52565b62002fc38282620013a0565b62000f675760008281526067602090815260408083206001600160a01b03851684529091529020805460ff1916600117905562002ffd3390565b6001600160a01b0316816001600160a01b0316837f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45050565b600062000e14836001600160a01b0384166200333f565b620030648282620013a0565b1562000f675760008281526067602090815260408083206001600160a01b0385168085529252808320805460ff1916905551339285917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45050565b600062000e14836001600160a01b03841662003391565b6000818310620030ea578162000e14565b5090919050565b60008260000182815481106200310b576200310b62003ac2565b9060005260206000200154905092915050565b600254610100900460ff16620031485760405162461bcd60e51b815260040162000f529062003d13565b81516200315d906038906020850190620034a3565b50805162000ee0906039906020840190620034a3565b606062000cab6001600160a01b03831660145b606060006200319783600262003a32565b620031a490600262003aa7565b6001600160401b03811115620031be57620031be620036ac565b6040519080825280601f01601f191660200182016040528015620031e9576020820181803683370190505b509050600360fc1b8160008151811062003207576200320762003ac2565b60200101906001600160f81b031916908160001a905350600f60fb1b8160018151811062003239576200323962003ac2565b60200101906001600160f81b031916908160001a90535060006200325f84600262003a32565b6200326c90600162003aa7565b90505b6001811115620032ee576f181899199a1a9b1b9c1cb0b131b232b360811b85600f1660108110620032a457620032a462003ac2565b1a60f81b828281518110620032bd57620032bd62003ac2565b60200101906001600160f81b031916908160001a90535060049490941c93620032e68162003dd7565b90506200326f565b50831562000e145760405162461bcd60e51b815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e74604482015260640162000f52565b6000818152600183016020526040812054620033885750815460018181018455600084815260208082209093018490558454848252828601909352604090209190915562000cab565b50600062000cab565b600081815260018301602052604081205480156200348a576000620033b860018362003a8d565b8554909150600090620033ce9060019062003a8d565b90508181146200343a576000866000018281548110620033f257620033f262003ac2565b906000526020600020015490508087600001848154811062003418576200341862003ac2565b6000918252602080832090910192909255918252600188019052604090208390555b85548690806200344e576200344e62003df1565b60019003818190600052602060002001600090559055856001016000868152602001908152602001600020600090556001935050505062000cab565b600091505062000cab565b6111c98062003e0883390190565b828054620034b19062003957565b90600052602060002090601f016020900481019282620034d5576000855562003520565b82601f10620034f057805160ff191683800117855562003520565b8280016001018555821562003520579182015b828111156200352057825182559160200191906001019062003503565b506200352e92915062003532565b5090565b5b808211156200352e576000815560010162003533565b6000602082840312156200355c57600080fd5b81356001600160e01b03198116811462000e1457600080fd5b60005b838110156200359257818101518382015260200162003578565b83811115620025cc5750506000910152565b60008151808452620035be81602086016020860162003575565b601f01601f19169290920160200192915050565b60208152600062000e146020830184620035a4565b80356001600160a01b03811681146200169157600080fd5b600080604083850312156200361357600080fd5b6200361e83620035e7565b946020939093013593505050565b6000602082840312156200363f57600080fd5b813560ff8116811462000e1457600080fd5b6000602082840312156200366457600080fd5b5035919050565b6000806000606084860312156200368157600080fd5b6200368c84620035e7565b92506200369c60208501620035e7565b9150604084013590509250925092565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b0381118282101715620036ed57620036ed620036ac565b604052919050565b60006001600160401b03821115620037115762003711620036ac565b5060051b60200190565b600082601f8301126200372d57600080fd5b81356020620037466200374083620036f5565b620036c2565b82815260059290921b840181019181810190868411156200376657600080fd5b8286015b848110156200378357803583529183019183016200376a565b509695505050505050565b60008060408385031215620037a257600080fd5b82356001600160401b0380821115620037ba57600080fd5b818501915085601f830112620037cf57600080fd5b81356020620037e26200374083620036f5565b82815260059290921b840181019181810190898411156200380257600080fd5b948201945b838610156200382b576200381b86620035e7565b8252948201949082019062003807565b965050860135925050808211156200384257600080fd5b5062003851858286016200371b565b9150509250929050565b600080604083850312156200386f57600080fd5b823591506200388160208401620035e7565b90509250929050565b6000602082840312156200389d57600080fd5b62000e1482620035e7565b60008060408385031215620038bc57600080fd5b50508035926020909101359150565b60008060408385031215620038df57600080fd5b620038ea83620035e7565b91506200388160208401620035e7565b600080600080608085870312156200391157600080fd5b6200391c85620035e7565b93506200392c60208601620035e7565b92506200393c60408601620035e7565b91506200394c60608601620035e7565b905092959194509250565b600181811c908216806200396c57607f821691505b602082108114156200398e57634e487b7160e01b600052602260045260246000fd5b50919050565b604080825283519082018190526000906020906060840190828701845b82811015620039d85781516001600160a01b031684529284019290840190600101620039b1565b5050508381038285015284518082528583019183019060005b8181101562003a0f57835183529284019291840191600101620039f1565b5090979650505050505050565b634e487b7160e01b600052601160045260246000fd5b600081600019048311821515161562003a4f5762003a4f62003a1c565b500290565b634e487b7160e01b600052601260045260246000fd5b60008262003a8857634e487b7160e01b600052601260045260246000fd5b500490565b60008282101562003aa25762003aa262003a1c565b500390565b6000821982111562003abd5762003abd62003a1c565b500190565b634e487b7160e01b600052603260045260246000fd5b600060ff821660ff81141562003af25762003af262003a1c565b60010192915050565b600060ff82168062003b115762003b1162003a1c565b6000190192915050565b600082601f83011262003b2d57600080fd5b8151602062003b406200374083620036f5565b82815260059290921b8401810191818101908684111562003b6057600080fd5b8286015b8481101562003783578051835291830191830162003b64565b60008060006060848603121562003b9357600080fd5b83516001600160401b038082111562003bab57600080fd5b818601915086601f83011262003bc057600080fd5b8151602062003bd36200374083620036f5565b82815260059290921b8401810191818101908a84111562003bf357600080fd5b8286015b8481101562003c895780518681111562003c115760008081fd5b8701603f81018d1362003c245760008081fd5b8481015160408882111562003c3d5762003c3d620036ac565b62003c51601f8301601f19168801620036c2565b8281528f8284860101111562003c675760008081fd5b62003c788389830184870162003575565b865250505091830191830162003bf7565b509189015191975090935050508082111562003ca457600080fd5b5062003cb38682870162003b1b565b925050604084015190509250925092565b60808152600062003cd96080830187620035a4565b6020830195909552506040810192909252606090910152919050565b600060001982141562003d0c5762003d0c62003a1c565b5060010190565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b7f416363657373436f6e74726f6c3a206163636f756e742000000000000000000081526000835162003d9881601785016020880162003575565b7001034b99036b4b9b9b4b733903937b6329607d1b601791840191820152835162003dcb81602884016020880162003575565b01602801949350505050565b60008162003de95762003de962003a1c565b506000190190565b634e487b7160e01b600052603160045260246000fdfe6080604052604051620011c9380380620011c983398101604081905262000026916200042e565b8051825114620000985760405162461bcd60e51b815260206004820152603260248201527f5061796d656e7453706c69747465723a2070617965657320616e6420736861726044820152710cae640d8cadccee8d040dad2e6dac2e8c6d60731b60648201526084015b60405180910390fd5b6000825111620000eb5760405162461bcd60e51b815260206004820152601a60248201527f5061796d656e7453706c69747465723a206e6f2070617965657300000000000060448201526064016200008f565b60005b82518110156200015757620001428382815181106200011157620001116200050c565b60200260200101518383815181106200012e576200012e6200050c565b60200260200101516200016060201b60201c565b806200014e8162000538565b915050620000ee565b50505062000571565b6001600160a01b038216620001cd5760405162461bcd60e51b815260206004820152602c60248201527f5061796d656e7453706c69747465723a206163636f756e74206973207468652060448201526b7a65726f206164647265737360a01b60648201526084016200008f565b600081116200021f5760405162461bcd60e51b815260206004820152601d60248201527f5061796d656e7453706c69747465723a2073686172657320617265203000000060448201526064016200008f565b6001600160a01b038216600090815260026020526040902054156200029b5760405162461bcd60e51b815260206004820152602b60248201527f5061796d656e7453706c69747465723a206163636f756e7420616c726561647960448201526a206861732073686172657360a81b60648201526084016200008f565b60048054600181019091557f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b0180546001600160a01b0319166001600160a01b0384169081179091556000908152600260205260408120829055546200030390829062000556565b600055604080516001600160a01b0384168152602081018390527f40c340f65e17194d14ddddb073d3c9f888e3cb52b5aae0c6c7706b4fbc905fac910160405180910390a15050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b03811182821017156200038d576200038d6200034c565b604052919050565b60006001600160401b03821115620003b157620003b16200034c565b5060051b60200190565b600082601f830112620003cd57600080fd5b81516020620003e6620003e08362000395565b62000362565b82815260059290921b840181019181810190868411156200040657600080fd5b8286015b848110156200042357805183529183019183016200040a565b509695505050505050565b600080604083850312156200044257600080fd5b82516001600160401b03808211156200045a57600080fd5b818501915085601f8301126200046f57600080fd5b8151602062000482620003e08362000395565b82815260059290921b84018101918181019089841115620004a257600080fd5b948201945b83861015620004d95785516001600160a01b0381168114620004c95760008081fd5b82529482019490820190620004a7565b91880151919650909350505080821115620004f357600080fd5b506200050285828601620003bb565b9150509250929050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b60006000198214156200054f576200054f62000522565b5060010190565b600082198211156200056c576200056c62000522565b500190565b610c4880620005816000396000f3fe6080604052600436106100a05760003560e01c80639852595c116100645780639852595c146101d2578063a3f8eace14610208578063c45ac05014610228578063ce7c2ac214610248578063d79779b21461027e578063e33b7de3146102b457600080fd5b806319165587146100ee5780633a98ef3914610110578063406072a91461013457806348b750441461017a5780638b83209b1461019a57600080fd5b366100e9577f6ef95f06320e7a25a04a175ca677b7052bdd97131872c2192525a629f51be77033604080516001600160a01b0390921682523460208301520160405180910390a1005b600080fd5b3480156100fa57600080fd5b5061010e6101093660046109bc565b6102c9565b005b34801561011c57600080fd5b506000545b6040519081526020015b60405180910390f35b34801561014057600080fd5b5061012161014f3660046109d9565b6001600160a01b03918216600090815260066020908152604080832093909416825291909152205490565b34801561018657600080fd5b5061010e6101953660046109d9565b6103b6565b3480156101a657600080fd5b506101ba6101b5366004610a12565b6104c4565b6040516001600160a01b03909116815260200161012b565b3480156101de57600080fd5b506101216101ed3660046109bc565b6001600160a01b031660009081526003602052604090205490565b34801561021457600080fd5b506101216102233660046109bc565b6104f4565b34801561023457600080fd5b506101216102433660046109d9565b61053c565b34801561025457600080fd5b506101216102633660046109bc565b6001600160a01b031660009081526002602052604090205490565b34801561028a57600080fd5b506101216102993660046109bc565b6001600160a01b031660009081526005602052604090205490565b3480156102c057600080fd5b50600154610121565b6001600160a01b0381166000908152600260205260409020546103075760405162461bcd60e51b81526004016102fe90610a2b565b60405180910390fd5b6000610312826104f4565b9050806103315760405162461bcd60e51b81526004016102fe90610a71565b80600160008282546103439190610ad2565b90915550506001600160a01b03821660009081526003602052604090208054820190556103708282610607565b604080516001600160a01b0384168152602081018390527fdf20fd1e76bc69d672e4814fafb2c449bba3a5369d8359adf9e05e6fde87b056910160405180910390a15050565b6001600160a01b0381166000908152600260205260409020546103eb5760405162461bcd60e51b81526004016102fe90610a2b565b60006103f7838361053c565b9050806104165760405162461bcd60e51b81526004016102fe90610a71565b6001600160a01b0383166000908152600560205260408120805483929061043e908490610ad2565b90915550506001600160a01b038084166000908152600660209081526040808320938616835292905220805482019055610479838383610725565b604080516001600160a01b038481168252602082018490528516917f3be5b7a71e84ed12875d241991c70855ac5817d847039e17a9d895c1ceb0f18a910160405180910390a2505050565b6000600482815481106104d9576104d9610aea565b6000918252602090912001546001600160a01b031692915050565b60008061050060015490565b61050a9047610ad2565b90506105358382610530866001600160a01b031660009081526003602052604090205490565b610777565b9392505050565b6001600160a01b03821660009081526005602052604081205481906040516370a0823160e01b81523060048201526001600160a01b038616906370a0823190602401602060405180830381865afa15801561059b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105bf9190610b00565b6105c99190610ad2565b6001600160a01b038086166000908152600660209081526040808320938816835292905220549091506105ff9084908390610777565b949350505050565b804710156106575760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a20696e73756666696369656e742062616c616e636500000060448201526064016102fe565b6000826001600160a01b03168260405160006040518083038185875af1925050503d80600081146106a4576040519150601f19603f3d011682016040523d82523d6000602084013e6106a9565b606091505b50509050806107205760405162461bcd60e51b815260206004820152603a60248201527f416464726573733a20756e61626c6520746f2073656e642076616c75652c207260448201527f6563697069656e74206d6179206861766520726576657274656400000000000060648201526084016102fe565b505050565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663a9059cbb60e01b1790526107209084906107b2565b600080546001600160a01b03851682526002602052604082205483919061079e9086610b19565b6107a89190610b38565b6105ff9190610b5a565b6000610807826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166108849092919063ffffffff16565b80519091501561072057808060200190518101906108259190610b71565b6107205760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016102fe565b60606105ff848460008585600080866001600160a01b031685876040516108ab9190610bc3565b60006040518083038185875af1925050503d80600081146108e8576040519150601f19603f3d011682016040523d82523d6000602084013e6108ed565b606091505b50915091506108fe87838387610909565b979650505050505050565b6060831561097557825161096e576001600160a01b0385163b61096e5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016102fe565b50816105ff565b6105ff838381511561098a5781518083602001fd5b8060405162461bcd60e51b81526004016102fe9190610bdf565b6001600160a01b03811681146109b957600080fd5b50565b6000602082840312156109ce57600080fd5b8135610535816109a4565b600080604083850312156109ec57600080fd5b82356109f7816109a4565b91506020830135610a07816109a4565b809150509250929050565b600060208284031215610a2457600080fd5b5035919050565b60208082526026908201527f5061796d656e7453706c69747465723a206163636f756e7420686173206e6f2060408201526573686172657360d01b606082015260800190565b6020808252602b908201527f5061796d656e7453706c69747465723a206163636f756e74206973206e6f742060408201526a191d59481c185e5b595b9d60aa1b606082015260800190565b634e487b7160e01b600052601160045260246000fd5b60008219821115610ae557610ae5610abc565b500190565b634e487b7160e01b600052603260045260246000fd5b600060208284031215610b1257600080fd5b5051919050565b6000816000190483118215151615610b3357610b33610abc565b500290565b600082610b5557634e487b7160e01b600052601260045260246000fd5b500490565b600082821015610b6c57610b6c610abc565b500390565b600060208284031215610b8357600080fd5b8151801515811461053557600080fd5b60005b83811015610bae578181015183820152602001610b96565b83811115610bbd576000848401525b50505050565b60008251610bd5818460208701610b93565b9190910192915050565b6020815260008251806020840152610bfe816040850160208701610b93565b601f01601f1916919091016040019291505056fea264697066735822122072124e5593df9b0f269294bc9437eac01d2c53da3f72549c0203647d323fdb5464736f6c634300080a0033d3ef87a7ea0f8f246b3bb6af4b410a89667f439c24eb3b101b985c7586acc2d2eed8967f77314cb9509704749de6f91c4a59cade181d6e377c26775e759a943da2646970667358221220feb928089377fc99316d7ffc2ae0c6a6667374d6c1a31434e207b6a80089e01564736f6c634300080a0033",
}

// PayableAvaLidoABI is the input ABI used to generate the binding from.
// Deprecated: Use PayableAvaLidoMetaData.ABI instead.
var PayableAvaLidoABI = PayableAvaLidoMetaData.ABI

// Deprecated: Use PayableAvaLidoMetaData.Sigs instead.
// PayableAvaLidoFuncSigs maps the 4-byte function signature to its string representation.
var PayableAvaLidoFuncSigs = PayableAvaLidoMetaData.Sigs

// PayableAvaLidoBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use PayableAvaLidoMetaData.Bin instead.
var PayableAvaLidoBin = PayableAvaLidoMetaData.Bin

// DeployPayableAvaLido deploys a new Ethereum contract, binding an instance of PayableAvaLido to it.
func DeployPayableAvaLido(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *PayableAvaLido, error) {
	parsed, err := PayableAvaLidoMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(PayableAvaLidoBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &PayableAvaLido{PayableAvaLidoCaller: PayableAvaLidoCaller{contract: contract}, PayableAvaLidoTransactor: PayableAvaLidoTransactor{contract: contract}, PayableAvaLidoFilterer: PayableAvaLidoFilterer{contract: contract}}, nil
}

// PayableAvaLido is an auto generated Go binding around an Ethereum contract.
type PayableAvaLido struct {
	PayableAvaLidoCaller     // Read-only binding to the contract
	PayableAvaLidoTransactor // Write-only binding to the contract
	PayableAvaLidoFilterer   // Log filterer for contract events
}

// PayableAvaLidoCaller is an auto generated read-only Go binding around an Ethereum contract.
type PayableAvaLidoCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PayableAvaLidoTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PayableAvaLidoTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PayableAvaLidoFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PayableAvaLidoFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PayableAvaLidoSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PayableAvaLidoSession struct {
	Contract     *PayableAvaLido   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PayableAvaLidoCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PayableAvaLidoCallerSession struct {
	Contract *PayableAvaLidoCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// PayableAvaLidoTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PayableAvaLidoTransactorSession struct {
	Contract     *PayableAvaLidoTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// PayableAvaLidoRaw is an auto generated low-level Go binding around an Ethereum contract.
type PayableAvaLidoRaw struct {
	Contract *PayableAvaLido // Generic contract binding to access the raw methods on
}

// PayableAvaLidoCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PayableAvaLidoCallerRaw struct {
	Contract *PayableAvaLidoCaller // Generic read-only contract binding to access the raw methods on
}

// PayableAvaLidoTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PayableAvaLidoTransactorRaw struct {
	Contract *PayableAvaLidoTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPayableAvaLido creates a new instance of PayableAvaLido, bound to a specific deployed contract.
func NewPayableAvaLido(address common.Address, backend bind.ContractBackend) (*PayableAvaLido, error) {
	contract, err := bindPayableAvaLido(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &PayableAvaLido{PayableAvaLidoCaller: PayableAvaLidoCaller{contract: contract}, PayableAvaLidoTransactor: PayableAvaLidoTransactor{contract: contract}, PayableAvaLidoFilterer: PayableAvaLidoFilterer{contract: contract}}, nil
}

// NewPayableAvaLidoCaller creates a new read-only instance of PayableAvaLido, bound to a specific deployed contract.
func NewPayableAvaLidoCaller(address common.Address, caller bind.ContractCaller) (*PayableAvaLidoCaller, error) {
	contract, err := bindPayableAvaLido(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PayableAvaLidoCaller{contract: contract}, nil
}

// NewPayableAvaLidoTransactor creates a new write-only instance of PayableAvaLido, bound to a specific deployed contract.
func NewPayableAvaLidoTransactor(address common.Address, transactor bind.ContractTransactor) (*PayableAvaLidoTransactor, error) {
	contract, err := bindPayableAvaLido(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PayableAvaLidoTransactor{contract: contract}, nil
}

// NewPayableAvaLidoFilterer creates a new log filterer instance of PayableAvaLido, bound to a specific deployed contract.
func NewPayableAvaLidoFilterer(address common.Address, filterer bind.ContractFilterer) (*PayableAvaLidoFilterer, error) {
	contract, err := bindPayableAvaLido(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PayableAvaLidoFilterer{contract: contract}, nil
}

// bindPayableAvaLido binds a generic wrapper to an already deployed contract.
func bindPayableAvaLido(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(PayableAvaLidoABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PayableAvaLido *PayableAvaLidoRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PayableAvaLido.Contract.PayableAvaLidoCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PayableAvaLido *PayableAvaLidoRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.PayableAvaLidoTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PayableAvaLido *PayableAvaLidoRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.PayableAvaLidoTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PayableAvaLido *PayableAvaLidoCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PayableAvaLido.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PayableAvaLido *PayableAvaLidoTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PayableAvaLido *PayableAvaLidoTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.contract.Transact(opts, method, params...)
}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_PayableAvaLido *PayableAvaLidoCaller) DEFAULTADMINROLE(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "DEFAULT_ADMIN_ROLE")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_PayableAvaLido *PayableAvaLidoSession) DEFAULTADMINROLE() ([32]byte, error) {
	return _PayableAvaLido.Contract.DEFAULTADMINROLE(&_PayableAvaLido.CallOpts)
}

// DEFAULTADMINROLE is a free data retrieval call binding the contract method 0xa217fddf.
//
// Solidity: function DEFAULT_ADMIN_ROLE() view returns(bytes32)
func (_PayableAvaLido *PayableAvaLidoCallerSession) DEFAULTADMINROLE() ([32]byte, error) {
	return _PayableAvaLido.Contract.DEFAULTADMINROLE(&_PayableAvaLido.CallOpts)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCaller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _PayableAvaLido.Contract.Allowance(&_PayableAvaLido.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _PayableAvaLido.Contract.Allowance(&_PayableAvaLido.CallOpts, owner, spender)
}

// AmountPendingAVAX is a free data retrieval call binding the contract method 0x7e1f1bfb.
//
// Solidity: function amountPendingAVAX() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCaller) AmountPendingAVAX(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "amountPendingAVAX")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// AmountPendingAVAX is a free data retrieval call binding the contract method 0x7e1f1bfb.
//
// Solidity: function amountPendingAVAX() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoSession) AmountPendingAVAX() (*big.Int, error) {
	return _PayableAvaLido.Contract.AmountPendingAVAX(&_PayableAvaLido.CallOpts)
}

// AmountPendingAVAX is a free data retrieval call binding the contract method 0x7e1f1bfb.
//
// Solidity: function amountPendingAVAX() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCallerSession) AmountPendingAVAX() (*big.Int, error) {
	return _PayableAvaLido.Contract.AmountPendingAVAX(&_PayableAvaLido.CallOpts)
}

// AmountStakedAVAX is a free data retrieval call binding the contract method 0x873dfe34.
//
// Solidity: function amountStakedAVAX() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCaller) AmountStakedAVAX(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "amountStakedAVAX")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// AmountStakedAVAX is a free data retrieval call binding the contract method 0x873dfe34.
//
// Solidity: function amountStakedAVAX() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoSession) AmountStakedAVAX() (*big.Int, error) {
	return _PayableAvaLido.Contract.AmountStakedAVAX(&_PayableAvaLido.CallOpts)
}

// AmountStakedAVAX is a free data retrieval call binding the contract method 0x873dfe34.
//
// Solidity: function amountStakedAVAX() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCallerSession) AmountStakedAVAX() (*big.Int, error) {
	return _PayableAvaLido.Contract.AmountStakedAVAX(&_PayableAvaLido.CallOpts)
}

// AvaxToStAVAX is a free data retrieval call binding the contract method 0x85990de5.
//
// Solidity: function avaxToStAVAX(uint256 totalControlled, uint256 avaxAmount) view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCaller) AvaxToStAVAX(opts *bind.CallOpts, totalControlled *big.Int, avaxAmount *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "avaxToStAVAX", totalControlled, avaxAmount)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// AvaxToStAVAX is a free data retrieval call binding the contract method 0x85990de5.
//
// Solidity: function avaxToStAVAX(uint256 totalControlled, uint256 avaxAmount) view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoSession) AvaxToStAVAX(totalControlled *big.Int, avaxAmount *big.Int) (*big.Int, error) {
	return _PayableAvaLido.Contract.AvaxToStAVAX(&_PayableAvaLido.CallOpts, totalControlled, avaxAmount)
}

// AvaxToStAVAX is a free data retrieval call binding the contract method 0x85990de5.
//
// Solidity: function avaxToStAVAX(uint256 totalControlled, uint256 avaxAmount) view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCallerSession) AvaxToStAVAX(totalControlled *big.Int, avaxAmount *big.Int) (*big.Int, error) {
	return _PayableAvaLido.Contract.AvaxToStAVAX(&_PayableAvaLido.CallOpts, totalControlled, avaxAmount)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCaller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _PayableAvaLido.Contract.BalanceOf(&_PayableAvaLido.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _PayableAvaLido.Contract.BalanceOf(&_PayableAvaLido.CallOpts, account)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_PayableAvaLido *PayableAvaLidoCaller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "decimals")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_PayableAvaLido *PayableAvaLidoSession) Decimals() (uint8, error) {
	return _PayableAvaLido.Contract.Decimals(&_PayableAvaLido.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_PayableAvaLido *PayableAvaLidoCallerSession) Decimals() (uint8, error) {
	return _PayableAvaLido.Contract.Decimals(&_PayableAvaLido.CallOpts)
}

// ExchangeRateAVAXToStAVAX is a free data retrieval call binding the contract method 0x9f94a9e3.
//
// Solidity: function exchangeRateAVAXToStAVAX() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCaller) ExchangeRateAVAXToStAVAX(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "exchangeRateAVAXToStAVAX")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ExchangeRateAVAXToStAVAX is a free data retrieval call binding the contract method 0x9f94a9e3.
//
// Solidity: function exchangeRateAVAXToStAVAX() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoSession) ExchangeRateAVAXToStAVAX() (*big.Int, error) {
	return _PayableAvaLido.Contract.ExchangeRateAVAXToStAVAX(&_PayableAvaLido.CallOpts)
}

// ExchangeRateAVAXToStAVAX is a free data retrieval call binding the contract method 0x9f94a9e3.
//
// Solidity: function exchangeRateAVAXToStAVAX() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCallerSession) ExchangeRateAVAXToStAVAX() (*big.Int, error) {
	return _PayableAvaLido.Contract.ExchangeRateAVAXToStAVAX(&_PayableAvaLido.CallOpts)
}

// ExchangeRateStAVAXToAVAX is a free data retrieval call binding the contract method 0x67300041.
//
// Solidity: function exchangeRateStAVAXToAVAX() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCaller) ExchangeRateStAVAXToAVAX(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "exchangeRateStAVAXToAVAX")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ExchangeRateStAVAXToAVAX is a free data retrieval call binding the contract method 0x67300041.
//
// Solidity: function exchangeRateStAVAXToAVAX() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoSession) ExchangeRateStAVAXToAVAX() (*big.Int, error) {
	return _PayableAvaLido.Contract.ExchangeRateStAVAXToAVAX(&_PayableAvaLido.CallOpts)
}

// ExchangeRateStAVAXToAVAX is a free data retrieval call binding the contract method 0x67300041.
//
// Solidity: function exchangeRateStAVAXToAVAX() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCallerSession) ExchangeRateStAVAXToAVAX() (*big.Int, error) {
	return _PayableAvaLido.Contract.ExchangeRateStAVAXToAVAX(&_PayableAvaLido.CallOpts)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_PayableAvaLido *PayableAvaLidoCaller) GetRoleAdmin(opts *bind.CallOpts, role [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "getRoleAdmin", role)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_PayableAvaLido *PayableAvaLidoSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _PayableAvaLido.Contract.GetRoleAdmin(&_PayableAvaLido.CallOpts, role)
}

// GetRoleAdmin is a free data retrieval call binding the contract method 0x248a9ca3.
//
// Solidity: function getRoleAdmin(bytes32 role) view returns(bytes32)
func (_PayableAvaLido *PayableAvaLidoCallerSession) GetRoleAdmin(role [32]byte) ([32]byte, error) {
	return _PayableAvaLido.Contract.GetRoleAdmin(&_PayableAvaLido.CallOpts, role)
}

// GetRoleMember is a free data retrieval call binding the contract method 0x9010d07c.
//
// Solidity: function getRoleMember(bytes32 role, uint256 index) view returns(address)
func (_PayableAvaLido *PayableAvaLidoCaller) GetRoleMember(opts *bind.CallOpts, role [32]byte, index *big.Int) (common.Address, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "getRoleMember", role, index)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetRoleMember is a free data retrieval call binding the contract method 0x9010d07c.
//
// Solidity: function getRoleMember(bytes32 role, uint256 index) view returns(address)
func (_PayableAvaLido *PayableAvaLidoSession) GetRoleMember(role [32]byte, index *big.Int) (common.Address, error) {
	return _PayableAvaLido.Contract.GetRoleMember(&_PayableAvaLido.CallOpts, role, index)
}

// GetRoleMember is a free data retrieval call binding the contract method 0x9010d07c.
//
// Solidity: function getRoleMember(bytes32 role, uint256 index) view returns(address)
func (_PayableAvaLido *PayableAvaLidoCallerSession) GetRoleMember(role [32]byte, index *big.Int) (common.Address, error) {
	return _PayableAvaLido.Contract.GetRoleMember(&_PayableAvaLido.CallOpts, role, index)
}

// GetRoleMemberCount is a free data retrieval call binding the contract method 0xca15c873.
//
// Solidity: function getRoleMemberCount(bytes32 role) view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCaller) GetRoleMemberCount(opts *bind.CallOpts, role [32]byte) (*big.Int, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "getRoleMemberCount", role)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetRoleMemberCount is a free data retrieval call binding the contract method 0xca15c873.
//
// Solidity: function getRoleMemberCount(bytes32 role) view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoSession) GetRoleMemberCount(role [32]byte) (*big.Int, error) {
	return _PayableAvaLido.Contract.GetRoleMemberCount(&_PayableAvaLido.CallOpts, role)
}

// GetRoleMemberCount is a free data retrieval call binding the contract method 0xca15c873.
//
// Solidity: function getRoleMemberCount(bytes32 role) view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCallerSession) GetRoleMemberCount(role [32]byte) (*big.Int, error) {
	return _PayableAvaLido.Contract.GetRoleMemberCount(&_PayableAvaLido.CallOpts, role)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_PayableAvaLido *PayableAvaLidoCaller) HasRole(opts *bind.CallOpts, role [32]byte, account common.Address) (bool, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "hasRole", role, account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_PayableAvaLido *PayableAvaLidoSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _PayableAvaLido.Contract.HasRole(&_PayableAvaLido.CallOpts, role, account)
}

// HasRole is a free data retrieval call binding the contract method 0x91d14854.
//
// Solidity: function hasRole(bytes32 role, address account) view returns(bool)
func (_PayableAvaLido *PayableAvaLidoCallerSession) HasRole(role [32]byte, account common.Address) (bool, error) {
	return _PayableAvaLido.Contract.HasRole(&_PayableAvaLido.CallOpts, role, account)
}

// MaxProtocolControlledAVAX is a free data retrieval call binding the contract method 0x53524303.
//
// Solidity: function maxProtocolControlledAVAX() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCaller) MaxProtocolControlledAVAX(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "maxProtocolControlledAVAX")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MaxProtocolControlledAVAX is a free data retrieval call binding the contract method 0x53524303.
//
// Solidity: function maxProtocolControlledAVAX() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoSession) MaxProtocolControlledAVAX() (*big.Int, error) {
	return _PayableAvaLido.Contract.MaxProtocolControlledAVAX(&_PayableAvaLido.CallOpts)
}

// MaxProtocolControlledAVAX is a free data retrieval call binding the contract method 0x53524303.
//
// Solidity: function maxProtocolControlledAVAX() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCallerSession) MaxProtocolControlledAVAX() (*big.Int, error) {
	return _PayableAvaLido.Contract.MaxProtocolControlledAVAX(&_PayableAvaLido.CallOpts)
}

// MaxUnstakeRequests is a free data retrieval call binding the contract method 0xa7602c7e.
//
// Solidity: function maxUnstakeRequests() view returns(uint8)
func (_PayableAvaLido *PayableAvaLidoCaller) MaxUnstakeRequests(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "maxUnstakeRequests")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// MaxUnstakeRequests is a free data retrieval call binding the contract method 0xa7602c7e.
//
// Solidity: function maxUnstakeRequests() view returns(uint8)
func (_PayableAvaLido *PayableAvaLidoSession) MaxUnstakeRequests() (uint8, error) {
	return _PayableAvaLido.Contract.MaxUnstakeRequests(&_PayableAvaLido.CallOpts)
}

// MaxUnstakeRequests is a free data retrieval call binding the contract method 0xa7602c7e.
//
// Solidity: function maxUnstakeRequests() view returns(uint8)
func (_PayableAvaLido *PayableAvaLidoCallerSession) MaxUnstakeRequests() (uint8, error) {
	return _PayableAvaLido.Contract.MaxUnstakeRequests(&_PayableAvaLido.CallOpts)
}

// MinStakeAmount is a free data retrieval call binding the contract method 0xf1887684.
//
// Solidity: function minStakeAmount() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCaller) MinStakeAmount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "minStakeAmount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinStakeAmount is a free data retrieval call binding the contract method 0xf1887684.
//
// Solidity: function minStakeAmount() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoSession) MinStakeAmount() (*big.Int, error) {
	return _PayableAvaLido.Contract.MinStakeAmount(&_PayableAvaLido.CallOpts)
}

// MinStakeAmount is a free data retrieval call binding the contract method 0xf1887684.
//
// Solidity: function minStakeAmount() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCallerSession) MinStakeAmount() (*big.Int, error) {
	return _PayableAvaLido.Contract.MinStakeAmount(&_PayableAvaLido.CallOpts)
}

// MinStakeBatchAmount is a free data retrieval call binding the contract method 0xad1497fa.
//
// Solidity: function minStakeBatchAmount() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCaller) MinStakeBatchAmount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "minStakeBatchAmount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinStakeBatchAmount is a free data retrieval call binding the contract method 0xad1497fa.
//
// Solidity: function minStakeBatchAmount() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoSession) MinStakeBatchAmount() (*big.Int, error) {
	return _PayableAvaLido.Contract.MinStakeBatchAmount(&_PayableAvaLido.CallOpts)
}

// MinStakeBatchAmount is a free data retrieval call binding the contract method 0xad1497fa.
//
// Solidity: function minStakeBatchAmount() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCallerSession) MinStakeBatchAmount() (*big.Int, error) {
	return _PayableAvaLido.Contract.MinStakeBatchAmount(&_PayableAvaLido.CallOpts)
}

// MpcManager is a free data retrieval call binding the contract method 0x846b3c8b.
//
// Solidity: function mpcManager() view returns(address)
func (_PayableAvaLido *PayableAvaLidoCaller) MpcManager(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "mpcManager")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// MpcManager is a free data retrieval call binding the contract method 0x846b3c8b.
//
// Solidity: function mpcManager() view returns(address)
func (_PayableAvaLido *PayableAvaLidoSession) MpcManager() (common.Address, error) {
	return _PayableAvaLido.Contract.MpcManager(&_PayableAvaLido.CallOpts)
}

// MpcManager is a free data retrieval call binding the contract method 0x846b3c8b.
//
// Solidity: function mpcManager() view returns(address)
func (_PayableAvaLido *PayableAvaLidoCallerSession) MpcManager() (common.Address, error) {
	return _PayableAvaLido.Contract.MpcManager(&_PayableAvaLido.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_PayableAvaLido *PayableAvaLidoCaller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_PayableAvaLido *PayableAvaLidoSession) Name() (string, error) {
	return _PayableAvaLido.Contract.Name(&_PayableAvaLido.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_PayableAvaLido *PayableAvaLidoCallerSession) Name() (string, error) {
	return _PayableAvaLido.Contract.Name(&_PayableAvaLido.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_PayableAvaLido *PayableAvaLidoCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_PayableAvaLido *PayableAvaLidoSession) Paused() (bool, error) {
	return _PayableAvaLido.Contract.Paused(&_PayableAvaLido.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_PayableAvaLido *PayableAvaLidoCallerSession) Paused() (bool, error) {
	return _PayableAvaLido.Contract.Paused(&_PayableAvaLido.CallOpts)
}

// PrincipalTreasury is a free data retrieval call binding the contract method 0x1c0fc3f6.
//
// Solidity: function principalTreasury() view returns(address)
func (_PayableAvaLido *PayableAvaLidoCaller) PrincipalTreasury(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "principalTreasury")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// PrincipalTreasury is a free data retrieval call binding the contract method 0x1c0fc3f6.
//
// Solidity: function principalTreasury() view returns(address)
func (_PayableAvaLido *PayableAvaLidoSession) PrincipalTreasury() (common.Address, error) {
	return _PayableAvaLido.Contract.PrincipalTreasury(&_PayableAvaLido.CallOpts)
}

// PrincipalTreasury is a free data retrieval call binding the contract method 0x1c0fc3f6.
//
// Solidity: function principalTreasury() view returns(address)
func (_PayableAvaLido *PayableAvaLidoCallerSession) PrincipalTreasury() (common.Address, error) {
	return _PayableAvaLido.Contract.PrincipalTreasury(&_PayableAvaLido.CallOpts)
}

// ProtocolControlledAVAX is a free data retrieval call binding the contract method 0xa23b4965.
//
// Solidity: function protocolControlledAVAX() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCaller) ProtocolControlledAVAX(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "protocolControlledAVAX")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ProtocolControlledAVAX is a free data retrieval call binding the contract method 0xa23b4965.
//
// Solidity: function protocolControlledAVAX() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoSession) ProtocolControlledAVAX() (*big.Int, error) {
	return _PayableAvaLido.Contract.ProtocolControlledAVAX(&_PayableAvaLido.CallOpts)
}

// ProtocolControlledAVAX is a free data retrieval call binding the contract method 0xa23b4965.
//
// Solidity: function protocolControlledAVAX() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCallerSession) ProtocolControlledAVAX() (*big.Int, error) {
	return _PayableAvaLido.Contract.ProtocolControlledAVAX(&_PayableAvaLido.CallOpts)
}

// ProtocolFeePercentage is a free data retrieval call binding the contract method 0x8e50e509.
//
// Solidity: function protocolFeePercentage() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCaller) ProtocolFeePercentage(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "protocolFeePercentage")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ProtocolFeePercentage is a free data retrieval call binding the contract method 0x8e50e509.
//
// Solidity: function protocolFeePercentage() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoSession) ProtocolFeePercentage() (*big.Int, error) {
	return _PayableAvaLido.Contract.ProtocolFeePercentage(&_PayableAvaLido.CallOpts)
}

// ProtocolFeePercentage is a free data retrieval call binding the contract method 0x8e50e509.
//
// Solidity: function protocolFeePercentage() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCallerSession) ProtocolFeePercentage() (*big.Int, error) {
	return _PayableAvaLido.Contract.ProtocolFeePercentage(&_PayableAvaLido.CallOpts)
}

// ProtocolFeeSplitter is a free data retrieval call binding the contract method 0x9d7710a5.
//
// Solidity: function protocolFeeSplitter() view returns(address)
func (_PayableAvaLido *PayableAvaLidoCaller) ProtocolFeeSplitter(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "protocolFeeSplitter")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// ProtocolFeeSplitter is a free data retrieval call binding the contract method 0x9d7710a5.
//
// Solidity: function protocolFeeSplitter() view returns(address)
func (_PayableAvaLido *PayableAvaLidoSession) ProtocolFeeSplitter() (common.Address, error) {
	return _PayableAvaLido.Contract.ProtocolFeeSplitter(&_PayableAvaLido.CallOpts)
}

// ProtocolFeeSplitter is a free data retrieval call binding the contract method 0x9d7710a5.
//
// Solidity: function protocolFeeSplitter() view returns(address)
func (_PayableAvaLido *PayableAvaLidoCallerSession) ProtocolFeeSplitter() (common.Address, error) {
	return _PayableAvaLido.Contract.ProtocolFeeSplitter(&_PayableAvaLido.CallOpts)
}

// RequestByIndex is a free data retrieval call binding the contract method 0x3d3da6ef.
//
// Solidity: function requestByIndex(uint256 requestIndex) view returns((address,uint64,uint256,uint256,uint256,uint256))
func (_PayableAvaLido *PayableAvaLidoCaller) RequestByIndex(opts *bind.CallOpts, requestIndex *big.Int) (UnstakeRequest, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "requestByIndex", requestIndex)

	if err != nil {
		return *new(UnstakeRequest), err
	}

	out0 := *abi.ConvertType(out[0], new(UnstakeRequest)).(*UnstakeRequest)

	return out0, err

}

// RequestByIndex is a free data retrieval call binding the contract method 0x3d3da6ef.
//
// Solidity: function requestByIndex(uint256 requestIndex) view returns((address,uint64,uint256,uint256,uint256,uint256))
func (_PayableAvaLido *PayableAvaLidoSession) RequestByIndex(requestIndex *big.Int) (UnstakeRequest, error) {
	return _PayableAvaLido.Contract.RequestByIndex(&_PayableAvaLido.CallOpts, requestIndex)
}

// RequestByIndex is a free data retrieval call binding the contract method 0x3d3da6ef.
//
// Solidity: function requestByIndex(uint256 requestIndex) view returns((address,uint64,uint256,uint256,uint256,uint256))
func (_PayableAvaLido *PayableAvaLidoCallerSession) RequestByIndex(requestIndex *big.Int) (UnstakeRequest, error) {
	return _PayableAvaLido.Contract.RequestByIndex(&_PayableAvaLido.CallOpts, requestIndex)
}

// RewardTreasury is a free data retrieval call binding the contract method 0xc7c934a1.
//
// Solidity: function rewardTreasury() view returns(address)
func (_PayableAvaLido *PayableAvaLidoCaller) RewardTreasury(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "rewardTreasury")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// RewardTreasury is a free data retrieval call binding the contract method 0xc7c934a1.
//
// Solidity: function rewardTreasury() view returns(address)
func (_PayableAvaLido *PayableAvaLidoSession) RewardTreasury() (common.Address, error) {
	return _PayableAvaLido.Contract.RewardTreasury(&_PayableAvaLido.CallOpts)
}

// RewardTreasury is a free data retrieval call binding the contract method 0xc7c934a1.
//
// Solidity: function rewardTreasury() view returns(address)
func (_PayableAvaLido *PayableAvaLidoCallerSession) RewardTreasury() (common.Address, error) {
	return _PayableAvaLido.Contract.RewardTreasury(&_PayableAvaLido.CallOpts)
}

// StAVAXToAVAX is a free data retrieval call binding the contract method 0xbc56684a.
//
// Solidity: function stAVAXToAVAX(uint256 totalControlled, uint256 stAvaxAmount) view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCaller) StAVAXToAVAX(opts *bind.CallOpts, totalControlled *big.Int, stAvaxAmount *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "stAVAXToAVAX", totalControlled, stAvaxAmount)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// StAVAXToAVAX is a free data retrieval call binding the contract method 0xbc56684a.
//
// Solidity: function stAVAXToAVAX(uint256 totalControlled, uint256 stAvaxAmount) view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoSession) StAVAXToAVAX(totalControlled *big.Int, stAvaxAmount *big.Int) (*big.Int, error) {
	return _PayableAvaLido.Contract.StAVAXToAVAX(&_PayableAvaLido.CallOpts, totalControlled, stAvaxAmount)
}

// StAVAXToAVAX is a free data retrieval call binding the contract method 0xbc56684a.
//
// Solidity: function stAVAXToAVAX(uint256 totalControlled, uint256 stAvaxAmount) view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCallerSession) StAVAXToAVAX(totalControlled *big.Int, stAvaxAmount *big.Int) (*big.Int, error) {
	return _PayableAvaLido.Contract.StAVAXToAVAX(&_PayableAvaLido.CallOpts, totalControlled, stAvaxAmount)
}

// StakePeriod is a free data retrieval call binding the contract method 0xc1699a99.
//
// Solidity: function stakePeriod() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCaller) StakePeriod(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "stakePeriod")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// StakePeriod is a free data retrieval call binding the contract method 0xc1699a99.
//
// Solidity: function stakePeriod() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoSession) StakePeriod() (*big.Int, error) {
	return _PayableAvaLido.Contract.StakePeriod(&_PayableAvaLido.CallOpts)
}

// StakePeriod is a free data retrieval call binding the contract method 0xc1699a99.
//
// Solidity: function stakePeriod() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCallerSession) StakePeriod() (*big.Int, error) {
	return _PayableAvaLido.Contract.StakePeriod(&_PayableAvaLido.CallOpts)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_PayableAvaLido *PayableAvaLidoCaller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_PayableAvaLido *PayableAvaLidoSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _PayableAvaLido.Contract.SupportsInterface(&_PayableAvaLido.CallOpts, interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 interfaceId) view returns(bool)
func (_PayableAvaLido *PayableAvaLidoCallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _PayableAvaLido.Contract.SupportsInterface(&_PayableAvaLido.CallOpts, interfaceId)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_PayableAvaLido *PayableAvaLidoCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_PayableAvaLido *PayableAvaLidoSession) Symbol() (string, error) {
	return _PayableAvaLido.Contract.Symbol(&_PayableAvaLido.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_PayableAvaLido *PayableAvaLidoCallerSession) Symbol() (string, error) {
	return _PayableAvaLido.Contract.Symbol(&_PayableAvaLido.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoSession) TotalSupply() (*big.Int, error) {
	return _PayableAvaLido.Contract.TotalSupply(&_PayableAvaLido.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_PayableAvaLido *PayableAvaLidoCallerSession) TotalSupply() (*big.Int, error) {
	return _PayableAvaLido.Contract.TotalSupply(&_PayableAvaLido.CallOpts)
}

// UnstakeRequestCount is a free data retrieval call binding the contract method 0xad874808.
//
// Solidity: function unstakeRequestCount(address ) view returns(uint8)
func (_PayableAvaLido *PayableAvaLidoCaller) UnstakeRequestCount(opts *bind.CallOpts, arg0 common.Address) (uint8, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "unstakeRequestCount", arg0)

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// UnstakeRequestCount is a free data retrieval call binding the contract method 0xad874808.
//
// Solidity: function unstakeRequestCount(address ) view returns(uint8)
func (_PayableAvaLido *PayableAvaLidoSession) UnstakeRequestCount(arg0 common.Address) (uint8, error) {
	return _PayableAvaLido.Contract.UnstakeRequestCount(&_PayableAvaLido.CallOpts, arg0)
}

// UnstakeRequestCount is a free data retrieval call binding the contract method 0xad874808.
//
// Solidity: function unstakeRequestCount(address ) view returns(uint8)
func (_PayableAvaLido *PayableAvaLidoCallerSession) UnstakeRequestCount(arg0 common.Address) (uint8, error) {
	return _PayableAvaLido.Contract.UnstakeRequestCount(&_PayableAvaLido.CallOpts, arg0)
}

// UnstakeRequests is a free data retrieval call binding the contract method 0xf87975af.
//
// Solidity: function unstakeRequests(uint256 ) view returns(address requester, uint64 requestedAt, uint256 amountRequested, uint256 amountFilled, uint256 amountClaimed, uint256 stAVAXLocked)
func (_PayableAvaLido *PayableAvaLidoCaller) UnstakeRequests(opts *bind.CallOpts, arg0 *big.Int) (struct {
	Requester       common.Address
	RequestedAt     uint64
	AmountRequested *big.Int
	AmountFilled    *big.Int
	AmountClaimed   *big.Int
	StAVAXLocked    *big.Int
}, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "unstakeRequests", arg0)

	outstruct := new(struct {
		Requester       common.Address
		RequestedAt     uint64
		AmountRequested *big.Int
		AmountFilled    *big.Int
		AmountClaimed   *big.Int
		StAVAXLocked    *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Requester = *abi.ConvertType(out[0], new(common.Address)).(*common.Address)
	outstruct.RequestedAt = *abi.ConvertType(out[1], new(uint64)).(*uint64)
	outstruct.AmountRequested = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.AmountFilled = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)
	outstruct.AmountClaimed = *abi.ConvertType(out[4], new(*big.Int)).(**big.Int)
	outstruct.StAVAXLocked = *abi.ConvertType(out[5], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// UnstakeRequests is a free data retrieval call binding the contract method 0xf87975af.
//
// Solidity: function unstakeRequests(uint256 ) view returns(address requester, uint64 requestedAt, uint256 amountRequested, uint256 amountFilled, uint256 amountClaimed, uint256 stAVAXLocked)
func (_PayableAvaLido *PayableAvaLidoSession) UnstakeRequests(arg0 *big.Int) (struct {
	Requester       common.Address
	RequestedAt     uint64
	AmountRequested *big.Int
	AmountFilled    *big.Int
	AmountClaimed   *big.Int
	StAVAXLocked    *big.Int
}, error) {
	return _PayableAvaLido.Contract.UnstakeRequests(&_PayableAvaLido.CallOpts, arg0)
}

// UnstakeRequests is a free data retrieval call binding the contract method 0xf87975af.
//
// Solidity: function unstakeRequests(uint256 ) view returns(address requester, uint64 requestedAt, uint256 amountRequested, uint256 amountFilled, uint256 amountClaimed, uint256 stAVAXLocked)
func (_PayableAvaLido *PayableAvaLidoCallerSession) UnstakeRequests(arg0 *big.Int) (struct {
	Requester       common.Address
	RequestedAt     uint64
	AmountRequested *big.Int
	AmountFilled    *big.Int
	AmountClaimed   *big.Int
	StAVAXLocked    *big.Int
}, error) {
	return _PayableAvaLido.Contract.UnstakeRequests(&_PayableAvaLido.CallOpts, arg0)
}

// ValidatorSelector is a free data retrieval call binding the contract method 0xe039e3cc.
//
// Solidity: function validatorSelector() view returns(address)
func (_PayableAvaLido *PayableAvaLidoCaller) ValidatorSelector(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _PayableAvaLido.contract.Call(opts, &out, "validatorSelector")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// ValidatorSelector is a free data retrieval call binding the contract method 0xe039e3cc.
//
// Solidity: function validatorSelector() view returns(address)
func (_PayableAvaLido *PayableAvaLidoSession) ValidatorSelector() (common.Address, error) {
	return _PayableAvaLido.Contract.ValidatorSelector(&_PayableAvaLido.CallOpts)
}

// ValidatorSelector is a free data retrieval call binding the contract method 0xe039e3cc.
//
// Solidity: function validatorSelector() view returns(address)
func (_PayableAvaLido *PayableAvaLidoCallerSession) ValidatorSelector() (common.Address, error) {
	return _PayableAvaLido.Contract.ValidatorSelector(&_PayableAvaLido.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_PayableAvaLido *PayableAvaLidoTransactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_PayableAvaLido *PayableAvaLidoSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.Approve(&_PayableAvaLido.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_PayableAvaLido *PayableAvaLidoTransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.Approve(&_PayableAvaLido.TransactOpts, spender, amount)
}

// Claim is a paid mutator transaction binding the contract method 0xc3490263.
//
// Solidity: function claim(uint256 requestIndex, uint256 amount) returns()
func (_PayableAvaLido *PayableAvaLidoTransactor) Claim(opts *bind.TransactOpts, requestIndex *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "claim", requestIndex, amount)
}

// Claim is a paid mutator transaction binding the contract method 0xc3490263.
//
// Solidity: function claim(uint256 requestIndex, uint256 amount) returns()
func (_PayableAvaLido *PayableAvaLidoSession) Claim(requestIndex *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.Claim(&_PayableAvaLido.TransactOpts, requestIndex, amount)
}

// Claim is a paid mutator transaction binding the contract method 0xc3490263.
//
// Solidity: function claim(uint256 requestIndex, uint256 amount) returns()
func (_PayableAvaLido *PayableAvaLidoTransactorSession) Claim(requestIndex *big.Int, amount *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.Claim(&_PayableAvaLido.TransactOpts, requestIndex, amount)
}

// ClaimRewards is a paid mutator transaction binding the contract method 0x372500ab.
//
// Solidity: function claimRewards() returns()
func (_PayableAvaLido *PayableAvaLidoTransactor) ClaimRewards(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "claimRewards")
}

// ClaimRewards is a paid mutator transaction binding the contract method 0x372500ab.
//
// Solidity: function claimRewards() returns()
func (_PayableAvaLido *PayableAvaLidoSession) ClaimRewards() (*types.Transaction, error) {
	return _PayableAvaLido.Contract.ClaimRewards(&_PayableAvaLido.TransactOpts)
}

// ClaimRewards is a paid mutator transaction binding the contract method 0x372500ab.
//
// Solidity: function claimRewards() returns()
func (_PayableAvaLido *PayableAvaLidoTransactorSession) ClaimRewards() (*types.Transaction, error) {
	return _PayableAvaLido.Contract.ClaimRewards(&_PayableAvaLido.TransactOpts)
}

// ClaimUnstakedPrincipals is a paid mutator transaction binding the contract method 0x446ed20b.
//
// Solidity: function claimUnstakedPrincipals() returns()
func (_PayableAvaLido *PayableAvaLidoTransactor) ClaimUnstakedPrincipals(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "claimUnstakedPrincipals")
}

// ClaimUnstakedPrincipals is a paid mutator transaction binding the contract method 0x446ed20b.
//
// Solidity: function claimUnstakedPrincipals() returns()
func (_PayableAvaLido *PayableAvaLidoSession) ClaimUnstakedPrincipals() (*types.Transaction, error) {
	return _PayableAvaLido.Contract.ClaimUnstakedPrincipals(&_PayableAvaLido.TransactOpts)
}

// ClaimUnstakedPrincipals is a paid mutator transaction binding the contract method 0x446ed20b.
//
// Solidity: function claimUnstakedPrincipals() returns()
func (_PayableAvaLido *PayableAvaLidoTransactorSession) ClaimUnstakedPrincipals() (*types.Transaction, error) {
	return _PayableAvaLido.Contract.ClaimUnstakedPrincipals(&_PayableAvaLido.TransactOpts)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_PayableAvaLido *PayableAvaLidoTransactor) DecreaseAllowance(opts *bind.TransactOpts, spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "decreaseAllowance", spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_PayableAvaLido *PayableAvaLidoSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.DecreaseAllowance(&_PayableAvaLido.TransactOpts, spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_PayableAvaLido *PayableAvaLidoTransactorSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.DecreaseAllowance(&_PayableAvaLido.TransactOpts, spender, subtractedValue)
}

// Deposit is a paid mutator transaction binding the contract method 0xd0e30db0.
//
// Solidity: function deposit() payable returns()
func (_PayableAvaLido *PayableAvaLidoTransactor) Deposit(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "deposit")
}

// Deposit is a paid mutator transaction binding the contract method 0xd0e30db0.
//
// Solidity: function deposit() payable returns()
func (_PayableAvaLido *PayableAvaLidoSession) Deposit() (*types.Transaction, error) {
	return _PayableAvaLido.Contract.Deposit(&_PayableAvaLido.TransactOpts)
}

// Deposit is a paid mutator transaction binding the contract method 0xd0e30db0.
//
// Solidity: function deposit() payable returns()
func (_PayableAvaLido *PayableAvaLidoTransactorSession) Deposit() (*types.Transaction, error) {
	return _PayableAvaLido.Contract.Deposit(&_PayableAvaLido.TransactOpts)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_PayableAvaLido *PayableAvaLidoTransactor) GrantRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "grantRole", role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_PayableAvaLido *PayableAvaLidoSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.GrantRole(&_PayableAvaLido.TransactOpts, role, account)
}

// GrantRole is a paid mutator transaction binding the contract method 0x2f2ff15d.
//
// Solidity: function grantRole(bytes32 role, address account) returns()
func (_PayableAvaLido *PayableAvaLidoTransactorSession) GrantRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.GrantRole(&_PayableAvaLido.TransactOpts, role, account)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_PayableAvaLido *PayableAvaLidoTransactor) IncreaseAllowance(opts *bind.TransactOpts, spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "increaseAllowance", spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_PayableAvaLido *PayableAvaLidoSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.IncreaseAllowance(&_PayableAvaLido.TransactOpts, spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_PayableAvaLido *PayableAvaLidoTransactorSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.IncreaseAllowance(&_PayableAvaLido.TransactOpts, spender, addedValue)
}

// Initialize is a paid mutator transaction binding the contract method 0xf8c8765e.
//
// Solidity: function initialize(address lidoFeeAddress, address authorFeeAddress, address validatorSelectorAddress, address _mpcManagerAddress) returns()
func (_PayableAvaLido *PayableAvaLidoTransactor) Initialize(opts *bind.TransactOpts, lidoFeeAddress common.Address, authorFeeAddress common.Address, validatorSelectorAddress common.Address, _mpcManagerAddress common.Address) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "initialize", lidoFeeAddress, authorFeeAddress, validatorSelectorAddress, _mpcManagerAddress)
}

// Initialize is a paid mutator transaction binding the contract method 0xf8c8765e.
//
// Solidity: function initialize(address lidoFeeAddress, address authorFeeAddress, address validatorSelectorAddress, address _mpcManagerAddress) returns()
func (_PayableAvaLido *PayableAvaLidoSession) Initialize(lidoFeeAddress common.Address, authorFeeAddress common.Address, validatorSelectorAddress common.Address, _mpcManagerAddress common.Address) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.Initialize(&_PayableAvaLido.TransactOpts, lidoFeeAddress, authorFeeAddress, validatorSelectorAddress, _mpcManagerAddress)
}

// Initialize is a paid mutator transaction binding the contract method 0xf8c8765e.
//
// Solidity: function initialize(address lidoFeeAddress, address authorFeeAddress, address validatorSelectorAddress, address _mpcManagerAddress) returns()
func (_PayableAvaLido *PayableAvaLidoTransactorSession) Initialize(lidoFeeAddress common.Address, authorFeeAddress common.Address, validatorSelectorAddress common.Address, _mpcManagerAddress common.Address) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.Initialize(&_PayableAvaLido.TransactOpts, lidoFeeAddress, authorFeeAddress, validatorSelectorAddress, _mpcManagerAddress)
}

// InitiateStake is a paid mutator transaction binding the contract method 0xdb4567d3.
//
// Solidity: function initiateStake() returns(uint256)
func (_PayableAvaLido *PayableAvaLidoTransactor) InitiateStake(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "initiateStake")
}

// InitiateStake is a paid mutator transaction binding the contract method 0xdb4567d3.
//
// Solidity: function initiateStake() returns(uint256)
func (_PayableAvaLido *PayableAvaLidoSession) InitiateStake() (*types.Transaction, error) {
	return _PayableAvaLido.Contract.InitiateStake(&_PayableAvaLido.TransactOpts)
}

// InitiateStake is a paid mutator transaction binding the contract method 0xdb4567d3.
//
// Solidity: function initiateStake() returns(uint256)
func (_PayableAvaLido *PayableAvaLidoTransactorSession) InitiateStake() (*types.Transaction, error) {
	return _PayableAvaLido.Contract.InitiateStake(&_PayableAvaLido.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_PayableAvaLido *PayableAvaLidoTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_PayableAvaLido *PayableAvaLidoSession) Pause() (*types.Transaction, error) {
	return _PayableAvaLido.Contract.Pause(&_PayableAvaLido.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_PayableAvaLido *PayableAvaLidoTransactorSession) Pause() (*types.Transaction, error) {
	return _PayableAvaLido.Contract.Pause(&_PayableAvaLido.TransactOpts)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_PayableAvaLido *PayableAvaLidoTransactor) RenounceRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "renounceRole", role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_PayableAvaLido *PayableAvaLidoSession) RenounceRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.RenounceRole(&_PayableAvaLido.TransactOpts, role, account)
}

// RenounceRole is a paid mutator transaction binding the contract method 0x36568abe.
//
// Solidity: function renounceRole(bytes32 role, address account) returns()
func (_PayableAvaLido *PayableAvaLidoTransactorSession) RenounceRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.RenounceRole(&_PayableAvaLido.TransactOpts, role, account)
}

// RequestWithdrawal is a paid mutator transaction binding the contract method 0x9ee679e8.
//
// Solidity: function requestWithdrawal(uint256 stAVAXAmount) returns(uint256)
func (_PayableAvaLido *PayableAvaLidoTransactor) RequestWithdrawal(opts *bind.TransactOpts, stAVAXAmount *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "requestWithdrawal", stAVAXAmount)
}

// RequestWithdrawal is a paid mutator transaction binding the contract method 0x9ee679e8.
//
// Solidity: function requestWithdrawal(uint256 stAVAXAmount) returns(uint256)
func (_PayableAvaLido *PayableAvaLidoSession) RequestWithdrawal(stAVAXAmount *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.RequestWithdrawal(&_PayableAvaLido.TransactOpts, stAVAXAmount)
}

// RequestWithdrawal is a paid mutator transaction binding the contract method 0x9ee679e8.
//
// Solidity: function requestWithdrawal(uint256 stAVAXAmount) returns(uint256)
func (_PayableAvaLido *PayableAvaLidoTransactorSession) RequestWithdrawal(stAVAXAmount *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.RequestWithdrawal(&_PayableAvaLido.TransactOpts, stAVAXAmount)
}

// Resume is a paid mutator transaction binding the contract method 0x046f7da2.
//
// Solidity: function resume() returns()
func (_PayableAvaLido *PayableAvaLidoTransactor) Resume(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "resume")
}

// Resume is a paid mutator transaction binding the contract method 0x046f7da2.
//
// Solidity: function resume() returns()
func (_PayableAvaLido *PayableAvaLidoSession) Resume() (*types.Transaction, error) {
	return _PayableAvaLido.Contract.Resume(&_PayableAvaLido.TransactOpts)
}

// Resume is a paid mutator transaction binding the contract method 0x046f7da2.
//
// Solidity: function resume() returns()
func (_PayableAvaLido *PayableAvaLidoTransactorSession) Resume() (*types.Transaction, error) {
	return _PayableAvaLido.Contract.Resume(&_PayableAvaLido.TransactOpts)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_PayableAvaLido *PayableAvaLidoTransactor) RevokeRole(opts *bind.TransactOpts, role [32]byte, account common.Address) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "revokeRole", role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_PayableAvaLido *PayableAvaLidoSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.RevokeRole(&_PayableAvaLido.TransactOpts, role, account)
}

// RevokeRole is a paid mutator transaction binding the contract method 0xd547741f.
//
// Solidity: function revokeRole(bytes32 role, address account) returns()
func (_PayableAvaLido *PayableAvaLidoTransactorSession) RevokeRole(role [32]byte, account common.Address) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.RevokeRole(&_PayableAvaLido.TransactOpts, role, account)
}

// SetMaxProtocolControlledAVAX is a paid mutator transaction binding the contract method 0x818a8e4c.
//
// Solidity: function setMaxProtocolControlledAVAX(uint256 _maxProtocolControlledAVAX) returns()
func (_PayableAvaLido *PayableAvaLidoTransactor) SetMaxProtocolControlledAVAX(opts *bind.TransactOpts, _maxProtocolControlledAVAX *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "setMaxProtocolControlledAVAX", _maxProtocolControlledAVAX)
}

// SetMaxProtocolControlledAVAX is a paid mutator transaction binding the contract method 0x818a8e4c.
//
// Solidity: function setMaxProtocolControlledAVAX(uint256 _maxProtocolControlledAVAX) returns()
func (_PayableAvaLido *PayableAvaLidoSession) SetMaxProtocolControlledAVAX(_maxProtocolControlledAVAX *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.SetMaxProtocolControlledAVAX(&_PayableAvaLido.TransactOpts, _maxProtocolControlledAVAX)
}

// SetMaxProtocolControlledAVAX is a paid mutator transaction binding the contract method 0x818a8e4c.
//
// Solidity: function setMaxProtocolControlledAVAX(uint256 _maxProtocolControlledAVAX) returns()
func (_PayableAvaLido *PayableAvaLidoTransactorSession) SetMaxProtocolControlledAVAX(_maxProtocolControlledAVAX *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.SetMaxProtocolControlledAVAX(&_PayableAvaLido.TransactOpts, _maxProtocolControlledAVAX)
}

// SetMaxUnstakeRequests is a paid mutator transaction binding the contract method 0x1031eb9c.
//
// Solidity: function setMaxUnstakeRequests(uint8 _maxUnstakeRequests) returns()
func (_PayableAvaLido *PayableAvaLidoTransactor) SetMaxUnstakeRequests(opts *bind.TransactOpts, _maxUnstakeRequests uint8) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "setMaxUnstakeRequests", _maxUnstakeRequests)
}

// SetMaxUnstakeRequests is a paid mutator transaction binding the contract method 0x1031eb9c.
//
// Solidity: function setMaxUnstakeRequests(uint8 _maxUnstakeRequests) returns()
func (_PayableAvaLido *PayableAvaLidoSession) SetMaxUnstakeRequests(_maxUnstakeRequests uint8) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.SetMaxUnstakeRequests(&_PayableAvaLido.TransactOpts, _maxUnstakeRequests)
}

// SetMaxUnstakeRequests is a paid mutator transaction binding the contract method 0x1031eb9c.
//
// Solidity: function setMaxUnstakeRequests(uint8 _maxUnstakeRequests) returns()
func (_PayableAvaLido *PayableAvaLidoTransactorSession) SetMaxUnstakeRequests(_maxUnstakeRequests uint8) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.SetMaxUnstakeRequests(&_PayableAvaLido.TransactOpts, _maxUnstakeRequests)
}

// SetMinStakeAmount is a paid mutator transaction binding the contract method 0xeb4af045.
//
// Solidity: function setMinStakeAmount(uint256 _minStakeAmount) returns()
func (_PayableAvaLido *PayableAvaLidoTransactor) SetMinStakeAmount(opts *bind.TransactOpts, _minStakeAmount *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "setMinStakeAmount", _minStakeAmount)
}

// SetMinStakeAmount is a paid mutator transaction binding the contract method 0xeb4af045.
//
// Solidity: function setMinStakeAmount(uint256 _minStakeAmount) returns()
func (_PayableAvaLido *PayableAvaLidoSession) SetMinStakeAmount(_minStakeAmount *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.SetMinStakeAmount(&_PayableAvaLido.TransactOpts, _minStakeAmount)
}

// SetMinStakeAmount is a paid mutator transaction binding the contract method 0xeb4af045.
//
// Solidity: function setMinStakeAmount(uint256 _minStakeAmount) returns()
func (_PayableAvaLido *PayableAvaLidoTransactorSession) SetMinStakeAmount(_minStakeAmount *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.SetMinStakeAmount(&_PayableAvaLido.TransactOpts, _minStakeAmount)
}

// SetMinStakeBatchAmount is a paid mutator transaction binding the contract method 0x262b1f9e.
//
// Solidity: function setMinStakeBatchAmount(uint256 _minStakeBatchAmount) returns()
func (_PayableAvaLido *PayableAvaLidoTransactor) SetMinStakeBatchAmount(opts *bind.TransactOpts, _minStakeBatchAmount *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "setMinStakeBatchAmount", _minStakeBatchAmount)
}

// SetMinStakeBatchAmount is a paid mutator transaction binding the contract method 0x262b1f9e.
//
// Solidity: function setMinStakeBatchAmount(uint256 _minStakeBatchAmount) returns()
func (_PayableAvaLido *PayableAvaLidoSession) SetMinStakeBatchAmount(_minStakeBatchAmount *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.SetMinStakeBatchAmount(&_PayableAvaLido.TransactOpts, _minStakeBatchAmount)
}

// SetMinStakeBatchAmount is a paid mutator transaction binding the contract method 0x262b1f9e.
//
// Solidity: function setMinStakeBatchAmount(uint256 _minStakeBatchAmount) returns()
func (_PayableAvaLido *PayableAvaLidoTransactorSession) SetMinStakeBatchAmount(_minStakeBatchAmount *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.SetMinStakeBatchAmount(&_PayableAvaLido.TransactOpts, _minStakeBatchAmount)
}

// SetPrincipalTreasuryAddress is a paid mutator transaction binding the contract method 0xd1f8aaac.
//
// Solidity: function setPrincipalTreasuryAddress(address _address) returns()
func (_PayableAvaLido *PayableAvaLidoTransactor) SetPrincipalTreasuryAddress(opts *bind.TransactOpts, _address common.Address) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "setPrincipalTreasuryAddress", _address)
}

// SetPrincipalTreasuryAddress is a paid mutator transaction binding the contract method 0xd1f8aaac.
//
// Solidity: function setPrincipalTreasuryAddress(address _address) returns()
func (_PayableAvaLido *PayableAvaLidoSession) SetPrincipalTreasuryAddress(_address common.Address) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.SetPrincipalTreasuryAddress(&_PayableAvaLido.TransactOpts, _address)
}

// SetPrincipalTreasuryAddress is a paid mutator transaction binding the contract method 0xd1f8aaac.
//
// Solidity: function setPrincipalTreasuryAddress(address _address) returns()
func (_PayableAvaLido *PayableAvaLidoTransactorSession) SetPrincipalTreasuryAddress(_address common.Address) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.SetPrincipalTreasuryAddress(&_PayableAvaLido.TransactOpts, _address)
}

// SetProtocolFeePercentage is a paid mutator transaction binding the contract method 0xd8a5e936.
//
// Solidity: function setProtocolFeePercentage(uint256 _protocolFeePercentage) returns()
func (_PayableAvaLido *PayableAvaLidoTransactor) SetProtocolFeePercentage(opts *bind.TransactOpts, _protocolFeePercentage *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "setProtocolFeePercentage", _protocolFeePercentage)
}

// SetProtocolFeePercentage is a paid mutator transaction binding the contract method 0xd8a5e936.
//
// Solidity: function setProtocolFeePercentage(uint256 _protocolFeePercentage) returns()
func (_PayableAvaLido *PayableAvaLidoSession) SetProtocolFeePercentage(_protocolFeePercentage *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.SetProtocolFeePercentage(&_PayableAvaLido.TransactOpts, _protocolFeePercentage)
}

// SetProtocolFeePercentage is a paid mutator transaction binding the contract method 0xd8a5e936.
//
// Solidity: function setProtocolFeePercentage(uint256 _protocolFeePercentage) returns()
func (_PayableAvaLido *PayableAvaLidoTransactorSession) SetProtocolFeePercentage(_protocolFeePercentage *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.SetProtocolFeePercentage(&_PayableAvaLido.TransactOpts, _protocolFeePercentage)
}

// SetProtocolFeeSplit is a paid mutator transaction binding the contract method 0x2659bc15.
//
// Solidity: function setProtocolFeeSplit(address[] paymentAddresses, uint256[] paymentSplit) returns()
func (_PayableAvaLido *PayableAvaLidoTransactor) SetProtocolFeeSplit(opts *bind.TransactOpts, paymentAddresses []common.Address, paymentSplit []*big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "setProtocolFeeSplit", paymentAddresses, paymentSplit)
}

// SetProtocolFeeSplit is a paid mutator transaction binding the contract method 0x2659bc15.
//
// Solidity: function setProtocolFeeSplit(address[] paymentAddresses, uint256[] paymentSplit) returns()
func (_PayableAvaLido *PayableAvaLidoSession) SetProtocolFeeSplit(paymentAddresses []common.Address, paymentSplit []*big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.SetProtocolFeeSplit(&_PayableAvaLido.TransactOpts, paymentAddresses, paymentSplit)
}

// SetProtocolFeeSplit is a paid mutator transaction binding the contract method 0x2659bc15.
//
// Solidity: function setProtocolFeeSplit(address[] paymentAddresses, uint256[] paymentSplit) returns()
func (_PayableAvaLido *PayableAvaLidoTransactorSession) SetProtocolFeeSplit(paymentAddresses []common.Address, paymentSplit []*big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.SetProtocolFeeSplit(&_PayableAvaLido.TransactOpts, paymentAddresses, paymentSplit)
}

// SetRewardTreasuryAddress is a paid mutator transaction binding the contract method 0xcb1045d0.
//
// Solidity: function setRewardTreasuryAddress(address _address) returns()
func (_PayableAvaLido *PayableAvaLidoTransactor) SetRewardTreasuryAddress(opts *bind.TransactOpts, _address common.Address) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "setRewardTreasuryAddress", _address)
}

// SetRewardTreasuryAddress is a paid mutator transaction binding the contract method 0xcb1045d0.
//
// Solidity: function setRewardTreasuryAddress(address _address) returns()
func (_PayableAvaLido *PayableAvaLidoSession) SetRewardTreasuryAddress(_address common.Address) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.SetRewardTreasuryAddress(&_PayableAvaLido.TransactOpts, _address)
}

// SetRewardTreasuryAddress is a paid mutator transaction binding the contract method 0xcb1045d0.
//
// Solidity: function setRewardTreasuryAddress(address _address) returns()
func (_PayableAvaLido *PayableAvaLidoTransactorSession) SetRewardTreasuryAddress(_address common.Address) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.SetRewardTreasuryAddress(&_PayableAvaLido.TransactOpts, _address)
}

// SetStakePeriod is a paid mutator transaction binding the contract method 0x1e6b4c6f.
//
// Solidity: function setStakePeriod(uint256 _stakePeriod) returns()
func (_PayableAvaLido *PayableAvaLidoTransactor) SetStakePeriod(opts *bind.TransactOpts, _stakePeriod *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "setStakePeriod", _stakePeriod)
}

// SetStakePeriod is a paid mutator transaction binding the contract method 0x1e6b4c6f.
//
// Solidity: function setStakePeriod(uint256 _stakePeriod) returns()
func (_PayableAvaLido *PayableAvaLidoSession) SetStakePeriod(_stakePeriod *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.SetStakePeriod(&_PayableAvaLido.TransactOpts, _stakePeriod)
}

// SetStakePeriod is a paid mutator transaction binding the contract method 0x1e6b4c6f.
//
// Solidity: function setStakePeriod(uint256 _stakePeriod) returns()
func (_PayableAvaLido *PayableAvaLidoTransactorSession) SetStakePeriod(_stakePeriod *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.SetStakePeriod(&_PayableAvaLido.TransactOpts, _stakePeriod)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_PayableAvaLido *PayableAvaLidoTransactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_PayableAvaLido *PayableAvaLidoSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.Transfer(&_PayableAvaLido.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_PayableAvaLido *PayableAvaLidoTransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.Transfer(&_PayableAvaLido.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_PayableAvaLido *PayableAvaLidoTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_PayableAvaLido *PayableAvaLidoSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.TransferFrom(&_PayableAvaLido.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_PayableAvaLido *PayableAvaLidoTransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _PayableAvaLido.Contract.TransferFrom(&_PayableAvaLido.TransactOpts, from, to, amount)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_PayableAvaLido *PayableAvaLidoTransactor) Receive(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PayableAvaLido.contract.RawTransact(opts, nil) // calldata is disallowed for receive function
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_PayableAvaLido *PayableAvaLidoSession) Receive() (*types.Transaction, error) {
	return _PayableAvaLido.Contract.Receive(&_PayableAvaLido.TransactOpts)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_PayableAvaLido *PayableAvaLidoTransactorSession) Receive() (*types.Transaction, error) {
	return _PayableAvaLido.Contract.Receive(&_PayableAvaLido.TransactOpts)
}

// PayableAvaLidoApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the PayableAvaLido contract.
type PayableAvaLidoApprovalIterator struct {
	Event *PayableAvaLidoApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PayableAvaLidoApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PayableAvaLidoApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PayableAvaLidoApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PayableAvaLidoApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PayableAvaLidoApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PayableAvaLidoApproval represents a Approval event raised by the PayableAvaLido contract.
type PayableAvaLidoApproval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_PayableAvaLido *PayableAvaLidoFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*PayableAvaLidoApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _PayableAvaLido.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &PayableAvaLidoApprovalIterator{contract: _PayableAvaLido.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_PayableAvaLido *PayableAvaLidoFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *PayableAvaLidoApproval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _PayableAvaLido.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PayableAvaLidoApproval)
				if err := _PayableAvaLido.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_PayableAvaLido *PayableAvaLidoFilterer) ParseApproval(log types.Log) (*PayableAvaLidoApproval, error) {
	event := new(PayableAvaLidoApproval)
	if err := _PayableAvaLido.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PayableAvaLidoClaimEventIterator is returned from FilterClaimEvent and is used to iterate over the raw logs and unpacked data for ClaimEvent events raised by the PayableAvaLido contract.
type PayableAvaLidoClaimEventIterator struct {
	Event *PayableAvaLidoClaimEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PayableAvaLidoClaimEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PayableAvaLidoClaimEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PayableAvaLidoClaimEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PayableAvaLidoClaimEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PayableAvaLidoClaimEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PayableAvaLidoClaimEvent represents a ClaimEvent event raised by the PayableAvaLido contract.
type PayableAvaLidoClaimEvent struct {
	From         common.Address
	ClaimAmount  *big.Int
	FinalClaim   bool
	RequestIndex *big.Int
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterClaimEvent is a free log retrieval operation binding the contract event 0x30694308508a999b8c8335a05cfb5919eb0bd4d9415c29592c8f558145dbfaa5.
//
// Solidity: event ClaimEvent(address indexed from, uint256 claimAmount, bool indexed finalClaim, uint256 requestIndex)
func (_PayableAvaLido *PayableAvaLidoFilterer) FilterClaimEvent(opts *bind.FilterOpts, from []common.Address, finalClaim []bool) (*PayableAvaLidoClaimEventIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	var finalClaimRule []interface{}
	for _, finalClaimItem := range finalClaim {
		finalClaimRule = append(finalClaimRule, finalClaimItem)
	}

	logs, sub, err := _PayableAvaLido.contract.FilterLogs(opts, "ClaimEvent", fromRule, finalClaimRule)
	if err != nil {
		return nil, err
	}
	return &PayableAvaLidoClaimEventIterator{contract: _PayableAvaLido.contract, event: "ClaimEvent", logs: logs, sub: sub}, nil
}

// WatchClaimEvent is a free log subscription operation binding the contract event 0x30694308508a999b8c8335a05cfb5919eb0bd4d9415c29592c8f558145dbfaa5.
//
// Solidity: event ClaimEvent(address indexed from, uint256 claimAmount, bool indexed finalClaim, uint256 requestIndex)
func (_PayableAvaLido *PayableAvaLidoFilterer) WatchClaimEvent(opts *bind.WatchOpts, sink chan<- *PayableAvaLidoClaimEvent, from []common.Address, finalClaim []bool) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	var finalClaimRule []interface{}
	for _, finalClaimItem := range finalClaim {
		finalClaimRule = append(finalClaimRule, finalClaimItem)
	}

	logs, sub, err := _PayableAvaLido.contract.WatchLogs(opts, "ClaimEvent", fromRule, finalClaimRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PayableAvaLidoClaimEvent)
				if err := _PayableAvaLido.contract.UnpackLog(event, "ClaimEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseClaimEvent is a log parse operation binding the contract event 0x30694308508a999b8c8335a05cfb5919eb0bd4d9415c29592c8f558145dbfaa5.
//
// Solidity: event ClaimEvent(address indexed from, uint256 claimAmount, bool indexed finalClaim, uint256 requestIndex)
func (_PayableAvaLido *PayableAvaLidoFilterer) ParseClaimEvent(log types.Log) (*PayableAvaLidoClaimEvent, error) {
	event := new(PayableAvaLidoClaimEvent)
	if err := _PayableAvaLido.contract.UnpackLog(event, "ClaimEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PayableAvaLidoDepositEventIterator is returned from FilterDepositEvent and is used to iterate over the raw logs and unpacked data for DepositEvent events raised by the PayableAvaLido contract.
type PayableAvaLidoDepositEventIterator struct {
	Event *PayableAvaLidoDepositEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PayableAvaLidoDepositEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PayableAvaLidoDepositEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PayableAvaLidoDepositEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PayableAvaLidoDepositEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PayableAvaLidoDepositEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PayableAvaLidoDepositEvent represents a DepositEvent event raised by the PayableAvaLido contract.
type PayableAvaLidoDepositEvent struct {
	From      common.Address
	Amount    *big.Int
	Timestamp *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterDepositEvent is a free log retrieval operation binding the contract event 0xad40ae5dc69974ba932d08b0a608e89109412d41d04850f5196f144875ae2660.
//
// Solidity: event DepositEvent(address indexed from, uint256 amount, uint256 timestamp)
func (_PayableAvaLido *PayableAvaLidoFilterer) FilterDepositEvent(opts *bind.FilterOpts, from []common.Address) (*PayableAvaLidoDepositEventIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _PayableAvaLido.contract.FilterLogs(opts, "DepositEvent", fromRule)
	if err != nil {
		return nil, err
	}
	return &PayableAvaLidoDepositEventIterator{contract: _PayableAvaLido.contract, event: "DepositEvent", logs: logs, sub: sub}, nil
}

// WatchDepositEvent is a free log subscription operation binding the contract event 0xad40ae5dc69974ba932d08b0a608e89109412d41d04850f5196f144875ae2660.
//
// Solidity: event DepositEvent(address indexed from, uint256 amount, uint256 timestamp)
func (_PayableAvaLido *PayableAvaLidoFilterer) WatchDepositEvent(opts *bind.WatchOpts, sink chan<- *PayableAvaLidoDepositEvent, from []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _PayableAvaLido.contract.WatchLogs(opts, "DepositEvent", fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PayableAvaLidoDepositEvent)
				if err := _PayableAvaLido.contract.UnpackLog(event, "DepositEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDepositEvent is a log parse operation binding the contract event 0xad40ae5dc69974ba932d08b0a608e89109412d41d04850f5196f144875ae2660.
//
// Solidity: event DepositEvent(address indexed from, uint256 amount, uint256 timestamp)
func (_PayableAvaLido *PayableAvaLidoFilterer) ParseDepositEvent(log types.Log) (*PayableAvaLidoDepositEvent, error) {
	event := new(PayableAvaLidoDepositEvent)
	if err := _PayableAvaLido.contract.UnpackLog(event, "DepositEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PayableAvaLidoInitializedIterator is returned from FilterInitialized and is used to iterate over the raw logs and unpacked data for Initialized events raised by the PayableAvaLido contract.
type PayableAvaLidoInitializedIterator struct {
	Event *PayableAvaLidoInitialized // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PayableAvaLidoInitializedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PayableAvaLidoInitialized)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PayableAvaLidoInitialized)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PayableAvaLidoInitializedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PayableAvaLidoInitializedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PayableAvaLidoInitialized represents a Initialized event raised by the PayableAvaLido contract.
type PayableAvaLidoInitialized struct {
	Version uint8
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInitialized is a free log retrieval operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_PayableAvaLido *PayableAvaLidoFilterer) FilterInitialized(opts *bind.FilterOpts) (*PayableAvaLidoInitializedIterator, error) {

	logs, sub, err := _PayableAvaLido.contract.FilterLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return &PayableAvaLidoInitializedIterator{contract: _PayableAvaLido.contract, event: "Initialized", logs: logs, sub: sub}, nil
}

// WatchInitialized is a free log subscription operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_PayableAvaLido *PayableAvaLidoFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *PayableAvaLidoInitialized) (event.Subscription, error) {

	logs, sub, err := _PayableAvaLido.contract.WatchLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PayableAvaLidoInitialized)
				if err := _PayableAvaLido.contract.UnpackLog(event, "Initialized", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInitialized is a log parse operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_PayableAvaLido *PayableAvaLidoFilterer) ParseInitialized(log types.Log) (*PayableAvaLidoInitialized, error) {
	event := new(PayableAvaLidoInitialized)
	if err := _PayableAvaLido.contract.UnpackLog(event, "Initialized", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PayableAvaLidoPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the PayableAvaLido contract.
type PayableAvaLidoPausedIterator struct {
	Event *PayableAvaLidoPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PayableAvaLidoPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PayableAvaLidoPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PayableAvaLidoPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PayableAvaLidoPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PayableAvaLidoPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PayableAvaLidoPaused represents a Paused event raised by the PayableAvaLido contract.
type PayableAvaLidoPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_PayableAvaLido *PayableAvaLidoFilterer) FilterPaused(opts *bind.FilterOpts) (*PayableAvaLidoPausedIterator, error) {

	logs, sub, err := _PayableAvaLido.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &PayableAvaLidoPausedIterator{contract: _PayableAvaLido.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_PayableAvaLido *PayableAvaLidoFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *PayableAvaLidoPaused) (event.Subscription, error) {

	logs, sub, err := _PayableAvaLido.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PayableAvaLidoPaused)
				if err := _PayableAvaLido.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_PayableAvaLido *PayableAvaLidoFilterer) ParsePaused(log types.Log) (*PayableAvaLidoPaused, error) {
	event := new(PayableAvaLidoPaused)
	if err := _PayableAvaLido.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PayableAvaLidoProtocolFeeEventIterator is returned from FilterProtocolFeeEvent and is used to iterate over the raw logs and unpacked data for ProtocolFeeEvent events raised by the PayableAvaLido contract.
type PayableAvaLidoProtocolFeeEventIterator struct {
	Event *PayableAvaLidoProtocolFeeEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PayableAvaLidoProtocolFeeEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PayableAvaLidoProtocolFeeEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PayableAvaLidoProtocolFeeEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PayableAvaLidoProtocolFeeEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PayableAvaLidoProtocolFeeEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PayableAvaLidoProtocolFeeEvent represents a ProtocolFeeEvent event raised by the PayableAvaLido contract.
type PayableAvaLidoProtocolFeeEvent struct {
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterProtocolFeeEvent is a free log retrieval operation binding the contract event 0x77bb62f6d632f13698ee0dfd8902692281a720e3bd4e18f03b96f3ba43ec5c25.
//
// Solidity: event ProtocolFeeEvent(uint256 amount)
func (_PayableAvaLido *PayableAvaLidoFilterer) FilterProtocolFeeEvent(opts *bind.FilterOpts) (*PayableAvaLidoProtocolFeeEventIterator, error) {

	logs, sub, err := _PayableAvaLido.contract.FilterLogs(opts, "ProtocolFeeEvent")
	if err != nil {
		return nil, err
	}
	return &PayableAvaLidoProtocolFeeEventIterator{contract: _PayableAvaLido.contract, event: "ProtocolFeeEvent", logs: logs, sub: sub}, nil
}

// WatchProtocolFeeEvent is a free log subscription operation binding the contract event 0x77bb62f6d632f13698ee0dfd8902692281a720e3bd4e18f03b96f3ba43ec5c25.
//
// Solidity: event ProtocolFeeEvent(uint256 amount)
func (_PayableAvaLido *PayableAvaLidoFilterer) WatchProtocolFeeEvent(opts *bind.WatchOpts, sink chan<- *PayableAvaLidoProtocolFeeEvent) (event.Subscription, error) {

	logs, sub, err := _PayableAvaLido.contract.WatchLogs(opts, "ProtocolFeeEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PayableAvaLidoProtocolFeeEvent)
				if err := _PayableAvaLido.contract.UnpackLog(event, "ProtocolFeeEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseProtocolFeeEvent is a log parse operation binding the contract event 0x77bb62f6d632f13698ee0dfd8902692281a720e3bd4e18f03b96f3ba43ec5c25.
//
// Solidity: event ProtocolFeeEvent(uint256 amount)
func (_PayableAvaLido *PayableAvaLidoFilterer) ParseProtocolFeeEvent(log types.Log) (*PayableAvaLidoProtocolFeeEvent, error) {
	event := new(PayableAvaLidoProtocolFeeEvent)
	if err := _PayableAvaLido.contract.UnpackLog(event, "ProtocolFeeEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PayableAvaLidoRequestFullyFilledEventIterator is returned from FilterRequestFullyFilledEvent and is used to iterate over the raw logs and unpacked data for RequestFullyFilledEvent events raised by the PayableAvaLido contract.
type PayableAvaLidoRequestFullyFilledEventIterator struct {
	Event *PayableAvaLidoRequestFullyFilledEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PayableAvaLidoRequestFullyFilledEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PayableAvaLidoRequestFullyFilledEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PayableAvaLidoRequestFullyFilledEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PayableAvaLidoRequestFullyFilledEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PayableAvaLidoRequestFullyFilledEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PayableAvaLidoRequestFullyFilledEvent represents a RequestFullyFilledEvent event raised by the PayableAvaLido contract.
type PayableAvaLidoRequestFullyFilledEvent struct {
	RequestedAmount *big.Int
	Timestamp       *big.Int
	RequestIndex    *big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterRequestFullyFilledEvent is a free log retrieval operation binding the contract event 0x6c09cd6b64ed10fcbd787eb4226ec81ab34e3db928a77faef8d22bc10ebe82ed.
//
// Solidity: event RequestFullyFilledEvent(uint256 indexed requestedAmount, uint256 timestamp, uint256 requestIndex)
func (_PayableAvaLido *PayableAvaLidoFilterer) FilterRequestFullyFilledEvent(opts *bind.FilterOpts, requestedAmount []*big.Int) (*PayableAvaLidoRequestFullyFilledEventIterator, error) {

	var requestedAmountRule []interface{}
	for _, requestedAmountItem := range requestedAmount {
		requestedAmountRule = append(requestedAmountRule, requestedAmountItem)
	}

	logs, sub, err := _PayableAvaLido.contract.FilterLogs(opts, "RequestFullyFilledEvent", requestedAmountRule)
	if err != nil {
		return nil, err
	}
	return &PayableAvaLidoRequestFullyFilledEventIterator{contract: _PayableAvaLido.contract, event: "RequestFullyFilledEvent", logs: logs, sub: sub}, nil
}

// WatchRequestFullyFilledEvent is a free log subscription operation binding the contract event 0x6c09cd6b64ed10fcbd787eb4226ec81ab34e3db928a77faef8d22bc10ebe82ed.
//
// Solidity: event RequestFullyFilledEvent(uint256 indexed requestedAmount, uint256 timestamp, uint256 requestIndex)
func (_PayableAvaLido *PayableAvaLidoFilterer) WatchRequestFullyFilledEvent(opts *bind.WatchOpts, sink chan<- *PayableAvaLidoRequestFullyFilledEvent, requestedAmount []*big.Int) (event.Subscription, error) {

	var requestedAmountRule []interface{}
	for _, requestedAmountItem := range requestedAmount {
		requestedAmountRule = append(requestedAmountRule, requestedAmountItem)
	}

	logs, sub, err := _PayableAvaLido.contract.WatchLogs(opts, "RequestFullyFilledEvent", requestedAmountRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PayableAvaLidoRequestFullyFilledEvent)
				if err := _PayableAvaLido.contract.UnpackLog(event, "RequestFullyFilledEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestFullyFilledEvent is a log parse operation binding the contract event 0x6c09cd6b64ed10fcbd787eb4226ec81ab34e3db928a77faef8d22bc10ebe82ed.
//
// Solidity: event RequestFullyFilledEvent(uint256 indexed requestedAmount, uint256 timestamp, uint256 requestIndex)
func (_PayableAvaLido *PayableAvaLidoFilterer) ParseRequestFullyFilledEvent(log types.Log) (*PayableAvaLidoRequestFullyFilledEvent, error) {
	event := new(PayableAvaLidoRequestFullyFilledEvent)
	if err := _PayableAvaLido.contract.UnpackLog(event, "RequestFullyFilledEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PayableAvaLidoRequestPartiallyFilledEventIterator is returned from FilterRequestPartiallyFilledEvent and is used to iterate over the raw logs and unpacked data for RequestPartiallyFilledEvent events raised by the PayableAvaLido contract.
type PayableAvaLidoRequestPartiallyFilledEventIterator struct {
	Event *PayableAvaLidoRequestPartiallyFilledEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PayableAvaLidoRequestPartiallyFilledEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PayableAvaLidoRequestPartiallyFilledEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PayableAvaLidoRequestPartiallyFilledEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PayableAvaLidoRequestPartiallyFilledEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PayableAvaLidoRequestPartiallyFilledEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PayableAvaLidoRequestPartiallyFilledEvent represents a RequestPartiallyFilledEvent event raised by the PayableAvaLido contract.
type PayableAvaLidoRequestPartiallyFilledEvent struct {
	FillAmount   *big.Int
	Timestamp    *big.Int
	RequestIndex *big.Int
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterRequestPartiallyFilledEvent is a free log retrieval operation binding the contract event 0xdc0903a14c2c2526071b103c0305417a977225da3764984a90de4c9b8195cac5.
//
// Solidity: event RequestPartiallyFilledEvent(uint256 indexed fillAmount, uint256 timestamp, uint256 requestIndex)
func (_PayableAvaLido *PayableAvaLidoFilterer) FilterRequestPartiallyFilledEvent(opts *bind.FilterOpts, fillAmount []*big.Int) (*PayableAvaLidoRequestPartiallyFilledEventIterator, error) {

	var fillAmountRule []interface{}
	for _, fillAmountItem := range fillAmount {
		fillAmountRule = append(fillAmountRule, fillAmountItem)
	}

	logs, sub, err := _PayableAvaLido.contract.FilterLogs(opts, "RequestPartiallyFilledEvent", fillAmountRule)
	if err != nil {
		return nil, err
	}
	return &PayableAvaLidoRequestPartiallyFilledEventIterator{contract: _PayableAvaLido.contract, event: "RequestPartiallyFilledEvent", logs: logs, sub: sub}, nil
}

// WatchRequestPartiallyFilledEvent is a free log subscription operation binding the contract event 0xdc0903a14c2c2526071b103c0305417a977225da3764984a90de4c9b8195cac5.
//
// Solidity: event RequestPartiallyFilledEvent(uint256 indexed fillAmount, uint256 timestamp, uint256 requestIndex)
func (_PayableAvaLido *PayableAvaLidoFilterer) WatchRequestPartiallyFilledEvent(opts *bind.WatchOpts, sink chan<- *PayableAvaLidoRequestPartiallyFilledEvent, fillAmount []*big.Int) (event.Subscription, error) {

	var fillAmountRule []interface{}
	for _, fillAmountItem := range fillAmount {
		fillAmountRule = append(fillAmountRule, fillAmountItem)
	}

	logs, sub, err := _PayableAvaLido.contract.WatchLogs(opts, "RequestPartiallyFilledEvent", fillAmountRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PayableAvaLidoRequestPartiallyFilledEvent)
				if err := _PayableAvaLido.contract.UnpackLog(event, "RequestPartiallyFilledEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRequestPartiallyFilledEvent is a log parse operation binding the contract event 0xdc0903a14c2c2526071b103c0305417a977225da3764984a90de4c9b8195cac5.
//
// Solidity: event RequestPartiallyFilledEvent(uint256 indexed fillAmount, uint256 timestamp, uint256 requestIndex)
func (_PayableAvaLido *PayableAvaLidoFilterer) ParseRequestPartiallyFilledEvent(log types.Log) (*PayableAvaLidoRequestPartiallyFilledEvent, error) {
	event := new(PayableAvaLidoRequestPartiallyFilledEvent)
	if err := _PayableAvaLido.contract.UnpackLog(event, "RequestPartiallyFilledEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PayableAvaLidoRewardsCollectedEventIterator is returned from FilterRewardsCollectedEvent and is used to iterate over the raw logs and unpacked data for RewardsCollectedEvent events raised by the PayableAvaLido contract.
type PayableAvaLidoRewardsCollectedEventIterator struct {
	Event *PayableAvaLidoRewardsCollectedEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PayableAvaLidoRewardsCollectedEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PayableAvaLidoRewardsCollectedEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PayableAvaLidoRewardsCollectedEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PayableAvaLidoRewardsCollectedEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PayableAvaLidoRewardsCollectedEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PayableAvaLidoRewardsCollectedEvent represents a RewardsCollectedEvent event raised by the PayableAvaLido contract.
type PayableAvaLidoRewardsCollectedEvent struct {
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRewardsCollectedEvent is a free log retrieval operation binding the contract event 0x4f085349488b0a9bbaba55c0dce4ef2ebfc933ff64bdfe6ff3d4b27fdb467706.
//
// Solidity: event RewardsCollectedEvent(uint256 amount)
func (_PayableAvaLido *PayableAvaLidoFilterer) FilterRewardsCollectedEvent(opts *bind.FilterOpts) (*PayableAvaLidoRewardsCollectedEventIterator, error) {

	logs, sub, err := _PayableAvaLido.contract.FilterLogs(opts, "RewardsCollectedEvent")
	if err != nil {
		return nil, err
	}
	return &PayableAvaLidoRewardsCollectedEventIterator{contract: _PayableAvaLido.contract, event: "RewardsCollectedEvent", logs: logs, sub: sub}, nil
}

// WatchRewardsCollectedEvent is a free log subscription operation binding the contract event 0x4f085349488b0a9bbaba55c0dce4ef2ebfc933ff64bdfe6ff3d4b27fdb467706.
//
// Solidity: event RewardsCollectedEvent(uint256 amount)
func (_PayableAvaLido *PayableAvaLidoFilterer) WatchRewardsCollectedEvent(opts *bind.WatchOpts, sink chan<- *PayableAvaLidoRewardsCollectedEvent) (event.Subscription, error) {

	logs, sub, err := _PayableAvaLido.contract.WatchLogs(opts, "RewardsCollectedEvent")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PayableAvaLidoRewardsCollectedEvent)
				if err := _PayableAvaLido.contract.UnpackLog(event, "RewardsCollectedEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRewardsCollectedEvent is a log parse operation binding the contract event 0x4f085349488b0a9bbaba55c0dce4ef2ebfc933ff64bdfe6ff3d4b27fdb467706.
//
// Solidity: event RewardsCollectedEvent(uint256 amount)
func (_PayableAvaLido *PayableAvaLidoFilterer) ParseRewardsCollectedEvent(log types.Log) (*PayableAvaLidoRewardsCollectedEvent, error) {
	event := new(PayableAvaLidoRewardsCollectedEvent)
	if err := _PayableAvaLido.contract.UnpackLog(event, "RewardsCollectedEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PayableAvaLidoRoleAdminChangedIterator is returned from FilterRoleAdminChanged and is used to iterate over the raw logs and unpacked data for RoleAdminChanged events raised by the PayableAvaLido contract.
type PayableAvaLidoRoleAdminChangedIterator struct {
	Event *PayableAvaLidoRoleAdminChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PayableAvaLidoRoleAdminChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PayableAvaLidoRoleAdminChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PayableAvaLidoRoleAdminChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PayableAvaLidoRoleAdminChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PayableAvaLidoRoleAdminChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PayableAvaLidoRoleAdminChanged represents a RoleAdminChanged event raised by the PayableAvaLido contract.
type PayableAvaLidoRoleAdminChanged struct {
	Role              [32]byte
	PreviousAdminRole [32]byte
	NewAdminRole      [32]byte
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRoleAdminChanged is a free log retrieval operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_PayableAvaLido *PayableAvaLidoFilterer) FilterRoleAdminChanged(opts *bind.FilterOpts, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (*PayableAvaLidoRoleAdminChangedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _PayableAvaLido.contract.FilterLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return &PayableAvaLidoRoleAdminChangedIterator{contract: _PayableAvaLido.contract, event: "RoleAdminChanged", logs: logs, sub: sub}, nil
}

// WatchRoleAdminChanged is a free log subscription operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_PayableAvaLido *PayableAvaLidoFilterer) WatchRoleAdminChanged(opts *bind.WatchOpts, sink chan<- *PayableAvaLidoRoleAdminChanged, role [][32]byte, previousAdminRole [][32]byte, newAdminRole [][32]byte) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var previousAdminRoleRule []interface{}
	for _, previousAdminRoleItem := range previousAdminRole {
		previousAdminRoleRule = append(previousAdminRoleRule, previousAdminRoleItem)
	}
	var newAdminRoleRule []interface{}
	for _, newAdminRoleItem := range newAdminRole {
		newAdminRoleRule = append(newAdminRoleRule, newAdminRoleItem)
	}

	logs, sub, err := _PayableAvaLido.contract.WatchLogs(opts, "RoleAdminChanged", roleRule, previousAdminRoleRule, newAdminRoleRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PayableAvaLidoRoleAdminChanged)
				if err := _PayableAvaLido.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleAdminChanged is a log parse operation binding the contract event 0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff.
//
// Solidity: event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole)
func (_PayableAvaLido *PayableAvaLidoFilterer) ParseRoleAdminChanged(log types.Log) (*PayableAvaLidoRoleAdminChanged, error) {
	event := new(PayableAvaLidoRoleAdminChanged)
	if err := _PayableAvaLido.contract.UnpackLog(event, "RoleAdminChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PayableAvaLidoRoleGrantedIterator is returned from FilterRoleGranted and is used to iterate over the raw logs and unpacked data for RoleGranted events raised by the PayableAvaLido contract.
type PayableAvaLidoRoleGrantedIterator struct {
	Event *PayableAvaLidoRoleGranted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PayableAvaLidoRoleGrantedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PayableAvaLidoRoleGranted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PayableAvaLidoRoleGranted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PayableAvaLidoRoleGrantedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PayableAvaLidoRoleGrantedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PayableAvaLidoRoleGranted represents a RoleGranted event raised by the PayableAvaLido contract.
type PayableAvaLidoRoleGranted struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleGranted is a free log retrieval operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_PayableAvaLido *PayableAvaLidoFilterer) FilterRoleGranted(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*PayableAvaLidoRoleGrantedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _PayableAvaLido.contract.FilterLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &PayableAvaLidoRoleGrantedIterator{contract: _PayableAvaLido.contract, event: "RoleGranted", logs: logs, sub: sub}, nil
}

// WatchRoleGranted is a free log subscription operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_PayableAvaLido *PayableAvaLidoFilterer) WatchRoleGranted(opts *bind.WatchOpts, sink chan<- *PayableAvaLidoRoleGranted, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _PayableAvaLido.contract.WatchLogs(opts, "RoleGranted", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PayableAvaLidoRoleGranted)
				if err := _PayableAvaLido.contract.UnpackLog(event, "RoleGranted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleGranted is a log parse operation binding the contract event 0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d.
//
// Solidity: event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender)
func (_PayableAvaLido *PayableAvaLidoFilterer) ParseRoleGranted(log types.Log) (*PayableAvaLidoRoleGranted, error) {
	event := new(PayableAvaLidoRoleGranted)
	if err := _PayableAvaLido.contract.UnpackLog(event, "RoleGranted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PayableAvaLidoRoleRevokedIterator is returned from FilterRoleRevoked and is used to iterate over the raw logs and unpacked data for RoleRevoked events raised by the PayableAvaLido contract.
type PayableAvaLidoRoleRevokedIterator struct {
	Event *PayableAvaLidoRoleRevoked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PayableAvaLidoRoleRevokedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PayableAvaLidoRoleRevoked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PayableAvaLidoRoleRevoked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PayableAvaLidoRoleRevokedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PayableAvaLidoRoleRevokedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PayableAvaLidoRoleRevoked represents a RoleRevoked event raised by the PayableAvaLido contract.
type PayableAvaLidoRoleRevoked struct {
	Role    [32]byte
	Account common.Address
	Sender  common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRoleRevoked is a free log retrieval operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_PayableAvaLido *PayableAvaLidoFilterer) FilterRoleRevoked(opts *bind.FilterOpts, role [][32]byte, account []common.Address, sender []common.Address) (*PayableAvaLidoRoleRevokedIterator, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _PayableAvaLido.contract.FilterLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return &PayableAvaLidoRoleRevokedIterator{contract: _PayableAvaLido.contract, event: "RoleRevoked", logs: logs, sub: sub}, nil
}

// WatchRoleRevoked is a free log subscription operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_PayableAvaLido *PayableAvaLidoFilterer) WatchRoleRevoked(opts *bind.WatchOpts, sink chan<- *PayableAvaLidoRoleRevoked, role [][32]byte, account []common.Address, sender []common.Address) (event.Subscription, error) {

	var roleRule []interface{}
	for _, roleItem := range role {
		roleRule = append(roleRule, roleItem)
	}
	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}
	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _PayableAvaLido.contract.WatchLogs(opts, "RoleRevoked", roleRule, accountRule, senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PayableAvaLidoRoleRevoked)
				if err := _PayableAvaLido.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRoleRevoked is a log parse operation binding the contract event 0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b.
//
// Solidity: event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender)
func (_PayableAvaLido *PayableAvaLidoFilterer) ParseRoleRevoked(log types.Log) (*PayableAvaLidoRoleRevoked, error) {
	event := new(PayableAvaLidoRoleRevoked)
	if err := _PayableAvaLido.contract.UnpackLog(event, "RoleRevoked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PayableAvaLidoTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the PayableAvaLido contract.
type PayableAvaLidoTransferIterator struct {
	Event *PayableAvaLidoTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PayableAvaLidoTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PayableAvaLidoTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PayableAvaLidoTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PayableAvaLidoTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PayableAvaLidoTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PayableAvaLidoTransfer represents a Transfer event raised by the PayableAvaLido contract.
type PayableAvaLidoTransfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_PayableAvaLido *PayableAvaLidoFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*PayableAvaLidoTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _PayableAvaLido.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &PayableAvaLidoTransferIterator{contract: _PayableAvaLido.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_PayableAvaLido *PayableAvaLidoFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *PayableAvaLidoTransfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _PayableAvaLido.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PayableAvaLidoTransfer)
				if err := _PayableAvaLido.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_PayableAvaLido *PayableAvaLidoFilterer) ParseTransfer(log types.Log) (*PayableAvaLidoTransfer, error) {
	event := new(PayableAvaLidoTransfer)
	if err := _PayableAvaLido.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PayableAvaLidoUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the PayableAvaLido contract.
type PayableAvaLidoUnpausedIterator struct {
	Event *PayableAvaLidoUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PayableAvaLidoUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PayableAvaLidoUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PayableAvaLidoUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PayableAvaLidoUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PayableAvaLidoUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PayableAvaLidoUnpaused represents a Unpaused event raised by the PayableAvaLido contract.
type PayableAvaLidoUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_PayableAvaLido *PayableAvaLidoFilterer) FilterUnpaused(opts *bind.FilterOpts) (*PayableAvaLidoUnpausedIterator, error) {

	logs, sub, err := _PayableAvaLido.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &PayableAvaLidoUnpausedIterator{contract: _PayableAvaLido.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_PayableAvaLido *PayableAvaLidoFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *PayableAvaLidoUnpaused) (event.Subscription, error) {

	logs, sub, err := _PayableAvaLido.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PayableAvaLidoUnpaused)
				if err := _PayableAvaLido.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_PayableAvaLido *PayableAvaLidoFilterer) ParseUnpaused(log types.Log) (*PayableAvaLidoUnpaused, error) {
	event := new(PayableAvaLidoUnpaused)
	if err := _PayableAvaLido.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PayableAvaLidoWithdrawRequestSubmittedEventIterator is returned from FilterWithdrawRequestSubmittedEvent and is used to iterate over the raw logs and unpacked data for WithdrawRequestSubmittedEvent events raised by the PayableAvaLido contract.
type PayableAvaLidoWithdrawRequestSubmittedEventIterator struct {
	Event *PayableAvaLidoWithdrawRequestSubmittedEvent // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PayableAvaLidoWithdrawRequestSubmittedEventIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PayableAvaLidoWithdrawRequestSubmittedEvent)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PayableAvaLidoWithdrawRequestSubmittedEvent)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PayableAvaLidoWithdrawRequestSubmittedEventIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PayableAvaLidoWithdrawRequestSubmittedEventIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PayableAvaLidoWithdrawRequestSubmittedEvent represents a WithdrawRequestSubmittedEvent event raised by the PayableAvaLido contract.
type PayableAvaLidoWithdrawRequestSubmittedEvent struct {
	From         common.Address
	AvaxAmount   *big.Int
	StAvaxAmount *big.Int
	Timestamp    *big.Int
	RequestIndex *big.Int
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterWithdrawRequestSubmittedEvent is a free log retrieval operation binding the contract event 0xdae9f04ebd508b8d6ff61ab1601937224910e223f2a01713eab68e3d4aeb10ef.
//
// Solidity: event WithdrawRequestSubmittedEvent(address indexed from, uint256 avaxAmount, uint256 stAvaxAmount, uint256 timestamp, uint256 requestIndex)
func (_PayableAvaLido *PayableAvaLidoFilterer) FilterWithdrawRequestSubmittedEvent(opts *bind.FilterOpts, from []common.Address) (*PayableAvaLidoWithdrawRequestSubmittedEventIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _PayableAvaLido.contract.FilterLogs(opts, "WithdrawRequestSubmittedEvent", fromRule)
	if err != nil {
		return nil, err
	}
	return &PayableAvaLidoWithdrawRequestSubmittedEventIterator{contract: _PayableAvaLido.contract, event: "WithdrawRequestSubmittedEvent", logs: logs, sub: sub}, nil
}

// WatchWithdrawRequestSubmittedEvent is a free log subscription operation binding the contract event 0xdae9f04ebd508b8d6ff61ab1601937224910e223f2a01713eab68e3d4aeb10ef.
//
// Solidity: event WithdrawRequestSubmittedEvent(address indexed from, uint256 avaxAmount, uint256 stAvaxAmount, uint256 timestamp, uint256 requestIndex)
func (_PayableAvaLido *PayableAvaLidoFilterer) WatchWithdrawRequestSubmittedEvent(opts *bind.WatchOpts, sink chan<- *PayableAvaLidoWithdrawRequestSubmittedEvent, from []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _PayableAvaLido.contract.WatchLogs(opts, "WithdrawRequestSubmittedEvent", fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PayableAvaLidoWithdrawRequestSubmittedEvent)
				if err := _PayableAvaLido.contract.UnpackLog(event, "WithdrawRequestSubmittedEvent", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawRequestSubmittedEvent is a log parse operation binding the contract event 0xdae9f04ebd508b8d6ff61ab1601937224910e223f2a01713eab68e3d4aeb10ef.
//
// Solidity: event WithdrawRequestSubmittedEvent(address indexed from, uint256 avaxAmount, uint256 stAvaxAmount, uint256 timestamp, uint256 requestIndex)
func (_PayableAvaLido *PayableAvaLidoFilterer) ParseWithdrawRequestSubmittedEvent(log types.Log) (*PayableAvaLidoWithdrawRequestSubmittedEvent, error) {
	event := new(PayableAvaLidoWithdrawRequestSubmittedEvent)
	if err := _PayableAvaLido.contract.UnpackLog(event, "WithdrawRequestSubmittedEvent", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PaymentSplitterMetaData contains all meta data concerning the PaymentSplitter contract.
var PaymentSplitterMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"payees\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"shares_\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contractIERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ERC20PaymentReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"PayeeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaymentReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaymentReleased\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"payee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"releasable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"releasable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"released\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"released\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"shares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"totalReleased\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReleased\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
	Sigs: map[string]string{
		"8b83209b": "payee(uint256)",
		"a3f8eace": "releasable(address)",
		"c45ac050": "releasable(address,address)",
		"19165587": "release(address)",
		"48b75044": "release(address,address)",
		"9852595c": "released(address)",
		"406072a9": "released(address,address)",
		"ce7c2ac2": "shares(address)",
		"e33b7de3": "totalReleased()",
		"d79779b2": "totalReleased(address)",
		"3a98ef39": "totalShares()",
	},
	Bin: "0x6080604052604051620011c9380380620011c983398101604081905262000026916200042e565b8051825114620000985760405162461bcd60e51b815260206004820152603260248201527f5061796d656e7453706c69747465723a2070617965657320616e6420736861726044820152710cae640d8cadccee8d040dad2e6dac2e8c6d60731b60648201526084015b60405180910390fd5b6000825111620000eb5760405162461bcd60e51b815260206004820152601a60248201527f5061796d656e7453706c69747465723a206e6f2070617965657300000000000060448201526064016200008f565b60005b82518110156200015757620001428382815181106200011157620001116200050c565b60200260200101518383815181106200012e576200012e6200050c565b60200260200101516200016060201b60201c565b806200014e8162000538565b915050620000ee565b50505062000571565b6001600160a01b038216620001cd5760405162461bcd60e51b815260206004820152602c60248201527f5061796d656e7453706c69747465723a206163636f756e74206973207468652060448201526b7a65726f206164647265737360a01b60648201526084016200008f565b600081116200021f5760405162461bcd60e51b815260206004820152601d60248201527f5061796d656e7453706c69747465723a2073686172657320617265203000000060448201526064016200008f565b6001600160a01b038216600090815260026020526040902054156200029b5760405162461bcd60e51b815260206004820152602b60248201527f5061796d656e7453706c69747465723a206163636f756e7420616c726561647960448201526a206861732073686172657360a81b60648201526084016200008f565b60048054600181019091557f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b0180546001600160a01b0319166001600160a01b0384169081179091556000908152600260205260408120829055546200030390829062000556565b600055604080516001600160a01b0384168152602081018390527f40c340f65e17194d14ddddb073d3c9f888e3cb52b5aae0c6c7706b4fbc905fac910160405180910390a15050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b03811182821017156200038d576200038d6200034c565b604052919050565b60006001600160401b03821115620003b157620003b16200034c565b5060051b60200190565b600082601f830112620003cd57600080fd5b81516020620003e6620003e08362000395565b62000362565b82815260059290921b840181019181810190868411156200040657600080fd5b8286015b848110156200042357805183529183019183016200040a565b509695505050505050565b600080604083850312156200044257600080fd5b82516001600160401b03808211156200045a57600080fd5b818501915085601f8301126200046f57600080fd5b8151602062000482620003e08362000395565b82815260059290921b84018101918181019089841115620004a257600080fd5b948201945b83861015620004d95785516001600160a01b0381168114620004c95760008081fd5b82529482019490820190620004a7565b91880151919650909350505080821115620004f357600080fd5b506200050285828601620003bb565b9150509250929050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b60006000198214156200054f576200054f62000522565b5060010190565b600082198211156200056c576200056c62000522565b500190565b610c4880620005816000396000f3fe6080604052600436106100a05760003560e01c80639852595c116100645780639852595c146101d2578063a3f8eace14610208578063c45ac05014610228578063ce7c2ac214610248578063d79779b21461027e578063e33b7de3146102b457600080fd5b806319165587146100ee5780633a98ef3914610110578063406072a91461013457806348b750441461017a5780638b83209b1461019a57600080fd5b366100e9577f6ef95f06320e7a25a04a175ca677b7052bdd97131872c2192525a629f51be77033604080516001600160a01b0390921682523460208301520160405180910390a1005b600080fd5b3480156100fa57600080fd5b5061010e6101093660046109bc565b6102c9565b005b34801561011c57600080fd5b506000545b6040519081526020015b60405180910390f35b34801561014057600080fd5b5061012161014f3660046109d9565b6001600160a01b03918216600090815260066020908152604080832093909416825291909152205490565b34801561018657600080fd5b5061010e6101953660046109d9565b6103b6565b3480156101a657600080fd5b506101ba6101b5366004610a12565b6104c4565b6040516001600160a01b03909116815260200161012b565b3480156101de57600080fd5b506101216101ed3660046109bc565b6001600160a01b031660009081526003602052604090205490565b34801561021457600080fd5b506101216102233660046109bc565b6104f4565b34801561023457600080fd5b506101216102433660046109d9565b61053c565b34801561025457600080fd5b506101216102633660046109bc565b6001600160a01b031660009081526002602052604090205490565b34801561028a57600080fd5b506101216102993660046109bc565b6001600160a01b031660009081526005602052604090205490565b3480156102c057600080fd5b50600154610121565b6001600160a01b0381166000908152600260205260409020546103075760405162461bcd60e51b81526004016102fe90610a2b565b60405180910390fd5b6000610312826104f4565b9050806103315760405162461bcd60e51b81526004016102fe90610a71565b80600160008282546103439190610ad2565b90915550506001600160a01b03821660009081526003602052604090208054820190556103708282610607565b604080516001600160a01b0384168152602081018390527fdf20fd1e76bc69d672e4814fafb2c449bba3a5369d8359adf9e05e6fde87b056910160405180910390a15050565b6001600160a01b0381166000908152600260205260409020546103eb5760405162461bcd60e51b81526004016102fe90610a2b565b60006103f7838361053c565b9050806104165760405162461bcd60e51b81526004016102fe90610a71565b6001600160a01b0383166000908152600560205260408120805483929061043e908490610ad2565b90915550506001600160a01b038084166000908152600660209081526040808320938616835292905220805482019055610479838383610725565b604080516001600160a01b038481168252602082018490528516917f3be5b7a71e84ed12875d241991c70855ac5817d847039e17a9d895c1ceb0f18a910160405180910390a2505050565b6000600482815481106104d9576104d9610aea565b6000918252602090912001546001600160a01b031692915050565b60008061050060015490565b61050a9047610ad2565b90506105358382610530866001600160a01b031660009081526003602052604090205490565b610777565b9392505050565b6001600160a01b03821660009081526005602052604081205481906040516370a0823160e01b81523060048201526001600160a01b038616906370a0823190602401602060405180830381865afa15801561059b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105bf9190610b00565b6105c99190610ad2565b6001600160a01b038086166000908152600660209081526040808320938816835292905220549091506105ff9084908390610777565b949350505050565b804710156106575760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a20696e73756666696369656e742062616c616e636500000060448201526064016102fe565b6000826001600160a01b03168260405160006040518083038185875af1925050503d80600081146106a4576040519150601f19603f3d011682016040523d82523d6000602084013e6106a9565b606091505b50509050806107205760405162461bcd60e51b815260206004820152603a60248201527f416464726573733a20756e61626c6520746f2073656e642076616c75652c207260448201527f6563697069656e74206d6179206861766520726576657274656400000000000060648201526084016102fe565b505050565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663a9059cbb60e01b1790526107209084906107b2565b600080546001600160a01b03851682526002602052604082205483919061079e9086610b19565b6107a89190610b38565b6105ff9190610b5a565b6000610807826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166108849092919063ffffffff16565b80519091501561072057808060200190518101906108259190610b71565b6107205760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016102fe565b60606105ff848460008585600080866001600160a01b031685876040516108ab9190610bc3565b60006040518083038185875af1925050503d80600081146108e8576040519150601f19603f3d011682016040523d82523d6000602084013e6108ed565b606091505b50915091506108fe87838387610909565b979650505050505050565b6060831561097557825161096e576001600160a01b0385163b61096e5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016102fe565b50816105ff565b6105ff838381511561098a5781518083602001fd5b8060405162461bcd60e51b81526004016102fe9190610bdf565b6001600160a01b03811681146109b957600080fd5b50565b6000602082840312156109ce57600080fd5b8135610535816109a4565b600080604083850312156109ec57600080fd5b82356109f7816109a4565b91506020830135610a07816109a4565b809150509250929050565b600060208284031215610a2457600080fd5b5035919050565b60208082526026908201527f5061796d656e7453706c69747465723a206163636f756e7420686173206e6f2060408201526573686172657360d01b606082015260800190565b6020808252602b908201527f5061796d656e7453706c69747465723a206163636f756e74206973206e6f742060408201526a191d59481c185e5b595b9d60aa1b606082015260800190565b634e487b7160e01b600052601160045260246000fd5b60008219821115610ae557610ae5610abc565b500190565b634e487b7160e01b600052603260045260246000fd5b600060208284031215610b1257600080fd5b5051919050565b6000816000190483118215151615610b3357610b33610abc565b500290565b600082610b5557634e487b7160e01b600052601260045260246000fd5b500490565b600082821015610b6c57610b6c610abc565b500390565b600060208284031215610b8357600080fd5b8151801515811461053557600080fd5b60005b83811015610bae578181015183820152602001610b96565b83811115610bbd576000848401525b50505050565b60008251610bd5818460208701610b93565b9190910192915050565b6020815260008251806020840152610bfe816040850160208701610b93565b601f01601f1916919091016040019291505056fea264697066735822122072124e5593df9b0f269294bc9437eac01d2c53da3f72549c0203647d323fdb5464736f6c634300080a0033",
}

// PaymentSplitterABI is the input ABI used to generate the binding from.
// Deprecated: Use PaymentSplitterMetaData.ABI instead.
var PaymentSplitterABI = PaymentSplitterMetaData.ABI

// Deprecated: Use PaymentSplitterMetaData.Sigs instead.
// PaymentSplitterFuncSigs maps the 4-byte function signature to its string representation.
var PaymentSplitterFuncSigs = PaymentSplitterMetaData.Sigs

// PaymentSplitterBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use PaymentSplitterMetaData.Bin instead.
var PaymentSplitterBin = PaymentSplitterMetaData.Bin

// DeployPaymentSplitter deploys a new Ethereum contract, binding an instance of PaymentSplitter to it.
func DeployPaymentSplitter(auth *bind.TransactOpts, backend bind.ContractBackend, payees []common.Address, shares_ []*big.Int) (common.Address, *types.Transaction, *PaymentSplitter, error) {
	parsed, err := PaymentSplitterMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(PaymentSplitterBin), backend, payees, shares_)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &PaymentSplitter{PaymentSplitterCaller: PaymentSplitterCaller{contract: contract}, PaymentSplitterTransactor: PaymentSplitterTransactor{contract: contract}, PaymentSplitterFilterer: PaymentSplitterFilterer{contract: contract}}, nil
}

// PaymentSplitter is an auto generated Go binding around an Ethereum contract.
type PaymentSplitter struct {
	PaymentSplitterCaller     // Read-only binding to the contract
	PaymentSplitterTransactor // Write-only binding to the contract
	PaymentSplitterFilterer   // Log filterer for contract events
}

// PaymentSplitterCaller is an auto generated read-only Go binding around an Ethereum contract.
type PaymentSplitterCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PaymentSplitterTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PaymentSplitterTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PaymentSplitterFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PaymentSplitterFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PaymentSplitterSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PaymentSplitterSession struct {
	Contract     *PaymentSplitter  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// PaymentSplitterCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PaymentSplitterCallerSession struct {
	Contract *PaymentSplitterCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// PaymentSplitterTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PaymentSplitterTransactorSession struct {
	Contract     *PaymentSplitterTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// PaymentSplitterRaw is an auto generated low-level Go binding around an Ethereum contract.
type PaymentSplitterRaw struct {
	Contract *PaymentSplitter // Generic contract binding to access the raw methods on
}

// PaymentSplitterCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PaymentSplitterCallerRaw struct {
	Contract *PaymentSplitterCaller // Generic read-only contract binding to access the raw methods on
}

// PaymentSplitterTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PaymentSplitterTransactorRaw struct {
	Contract *PaymentSplitterTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPaymentSplitter creates a new instance of PaymentSplitter, bound to a specific deployed contract.
func NewPaymentSplitter(address common.Address, backend bind.ContractBackend) (*PaymentSplitter, error) {
	contract, err := bindPaymentSplitter(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &PaymentSplitter{PaymentSplitterCaller: PaymentSplitterCaller{contract: contract}, PaymentSplitterTransactor: PaymentSplitterTransactor{contract: contract}, PaymentSplitterFilterer: PaymentSplitterFilterer{contract: contract}}, nil
}

// NewPaymentSplitterCaller creates a new read-only instance of PaymentSplitter, bound to a specific deployed contract.
func NewPaymentSplitterCaller(address common.Address, caller bind.ContractCaller) (*PaymentSplitterCaller, error) {
	contract, err := bindPaymentSplitter(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PaymentSplitterCaller{contract: contract}, nil
}

// NewPaymentSplitterTransactor creates a new write-only instance of PaymentSplitter, bound to a specific deployed contract.
func NewPaymentSplitterTransactor(address common.Address, transactor bind.ContractTransactor) (*PaymentSplitterTransactor, error) {
	contract, err := bindPaymentSplitter(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PaymentSplitterTransactor{contract: contract}, nil
}

// NewPaymentSplitterFilterer creates a new log filterer instance of PaymentSplitter, bound to a specific deployed contract.
func NewPaymentSplitterFilterer(address common.Address, filterer bind.ContractFilterer) (*PaymentSplitterFilterer, error) {
	contract, err := bindPaymentSplitter(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PaymentSplitterFilterer{contract: contract}, nil
}

// bindPaymentSplitter binds a generic wrapper to an already deployed contract.
func bindPaymentSplitter(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(PaymentSplitterABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PaymentSplitter *PaymentSplitterRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PaymentSplitter.Contract.PaymentSplitterCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PaymentSplitter *PaymentSplitterRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PaymentSplitter.Contract.PaymentSplitterTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PaymentSplitter *PaymentSplitterRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PaymentSplitter.Contract.PaymentSplitterTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PaymentSplitter *PaymentSplitterCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PaymentSplitter.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PaymentSplitter *PaymentSplitterTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PaymentSplitter.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PaymentSplitter *PaymentSplitterTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PaymentSplitter.Contract.contract.Transact(opts, method, params...)
}

// Payee is a free data retrieval call binding the contract method 0x8b83209b.
//
// Solidity: function payee(uint256 index) view returns(address)
func (_PaymentSplitter *PaymentSplitterCaller) Payee(opts *bind.CallOpts, index *big.Int) (common.Address, error) {
	var out []interface{}
	err := _PaymentSplitter.contract.Call(opts, &out, "payee", index)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Payee is a free data retrieval call binding the contract method 0x8b83209b.
//
// Solidity: function payee(uint256 index) view returns(address)
func (_PaymentSplitter *PaymentSplitterSession) Payee(index *big.Int) (common.Address, error) {
	return _PaymentSplitter.Contract.Payee(&_PaymentSplitter.CallOpts, index)
}

// Payee is a free data retrieval call binding the contract method 0x8b83209b.
//
// Solidity: function payee(uint256 index) view returns(address)
func (_PaymentSplitter *PaymentSplitterCallerSession) Payee(index *big.Int) (common.Address, error) {
	return _PaymentSplitter.Contract.Payee(&_PaymentSplitter.CallOpts, index)
}

// Releasable is a free data retrieval call binding the contract method 0xa3f8eace.
//
// Solidity: function releasable(address account) view returns(uint256)
func (_PaymentSplitter *PaymentSplitterCaller) Releasable(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PaymentSplitter.contract.Call(opts, &out, "releasable", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Releasable is a free data retrieval call binding the contract method 0xa3f8eace.
//
// Solidity: function releasable(address account) view returns(uint256)
func (_PaymentSplitter *PaymentSplitterSession) Releasable(account common.Address) (*big.Int, error) {
	return _PaymentSplitter.Contract.Releasable(&_PaymentSplitter.CallOpts, account)
}

// Releasable is a free data retrieval call binding the contract method 0xa3f8eace.
//
// Solidity: function releasable(address account) view returns(uint256)
func (_PaymentSplitter *PaymentSplitterCallerSession) Releasable(account common.Address) (*big.Int, error) {
	return _PaymentSplitter.Contract.Releasable(&_PaymentSplitter.CallOpts, account)
}

// Releasable0 is a free data retrieval call binding the contract method 0xc45ac050.
//
// Solidity: function releasable(address token, address account) view returns(uint256)
func (_PaymentSplitter *PaymentSplitterCaller) Releasable0(opts *bind.CallOpts, token common.Address, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PaymentSplitter.contract.Call(opts, &out, "releasable0", token, account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Releasable0 is a free data retrieval call binding the contract method 0xc45ac050.
//
// Solidity: function releasable(address token, address account) view returns(uint256)
func (_PaymentSplitter *PaymentSplitterSession) Releasable0(token common.Address, account common.Address) (*big.Int, error) {
	return _PaymentSplitter.Contract.Releasable0(&_PaymentSplitter.CallOpts, token, account)
}

// Releasable0 is a free data retrieval call binding the contract method 0xc45ac050.
//
// Solidity: function releasable(address token, address account) view returns(uint256)
func (_PaymentSplitter *PaymentSplitterCallerSession) Releasable0(token common.Address, account common.Address) (*big.Int, error) {
	return _PaymentSplitter.Contract.Releasable0(&_PaymentSplitter.CallOpts, token, account)
}

// Released is a free data retrieval call binding the contract method 0x406072a9.
//
// Solidity: function released(address token, address account) view returns(uint256)
func (_PaymentSplitter *PaymentSplitterCaller) Released(opts *bind.CallOpts, token common.Address, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PaymentSplitter.contract.Call(opts, &out, "released", token, account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Released is a free data retrieval call binding the contract method 0x406072a9.
//
// Solidity: function released(address token, address account) view returns(uint256)
func (_PaymentSplitter *PaymentSplitterSession) Released(token common.Address, account common.Address) (*big.Int, error) {
	return _PaymentSplitter.Contract.Released(&_PaymentSplitter.CallOpts, token, account)
}

// Released is a free data retrieval call binding the contract method 0x406072a9.
//
// Solidity: function released(address token, address account) view returns(uint256)
func (_PaymentSplitter *PaymentSplitterCallerSession) Released(token common.Address, account common.Address) (*big.Int, error) {
	return _PaymentSplitter.Contract.Released(&_PaymentSplitter.CallOpts, token, account)
}

// Released0 is a free data retrieval call binding the contract method 0x9852595c.
//
// Solidity: function released(address account) view returns(uint256)
func (_PaymentSplitter *PaymentSplitterCaller) Released0(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PaymentSplitter.contract.Call(opts, &out, "released0", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Released0 is a free data retrieval call binding the contract method 0x9852595c.
//
// Solidity: function released(address account) view returns(uint256)
func (_PaymentSplitter *PaymentSplitterSession) Released0(account common.Address) (*big.Int, error) {
	return _PaymentSplitter.Contract.Released0(&_PaymentSplitter.CallOpts, account)
}

// Released0 is a free data retrieval call binding the contract method 0x9852595c.
//
// Solidity: function released(address account) view returns(uint256)
func (_PaymentSplitter *PaymentSplitterCallerSession) Released0(account common.Address) (*big.Int, error) {
	return _PaymentSplitter.Contract.Released0(&_PaymentSplitter.CallOpts, account)
}

// Shares is a free data retrieval call binding the contract method 0xce7c2ac2.
//
// Solidity: function shares(address account) view returns(uint256)
func (_PaymentSplitter *PaymentSplitterCaller) Shares(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PaymentSplitter.contract.Call(opts, &out, "shares", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Shares is a free data retrieval call binding the contract method 0xce7c2ac2.
//
// Solidity: function shares(address account) view returns(uint256)
func (_PaymentSplitter *PaymentSplitterSession) Shares(account common.Address) (*big.Int, error) {
	return _PaymentSplitter.Contract.Shares(&_PaymentSplitter.CallOpts, account)
}

// Shares is a free data retrieval call binding the contract method 0xce7c2ac2.
//
// Solidity: function shares(address account) view returns(uint256)
func (_PaymentSplitter *PaymentSplitterCallerSession) Shares(account common.Address) (*big.Int, error) {
	return _PaymentSplitter.Contract.Shares(&_PaymentSplitter.CallOpts, account)
}

// TotalReleased is a free data retrieval call binding the contract method 0xd79779b2.
//
// Solidity: function totalReleased(address token) view returns(uint256)
func (_PaymentSplitter *PaymentSplitterCaller) TotalReleased(opts *bind.CallOpts, token common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PaymentSplitter.contract.Call(opts, &out, "totalReleased", token)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalReleased is a free data retrieval call binding the contract method 0xd79779b2.
//
// Solidity: function totalReleased(address token) view returns(uint256)
func (_PaymentSplitter *PaymentSplitterSession) TotalReleased(token common.Address) (*big.Int, error) {
	return _PaymentSplitter.Contract.TotalReleased(&_PaymentSplitter.CallOpts, token)
}

// TotalReleased is a free data retrieval call binding the contract method 0xd79779b2.
//
// Solidity: function totalReleased(address token) view returns(uint256)
func (_PaymentSplitter *PaymentSplitterCallerSession) TotalReleased(token common.Address) (*big.Int, error) {
	return _PaymentSplitter.Contract.TotalReleased(&_PaymentSplitter.CallOpts, token)
}

// TotalReleased0 is a free data retrieval call binding the contract method 0xe33b7de3.
//
// Solidity: function totalReleased() view returns(uint256)
func (_PaymentSplitter *PaymentSplitterCaller) TotalReleased0(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _PaymentSplitter.contract.Call(opts, &out, "totalReleased0")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalReleased0 is a free data retrieval call binding the contract method 0xe33b7de3.
//
// Solidity: function totalReleased() view returns(uint256)
func (_PaymentSplitter *PaymentSplitterSession) TotalReleased0() (*big.Int, error) {
	return _PaymentSplitter.Contract.TotalReleased0(&_PaymentSplitter.CallOpts)
}

// TotalReleased0 is a free data retrieval call binding the contract method 0xe33b7de3.
//
// Solidity: function totalReleased() view returns(uint256)
func (_PaymentSplitter *PaymentSplitterCallerSession) TotalReleased0() (*big.Int, error) {
	return _PaymentSplitter.Contract.TotalReleased0(&_PaymentSplitter.CallOpts)
}

// TotalShares is a free data retrieval call binding the contract method 0x3a98ef39.
//
// Solidity: function totalShares() view returns(uint256)
func (_PaymentSplitter *PaymentSplitterCaller) TotalShares(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _PaymentSplitter.contract.Call(opts, &out, "totalShares")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalShares is a free data retrieval call binding the contract method 0x3a98ef39.
//
// Solidity: function totalShares() view returns(uint256)
func (_PaymentSplitter *PaymentSplitterSession) TotalShares() (*big.Int, error) {
	return _PaymentSplitter.Contract.TotalShares(&_PaymentSplitter.CallOpts)
}

// TotalShares is a free data retrieval call binding the contract method 0x3a98ef39.
//
// Solidity: function totalShares() view returns(uint256)
func (_PaymentSplitter *PaymentSplitterCallerSession) TotalShares() (*big.Int, error) {
	return _PaymentSplitter.Contract.TotalShares(&_PaymentSplitter.CallOpts)
}

// Release is a paid mutator transaction binding the contract method 0x19165587.
//
// Solidity: function release(address account) returns()
func (_PaymentSplitter *PaymentSplitterTransactor) Release(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _PaymentSplitter.contract.Transact(opts, "release", account)
}

// Release is a paid mutator transaction binding the contract method 0x19165587.
//
// Solidity: function release(address account) returns()
func (_PaymentSplitter *PaymentSplitterSession) Release(account common.Address) (*types.Transaction, error) {
	return _PaymentSplitter.Contract.Release(&_PaymentSplitter.TransactOpts, account)
}

// Release is a paid mutator transaction binding the contract method 0x19165587.
//
// Solidity: function release(address account) returns()
func (_PaymentSplitter *PaymentSplitterTransactorSession) Release(account common.Address) (*types.Transaction, error) {
	return _PaymentSplitter.Contract.Release(&_PaymentSplitter.TransactOpts, account)
}

// Release0 is a paid mutator transaction binding the contract method 0x48b75044.
//
// Solidity: function release(address token, address account) returns()
func (_PaymentSplitter *PaymentSplitterTransactor) Release0(opts *bind.TransactOpts, token common.Address, account common.Address) (*types.Transaction, error) {
	return _PaymentSplitter.contract.Transact(opts, "release0", token, account)
}

// Release0 is a paid mutator transaction binding the contract method 0x48b75044.
//
// Solidity: function release(address token, address account) returns()
func (_PaymentSplitter *PaymentSplitterSession) Release0(token common.Address, account common.Address) (*types.Transaction, error) {
	return _PaymentSplitter.Contract.Release0(&_PaymentSplitter.TransactOpts, token, account)
}

// Release0 is a paid mutator transaction binding the contract method 0x48b75044.
//
// Solidity: function release(address token, address account) returns()
func (_PaymentSplitter *PaymentSplitterTransactorSession) Release0(token common.Address, account common.Address) (*types.Transaction, error) {
	return _PaymentSplitter.Contract.Release0(&_PaymentSplitter.TransactOpts, token, account)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_PaymentSplitter *PaymentSplitterTransactor) Receive(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PaymentSplitter.contract.RawTransact(opts, nil) // calldata is disallowed for receive function
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_PaymentSplitter *PaymentSplitterSession) Receive() (*types.Transaction, error) {
	return _PaymentSplitter.Contract.Receive(&_PaymentSplitter.TransactOpts)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_PaymentSplitter *PaymentSplitterTransactorSession) Receive() (*types.Transaction, error) {
	return _PaymentSplitter.Contract.Receive(&_PaymentSplitter.TransactOpts)
}

// PaymentSplitterERC20PaymentReleasedIterator is returned from FilterERC20PaymentReleased and is used to iterate over the raw logs and unpacked data for ERC20PaymentReleased events raised by the PaymentSplitter contract.
type PaymentSplitterERC20PaymentReleasedIterator struct {
	Event *PaymentSplitterERC20PaymentReleased // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PaymentSplitterERC20PaymentReleasedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PaymentSplitterERC20PaymentReleased)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PaymentSplitterERC20PaymentReleased)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PaymentSplitterERC20PaymentReleasedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PaymentSplitterERC20PaymentReleasedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PaymentSplitterERC20PaymentReleased represents a ERC20PaymentReleased event raised by the PaymentSplitter contract.
type PaymentSplitterERC20PaymentReleased struct {
	Token  common.Address
	To     common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterERC20PaymentReleased is a free log retrieval operation binding the contract event 0x3be5b7a71e84ed12875d241991c70855ac5817d847039e17a9d895c1ceb0f18a.
//
// Solidity: event ERC20PaymentReleased(address indexed token, address to, uint256 amount)
func (_PaymentSplitter *PaymentSplitterFilterer) FilterERC20PaymentReleased(opts *bind.FilterOpts, token []common.Address) (*PaymentSplitterERC20PaymentReleasedIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _PaymentSplitter.contract.FilterLogs(opts, "ERC20PaymentReleased", tokenRule)
	if err != nil {
		return nil, err
	}
	return &PaymentSplitterERC20PaymentReleasedIterator{contract: _PaymentSplitter.contract, event: "ERC20PaymentReleased", logs: logs, sub: sub}, nil
}

// WatchERC20PaymentReleased is a free log subscription operation binding the contract event 0x3be5b7a71e84ed12875d241991c70855ac5817d847039e17a9d895c1ceb0f18a.
//
// Solidity: event ERC20PaymentReleased(address indexed token, address to, uint256 amount)
func (_PaymentSplitter *PaymentSplitterFilterer) WatchERC20PaymentReleased(opts *bind.WatchOpts, sink chan<- *PaymentSplitterERC20PaymentReleased, token []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}

	logs, sub, err := _PaymentSplitter.contract.WatchLogs(opts, "ERC20PaymentReleased", tokenRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PaymentSplitterERC20PaymentReleased)
				if err := _PaymentSplitter.contract.UnpackLog(event, "ERC20PaymentReleased", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseERC20PaymentReleased is a log parse operation binding the contract event 0x3be5b7a71e84ed12875d241991c70855ac5817d847039e17a9d895c1ceb0f18a.
//
// Solidity: event ERC20PaymentReleased(address indexed token, address to, uint256 amount)
func (_PaymentSplitter *PaymentSplitterFilterer) ParseERC20PaymentReleased(log types.Log) (*PaymentSplitterERC20PaymentReleased, error) {
	event := new(PaymentSplitterERC20PaymentReleased)
	if err := _PaymentSplitter.contract.UnpackLog(event, "ERC20PaymentReleased", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PaymentSplitterPayeeAddedIterator is returned from FilterPayeeAdded and is used to iterate over the raw logs and unpacked data for PayeeAdded events raised by the PaymentSplitter contract.
type PaymentSplitterPayeeAddedIterator struct {
	Event *PaymentSplitterPayeeAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PaymentSplitterPayeeAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PaymentSplitterPayeeAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PaymentSplitterPayeeAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PaymentSplitterPayeeAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PaymentSplitterPayeeAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PaymentSplitterPayeeAdded represents a PayeeAdded event raised by the PaymentSplitter contract.
type PaymentSplitterPayeeAdded struct {
	Account common.Address
	Shares  *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPayeeAdded is a free log retrieval operation binding the contract event 0x40c340f65e17194d14ddddb073d3c9f888e3cb52b5aae0c6c7706b4fbc905fac.
//
// Solidity: event PayeeAdded(address account, uint256 shares)
func (_PaymentSplitter *PaymentSplitterFilterer) FilterPayeeAdded(opts *bind.FilterOpts) (*PaymentSplitterPayeeAddedIterator, error) {

	logs, sub, err := _PaymentSplitter.contract.FilterLogs(opts, "PayeeAdded")
	if err != nil {
		return nil, err
	}
	return &PaymentSplitterPayeeAddedIterator{contract: _PaymentSplitter.contract, event: "PayeeAdded", logs: logs, sub: sub}, nil
}

// WatchPayeeAdded is a free log subscription operation binding the contract event 0x40c340f65e17194d14ddddb073d3c9f888e3cb52b5aae0c6c7706b4fbc905fac.
//
// Solidity: event PayeeAdded(address account, uint256 shares)
func (_PaymentSplitter *PaymentSplitterFilterer) WatchPayeeAdded(opts *bind.WatchOpts, sink chan<- *PaymentSplitterPayeeAdded) (event.Subscription, error) {

	logs, sub, err := _PaymentSplitter.contract.WatchLogs(opts, "PayeeAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PaymentSplitterPayeeAdded)
				if err := _PaymentSplitter.contract.UnpackLog(event, "PayeeAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePayeeAdded is a log parse operation binding the contract event 0x40c340f65e17194d14ddddb073d3c9f888e3cb52b5aae0c6c7706b4fbc905fac.
//
// Solidity: event PayeeAdded(address account, uint256 shares)
func (_PaymentSplitter *PaymentSplitterFilterer) ParsePayeeAdded(log types.Log) (*PaymentSplitterPayeeAdded, error) {
	event := new(PaymentSplitterPayeeAdded)
	if err := _PaymentSplitter.contract.UnpackLog(event, "PayeeAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PaymentSplitterPaymentReceivedIterator is returned from FilterPaymentReceived and is used to iterate over the raw logs and unpacked data for PaymentReceived events raised by the PaymentSplitter contract.
type PaymentSplitterPaymentReceivedIterator struct {
	Event *PaymentSplitterPaymentReceived // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PaymentSplitterPaymentReceivedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PaymentSplitterPaymentReceived)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PaymentSplitterPaymentReceived)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PaymentSplitterPaymentReceivedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PaymentSplitterPaymentReceivedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PaymentSplitterPaymentReceived represents a PaymentReceived event raised by the PaymentSplitter contract.
type PaymentSplitterPaymentReceived struct {
	From   common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterPaymentReceived is a free log retrieval operation binding the contract event 0x6ef95f06320e7a25a04a175ca677b7052bdd97131872c2192525a629f51be770.
//
// Solidity: event PaymentReceived(address from, uint256 amount)
func (_PaymentSplitter *PaymentSplitterFilterer) FilterPaymentReceived(opts *bind.FilterOpts) (*PaymentSplitterPaymentReceivedIterator, error) {

	logs, sub, err := _PaymentSplitter.contract.FilterLogs(opts, "PaymentReceived")
	if err != nil {
		return nil, err
	}
	return &PaymentSplitterPaymentReceivedIterator{contract: _PaymentSplitter.contract, event: "PaymentReceived", logs: logs, sub: sub}, nil
}

// WatchPaymentReceived is a free log subscription operation binding the contract event 0x6ef95f06320e7a25a04a175ca677b7052bdd97131872c2192525a629f51be770.
//
// Solidity: event PaymentReceived(address from, uint256 amount)
func (_PaymentSplitter *PaymentSplitterFilterer) WatchPaymentReceived(opts *bind.WatchOpts, sink chan<- *PaymentSplitterPaymentReceived) (event.Subscription, error) {

	logs, sub, err := _PaymentSplitter.contract.WatchLogs(opts, "PaymentReceived")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PaymentSplitterPaymentReceived)
				if err := _PaymentSplitter.contract.UnpackLog(event, "PaymentReceived", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaymentReceived is a log parse operation binding the contract event 0x6ef95f06320e7a25a04a175ca677b7052bdd97131872c2192525a629f51be770.
//
// Solidity: event PaymentReceived(address from, uint256 amount)
func (_PaymentSplitter *PaymentSplitterFilterer) ParsePaymentReceived(log types.Log) (*PaymentSplitterPaymentReceived, error) {
	event := new(PaymentSplitterPaymentReceived)
	if err := _PaymentSplitter.contract.UnpackLog(event, "PaymentReceived", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PaymentSplitterPaymentReleasedIterator is returned from FilterPaymentReleased and is used to iterate over the raw logs and unpacked data for PaymentReleased events raised by the PaymentSplitter contract.
type PaymentSplitterPaymentReleasedIterator struct {
	Event *PaymentSplitterPaymentReleased // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PaymentSplitterPaymentReleasedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PaymentSplitterPaymentReleased)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PaymentSplitterPaymentReleased)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PaymentSplitterPaymentReleasedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PaymentSplitterPaymentReleasedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PaymentSplitterPaymentReleased represents a PaymentReleased event raised by the PaymentSplitter contract.
type PaymentSplitterPaymentReleased struct {
	To     common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterPaymentReleased is a free log retrieval operation binding the contract event 0xdf20fd1e76bc69d672e4814fafb2c449bba3a5369d8359adf9e05e6fde87b056.
//
// Solidity: event PaymentReleased(address to, uint256 amount)
func (_PaymentSplitter *PaymentSplitterFilterer) FilterPaymentReleased(opts *bind.FilterOpts) (*PaymentSplitterPaymentReleasedIterator, error) {

	logs, sub, err := _PaymentSplitter.contract.FilterLogs(opts, "PaymentReleased")
	if err != nil {
		return nil, err
	}
	return &PaymentSplitterPaymentReleasedIterator{contract: _PaymentSplitter.contract, event: "PaymentReleased", logs: logs, sub: sub}, nil
}

// WatchPaymentReleased is a free log subscription operation binding the contract event 0xdf20fd1e76bc69d672e4814fafb2c449bba3a5369d8359adf9e05e6fde87b056.
//
// Solidity: event PaymentReleased(address to, uint256 amount)
func (_PaymentSplitter *PaymentSplitterFilterer) WatchPaymentReleased(opts *bind.WatchOpts, sink chan<- *PaymentSplitterPaymentReleased) (event.Subscription, error) {

	logs, sub, err := _PaymentSplitter.contract.WatchLogs(opts, "PaymentReleased")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PaymentSplitterPaymentReleased)
				if err := _PaymentSplitter.contract.UnpackLog(event, "PaymentReleased", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaymentReleased is a log parse operation binding the contract event 0xdf20fd1e76bc69d672e4814fafb2c449bba3a5369d8359adf9e05e6fde87b056.
//
// Solidity: event PaymentReleased(address to, uint256 amount)
func (_PaymentSplitter *PaymentSplitterFilterer) ParsePaymentReleased(log types.Log) (*PaymentSplitterPaymentReleased, error) {
	event := new(PaymentSplitterPaymentReleased)
	if err := _PaymentSplitter.contract.UnpackLog(event, "PaymentReleased", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ReentrancyGuardMetaData contains all meta data concerning the ReentrancyGuard contract.
var ReentrancyGuardMetaData = &bind.MetaData{
	ABI: "[]",
}

// ReentrancyGuardABI is the input ABI used to generate the binding from.
// Deprecated: Use ReentrancyGuardMetaData.ABI instead.
var ReentrancyGuardABI = ReentrancyGuardMetaData.ABI

// ReentrancyGuard is an auto generated Go binding around an Ethereum contract.
type ReentrancyGuard struct {
	ReentrancyGuardCaller     // Read-only binding to the contract
	ReentrancyGuardTransactor // Write-only binding to the contract
	ReentrancyGuardFilterer   // Log filterer for contract events
}

// ReentrancyGuardCaller is an auto generated read-only Go binding around an Ethereum contract.
type ReentrancyGuardCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ReentrancyGuardTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ReentrancyGuardTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ReentrancyGuardFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ReentrancyGuardFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ReentrancyGuardSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ReentrancyGuardSession struct {
	Contract     *ReentrancyGuard  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ReentrancyGuardCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ReentrancyGuardCallerSession struct {
	Contract *ReentrancyGuardCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// ReentrancyGuardTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ReentrancyGuardTransactorSession struct {
	Contract     *ReentrancyGuardTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// ReentrancyGuardRaw is an auto generated low-level Go binding around an Ethereum contract.
type ReentrancyGuardRaw struct {
	Contract *ReentrancyGuard // Generic contract binding to access the raw methods on
}

// ReentrancyGuardCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ReentrancyGuardCallerRaw struct {
	Contract *ReentrancyGuardCaller // Generic read-only contract binding to access the raw methods on
}

// ReentrancyGuardTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ReentrancyGuardTransactorRaw struct {
	Contract *ReentrancyGuardTransactor // Generic write-only contract binding to access the raw methods on
}

// NewReentrancyGuard creates a new instance of ReentrancyGuard, bound to a specific deployed contract.
func NewReentrancyGuard(address common.Address, backend bind.ContractBackend) (*ReentrancyGuard, error) {
	contract, err := bindReentrancyGuard(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ReentrancyGuard{ReentrancyGuardCaller: ReentrancyGuardCaller{contract: contract}, ReentrancyGuardTransactor: ReentrancyGuardTransactor{contract: contract}, ReentrancyGuardFilterer: ReentrancyGuardFilterer{contract: contract}}, nil
}

// NewReentrancyGuardCaller creates a new read-only instance of ReentrancyGuard, bound to a specific deployed contract.
func NewReentrancyGuardCaller(address common.Address, caller bind.ContractCaller) (*ReentrancyGuardCaller, error) {
	contract, err := bindReentrancyGuard(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ReentrancyGuardCaller{contract: contract}, nil
}

// NewReentrancyGuardTransactor creates a new write-only instance of ReentrancyGuard, bound to a specific deployed contract.
func NewReentrancyGuardTransactor(address common.Address, transactor bind.ContractTransactor) (*ReentrancyGuardTransactor, error) {
	contract, err := bindReentrancyGuard(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ReentrancyGuardTransactor{contract: contract}, nil
}

// NewReentrancyGuardFilterer creates a new log filterer instance of ReentrancyGuard, bound to a specific deployed contract.
func NewReentrancyGuardFilterer(address common.Address, filterer bind.ContractFilterer) (*ReentrancyGuardFilterer, error) {
	contract, err := bindReentrancyGuard(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ReentrancyGuardFilterer{contract: contract}, nil
}

// bindReentrancyGuard binds a generic wrapper to an already deployed contract.
func bindReentrancyGuard(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ReentrancyGuardABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ReentrancyGuard *ReentrancyGuardRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ReentrancyGuard.Contract.ReentrancyGuardCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ReentrancyGuard *ReentrancyGuardRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ReentrancyGuard.Contract.ReentrancyGuardTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ReentrancyGuard *ReentrancyGuardRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ReentrancyGuard.Contract.ReentrancyGuardTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ReentrancyGuard *ReentrancyGuardCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ReentrancyGuard.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ReentrancyGuard *ReentrancyGuardTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ReentrancyGuard.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ReentrancyGuard *ReentrancyGuardTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ReentrancyGuard.Contract.contract.Transact(opts, method, params...)
}

// SafeERC20MetaData contains all meta data concerning the SafeERC20 contract.
var SafeERC20MetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212202a52bdfc967ecf786e43126174fbc63823564ac37db7431cb3589bc1fed456e064736f6c634300080a0033",
}

// SafeERC20ABI is the input ABI used to generate the binding from.
// Deprecated: Use SafeERC20MetaData.ABI instead.
var SafeERC20ABI = SafeERC20MetaData.ABI

// SafeERC20Bin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use SafeERC20MetaData.Bin instead.
var SafeERC20Bin = SafeERC20MetaData.Bin

// DeploySafeERC20 deploys a new Ethereum contract, binding an instance of SafeERC20 to it.
func DeploySafeERC20(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SafeERC20, error) {
	parsed, err := SafeERC20MetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(SafeERC20Bin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SafeERC20{SafeERC20Caller: SafeERC20Caller{contract: contract}, SafeERC20Transactor: SafeERC20Transactor{contract: contract}, SafeERC20Filterer: SafeERC20Filterer{contract: contract}}, nil
}

// SafeERC20 is an auto generated Go binding around an Ethereum contract.
type SafeERC20 struct {
	SafeERC20Caller     // Read-only binding to the contract
	SafeERC20Transactor // Write-only binding to the contract
	SafeERC20Filterer   // Log filterer for contract events
}

// SafeERC20Caller is an auto generated read-only Go binding around an Ethereum contract.
type SafeERC20Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeERC20Transactor is an auto generated write-only Go binding around an Ethereum contract.
type SafeERC20Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeERC20Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SafeERC20Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeERC20Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SafeERC20Session struct {
	Contract     *SafeERC20        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SafeERC20CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SafeERC20CallerSession struct {
	Contract *SafeERC20Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// SafeERC20TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SafeERC20TransactorSession struct {
	Contract     *SafeERC20Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// SafeERC20Raw is an auto generated low-level Go binding around an Ethereum contract.
type SafeERC20Raw struct {
	Contract *SafeERC20 // Generic contract binding to access the raw methods on
}

// SafeERC20CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SafeERC20CallerRaw struct {
	Contract *SafeERC20Caller // Generic read-only contract binding to access the raw methods on
}

// SafeERC20TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SafeERC20TransactorRaw struct {
	Contract *SafeERC20Transactor // Generic write-only contract binding to access the raw methods on
}

// NewSafeERC20 creates a new instance of SafeERC20, bound to a specific deployed contract.
func NewSafeERC20(address common.Address, backend bind.ContractBackend) (*SafeERC20, error) {
	contract, err := bindSafeERC20(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SafeERC20{SafeERC20Caller: SafeERC20Caller{contract: contract}, SafeERC20Transactor: SafeERC20Transactor{contract: contract}, SafeERC20Filterer: SafeERC20Filterer{contract: contract}}, nil
}

// NewSafeERC20Caller creates a new read-only instance of SafeERC20, bound to a specific deployed contract.
func NewSafeERC20Caller(address common.Address, caller bind.ContractCaller) (*SafeERC20Caller, error) {
	contract, err := bindSafeERC20(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SafeERC20Caller{contract: contract}, nil
}

// NewSafeERC20Transactor creates a new write-only instance of SafeERC20, bound to a specific deployed contract.
func NewSafeERC20Transactor(address common.Address, transactor bind.ContractTransactor) (*SafeERC20Transactor, error) {
	contract, err := bindSafeERC20(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SafeERC20Transactor{contract: contract}, nil
}

// NewSafeERC20Filterer creates a new log filterer instance of SafeERC20, bound to a specific deployed contract.
func NewSafeERC20Filterer(address common.Address, filterer bind.ContractFilterer) (*SafeERC20Filterer, error) {
	contract, err := bindSafeERC20(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SafeERC20Filterer{contract: contract}, nil
}

// bindSafeERC20 binds a generic wrapper to an already deployed contract.
func bindSafeERC20(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(SafeERC20ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeERC20 *SafeERC20Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SafeERC20.Contract.SafeERC20Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeERC20 *SafeERC20Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeERC20.Contract.SafeERC20Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeERC20 *SafeERC20Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeERC20.Contract.SafeERC20Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeERC20 *SafeERC20CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SafeERC20.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeERC20 *SafeERC20TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeERC20.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeERC20 *SafeERC20TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeERC20.Contract.contract.Transact(opts, method, params...)
}

// StringsMetaData contains all meta data concerning the Strings contract.
var StringsMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122089b777a646b844bd910a81cc896f82ec50632b741f4e95db2005c5031e3bf64464736f6c634300080a0033",
}

// StringsABI is the input ABI used to generate the binding from.
// Deprecated: Use StringsMetaData.ABI instead.
var StringsABI = StringsMetaData.ABI

// StringsBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use StringsMetaData.Bin instead.
var StringsBin = StringsMetaData.Bin

// DeployStrings deploys a new Ethereum contract, binding an instance of Strings to it.
func DeployStrings(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Strings, error) {
	parsed, err := StringsMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(StringsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Strings{StringsCaller: StringsCaller{contract: contract}, StringsTransactor: StringsTransactor{contract: contract}, StringsFilterer: StringsFilterer{contract: contract}}, nil
}

// Strings is an auto generated Go binding around an Ethereum contract.
type Strings struct {
	StringsCaller     // Read-only binding to the contract
	StringsTransactor // Write-only binding to the contract
	StringsFilterer   // Log filterer for contract events
}

// StringsCaller is an auto generated read-only Go binding around an Ethereum contract.
type StringsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StringsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type StringsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StringsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type StringsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StringsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type StringsSession struct {
	Contract     *Strings          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// StringsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type StringsCallerSession struct {
	Contract *StringsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// StringsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type StringsTransactorSession struct {
	Contract     *StringsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// StringsRaw is an auto generated low-level Go binding around an Ethereum contract.
type StringsRaw struct {
	Contract *Strings // Generic contract binding to access the raw methods on
}

// StringsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type StringsCallerRaw struct {
	Contract *StringsCaller // Generic read-only contract binding to access the raw methods on
}

// StringsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type StringsTransactorRaw struct {
	Contract *StringsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewStrings creates a new instance of Strings, bound to a specific deployed contract.
func NewStrings(address common.Address, backend bind.ContractBackend) (*Strings, error) {
	contract, err := bindStrings(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Strings{StringsCaller: StringsCaller{contract: contract}, StringsTransactor: StringsTransactor{contract: contract}, StringsFilterer: StringsFilterer{contract: contract}}, nil
}

// NewStringsCaller creates a new read-only instance of Strings, bound to a specific deployed contract.
func NewStringsCaller(address common.Address, caller bind.ContractCaller) (*StringsCaller, error) {
	contract, err := bindStrings(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &StringsCaller{contract: contract}, nil
}

// NewStringsTransactor creates a new write-only instance of Strings, bound to a specific deployed contract.
func NewStringsTransactor(address common.Address, transactor bind.ContractTransactor) (*StringsTransactor, error) {
	contract, err := bindStrings(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &StringsTransactor{contract: contract}, nil
}

// NewStringsFilterer creates a new log filterer instance of Strings, bound to a specific deployed contract.
func NewStringsFilterer(address common.Address, filterer bind.ContractFilterer) (*StringsFilterer, error) {
	contract, err := bindStrings(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &StringsFilterer{contract: contract}, nil
}

// bindStrings binds a generic wrapper to an already deployed contract.
func bindStrings(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(StringsABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Strings *StringsRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Strings.Contract.StringsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Strings *StringsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Strings.Contract.StringsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Strings *StringsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Strings.Contract.StringsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Strings *StringsCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Strings.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Strings *StringsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Strings.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Strings *StringsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Strings.Contract.contract.Transact(opts, method, params...)
}

// ValidatorHelpersMetaData contains all meta data concerning the ValidatorHelpers contract.
var ValidatorHelpersMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"Validator\",\"name\":\"data\",\"type\":\"uint24\"}],\"name\":\"freeSpace\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Validator\",\"name\":\"data\",\"type\":\"uint24\"}],\"name\":\"getNodeIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Validator\",\"name\":\"data\",\"type\":\"uint24\"}],\"name\":\"hasAcceptableUptime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"Validator\",\"name\":\"data\",\"type\":\"uint24\"}],\"name\":\"hasTimeRemaining\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"nodeIndex\",\"type\":\"uint24\"},{\"internalType\":\"bool\",\"name\":\"hasUptime\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasSpace\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"hundredsOfAvax\",\"type\":\"uint24\"}],\"name\":\"packValidator\",\"outputs\":[{\"internalType\":\"Validator\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"08dc4a3f": "freeSpace(uint24)",
		"31b7d82e": "getNodeIndex(uint24)",
		"b242d719": "hasAcceptableUptime(uint24)",
		"a5c062cb": "hasTimeRemaining(uint24)",
		"8e4fa317": "packValidator(uint24,bool,bool,uint24)",
	},
	Bin: "0x6102dc61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100615760003560e01c806308dc4a3f1461006657806331b7d82e1461008c5780638e4fa317146100a4578063a5c062cb146100cb578063b242d719146100ee575b600080fd5b6100796100743660046101d9565b610101565b6040519081526020015b60405180910390f35b61007961009a3660046101d9565b600a1c610fff1690565b6100b76100b236600461020b565b610122565b60405162ffffff9091168152602001610083565b6100de6100d93660046101d9565b610180565b6040519015158152602001610083565b6100de6100fc3660046101d9565b6101aa565b60006103ff821661011b8168056bc75e2d63100000610263565b9392505050565b60006110008562ffffff161061013a5761013a610290565b6104008262ffffff161061015057610150610290565b81841561015d5762800000175b83156101695762400000175b6403fffffc00600a87901b16179050949350505050565b6000601682901c6003811690600190811690811461019f5760006101a2565b60015b949350505050565b60006001601783901c8116908190811461019f5760006101a2565b62ffffff811681146101d657600080fd5b50565b6000602082840312156101eb57600080fd5b813561011b816101c5565b8035801515811461020657600080fd5b919050565b6000806000806080858703121561022157600080fd5b843561022c816101c5565b935061023a602086016101f6565b9250610248604086016101f6565b91506060850135610258816101c5565b939692955090935050565b600081600019048311821515161561028b57634e487b7160e01b600052601160045260246000fd5b500290565b634e487b7160e01b600052600160045260246000fdfea2646970667358221220a8612287d82efcd7b83618131512ce7829841678d300f3dfb1bbdf1e647a404e64736f6c634300080a0033",
}

// ValidatorHelpersABI is the input ABI used to generate the binding from.
// Deprecated: Use ValidatorHelpersMetaData.ABI instead.
var ValidatorHelpersABI = ValidatorHelpersMetaData.ABI

// Deprecated: Use ValidatorHelpersMetaData.Sigs instead.
// ValidatorHelpersFuncSigs maps the 4-byte function signature to its string representation.
var ValidatorHelpersFuncSigs = ValidatorHelpersMetaData.Sigs

// ValidatorHelpersBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ValidatorHelpersMetaData.Bin instead.
var ValidatorHelpersBin = ValidatorHelpersMetaData.Bin

// DeployValidatorHelpers deploys a new Ethereum contract, binding an instance of ValidatorHelpers to it.
func DeployValidatorHelpers(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ValidatorHelpers, error) {
	parsed, err := ValidatorHelpersMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ValidatorHelpersBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ValidatorHelpers{ValidatorHelpersCaller: ValidatorHelpersCaller{contract: contract}, ValidatorHelpersTransactor: ValidatorHelpersTransactor{contract: contract}, ValidatorHelpersFilterer: ValidatorHelpersFilterer{contract: contract}}, nil
}

// ValidatorHelpers is an auto generated Go binding around an Ethereum contract.
type ValidatorHelpers struct {
	ValidatorHelpersCaller     // Read-only binding to the contract
	ValidatorHelpersTransactor // Write-only binding to the contract
	ValidatorHelpersFilterer   // Log filterer for contract events
}

// ValidatorHelpersCaller is an auto generated read-only Go binding around an Ethereum contract.
type ValidatorHelpersCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorHelpersTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ValidatorHelpersTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorHelpersFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ValidatorHelpersFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValidatorHelpersSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ValidatorHelpersSession struct {
	Contract     *ValidatorHelpers // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ValidatorHelpersCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ValidatorHelpersCallerSession struct {
	Contract *ValidatorHelpersCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts           // Call options to use throughout this session
}

// ValidatorHelpersTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ValidatorHelpersTransactorSession struct {
	Contract     *ValidatorHelpersTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts           // Transaction auth options to use throughout this session
}

// ValidatorHelpersRaw is an auto generated low-level Go binding around an Ethereum contract.
type ValidatorHelpersRaw struct {
	Contract *ValidatorHelpers // Generic contract binding to access the raw methods on
}

// ValidatorHelpersCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ValidatorHelpersCallerRaw struct {
	Contract *ValidatorHelpersCaller // Generic read-only contract binding to access the raw methods on
}

// ValidatorHelpersTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ValidatorHelpersTransactorRaw struct {
	Contract *ValidatorHelpersTransactor // Generic write-only contract binding to access the raw methods on
}

// NewValidatorHelpers creates a new instance of ValidatorHelpers, bound to a specific deployed contract.
func NewValidatorHelpers(address common.Address, backend bind.ContractBackend) (*ValidatorHelpers, error) {
	contract, err := bindValidatorHelpers(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ValidatorHelpers{ValidatorHelpersCaller: ValidatorHelpersCaller{contract: contract}, ValidatorHelpersTransactor: ValidatorHelpersTransactor{contract: contract}, ValidatorHelpersFilterer: ValidatorHelpersFilterer{contract: contract}}, nil
}

// NewValidatorHelpersCaller creates a new read-only instance of ValidatorHelpers, bound to a specific deployed contract.
func NewValidatorHelpersCaller(address common.Address, caller bind.ContractCaller) (*ValidatorHelpersCaller, error) {
	contract, err := bindValidatorHelpers(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ValidatorHelpersCaller{contract: contract}, nil
}

// NewValidatorHelpersTransactor creates a new write-only instance of ValidatorHelpers, bound to a specific deployed contract.
func NewValidatorHelpersTransactor(address common.Address, transactor bind.ContractTransactor) (*ValidatorHelpersTransactor, error) {
	contract, err := bindValidatorHelpers(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ValidatorHelpersTransactor{contract: contract}, nil
}

// NewValidatorHelpersFilterer creates a new log filterer instance of ValidatorHelpers, bound to a specific deployed contract.
func NewValidatorHelpersFilterer(address common.Address, filterer bind.ContractFilterer) (*ValidatorHelpersFilterer, error) {
	contract, err := bindValidatorHelpers(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ValidatorHelpersFilterer{contract: contract}, nil
}

// bindValidatorHelpers binds a generic wrapper to an already deployed contract.
func bindValidatorHelpers(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ValidatorHelpersABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ValidatorHelpers *ValidatorHelpersRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ValidatorHelpers.Contract.ValidatorHelpersCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ValidatorHelpers *ValidatorHelpersRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorHelpers.Contract.ValidatorHelpersTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ValidatorHelpers *ValidatorHelpersRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ValidatorHelpers.Contract.ValidatorHelpersTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ValidatorHelpers *ValidatorHelpersCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ValidatorHelpers.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ValidatorHelpers *ValidatorHelpersTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ValidatorHelpers.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ValidatorHelpers *ValidatorHelpersTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ValidatorHelpers.Contract.contract.Transact(opts, method, params...)
}

// FreeSpace is a free data retrieval call binding the contract method 0x08dc4a3f.
//
// Solidity: function freeSpace(uint24 data) pure returns(uint256)
func (_ValidatorHelpers *ValidatorHelpersCaller) FreeSpace(opts *bind.CallOpts, data *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _ValidatorHelpers.contract.Call(opts, &out, "freeSpace", data)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// FreeSpace is a free data retrieval call binding the contract method 0x08dc4a3f.
//
// Solidity: function freeSpace(uint24 data) pure returns(uint256)
func (_ValidatorHelpers *ValidatorHelpersSession) FreeSpace(data *big.Int) (*big.Int, error) {
	return _ValidatorHelpers.Contract.FreeSpace(&_ValidatorHelpers.CallOpts, data)
}

// FreeSpace is a free data retrieval call binding the contract method 0x08dc4a3f.
//
// Solidity: function freeSpace(uint24 data) pure returns(uint256)
func (_ValidatorHelpers *ValidatorHelpersCallerSession) FreeSpace(data *big.Int) (*big.Int, error) {
	return _ValidatorHelpers.Contract.FreeSpace(&_ValidatorHelpers.CallOpts, data)
}

// GetNodeIndex is a free data retrieval call binding the contract method 0x31b7d82e.
//
// Solidity: function getNodeIndex(uint24 data) pure returns(uint256)
func (_ValidatorHelpers *ValidatorHelpersCaller) GetNodeIndex(opts *bind.CallOpts, data *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _ValidatorHelpers.contract.Call(opts, &out, "getNodeIndex", data)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetNodeIndex is a free data retrieval call binding the contract method 0x31b7d82e.
//
// Solidity: function getNodeIndex(uint24 data) pure returns(uint256)
func (_ValidatorHelpers *ValidatorHelpersSession) GetNodeIndex(data *big.Int) (*big.Int, error) {
	return _ValidatorHelpers.Contract.GetNodeIndex(&_ValidatorHelpers.CallOpts, data)
}

// GetNodeIndex is a free data retrieval call binding the contract method 0x31b7d82e.
//
// Solidity: function getNodeIndex(uint24 data) pure returns(uint256)
func (_ValidatorHelpers *ValidatorHelpersCallerSession) GetNodeIndex(data *big.Int) (*big.Int, error) {
	return _ValidatorHelpers.Contract.GetNodeIndex(&_ValidatorHelpers.CallOpts, data)
}

// HasAcceptableUptime is a free data retrieval call binding the contract method 0xb242d719.
//
// Solidity: function hasAcceptableUptime(uint24 data) pure returns(bool)
func (_ValidatorHelpers *ValidatorHelpersCaller) HasAcceptableUptime(opts *bind.CallOpts, data *big.Int) (bool, error) {
	var out []interface{}
	err := _ValidatorHelpers.contract.Call(opts, &out, "hasAcceptableUptime", data)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// HasAcceptableUptime is a free data retrieval call binding the contract method 0xb242d719.
//
// Solidity: function hasAcceptableUptime(uint24 data) pure returns(bool)
func (_ValidatorHelpers *ValidatorHelpersSession) HasAcceptableUptime(data *big.Int) (bool, error) {
	return _ValidatorHelpers.Contract.HasAcceptableUptime(&_ValidatorHelpers.CallOpts, data)
}

// HasAcceptableUptime is a free data retrieval call binding the contract method 0xb242d719.
//
// Solidity: function hasAcceptableUptime(uint24 data) pure returns(bool)
func (_ValidatorHelpers *ValidatorHelpersCallerSession) HasAcceptableUptime(data *big.Int) (bool, error) {
	return _ValidatorHelpers.Contract.HasAcceptableUptime(&_ValidatorHelpers.CallOpts, data)
}

// HasTimeRemaining is a free data retrieval call binding the contract method 0xa5c062cb.
//
// Solidity: function hasTimeRemaining(uint24 data) pure returns(bool)
func (_ValidatorHelpers *ValidatorHelpersCaller) HasTimeRemaining(opts *bind.CallOpts, data *big.Int) (bool, error) {
	var out []interface{}
	err := _ValidatorHelpers.contract.Call(opts, &out, "hasTimeRemaining", data)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// HasTimeRemaining is a free data retrieval call binding the contract method 0xa5c062cb.
//
// Solidity: function hasTimeRemaining(uint24 data) pure returns(bool)
func (_ValidatorHelpers *ValidatorHelpersSession) HasTimeRemaining(data *big.Int) (bool, error) {
	return _ValidatorHelpers.Contract.HasTimeRemaining(&_ValidatorHelpers.CallOpts, data)
}

// HasTimeRemaining is a free data retrieval call binding the contract method 0xa5c062cb.
//
// Solidity: function hasTimeRemaining(uint24 data) pure returns(bool)
func (_ValidatorHelpers *ValidatorHelpersCallerSession) HasTimeRemaining(data *big.Int) (bool, error) {
	return _ValidatorHelpers.Contract.HasTimeRemaining(&_ValidatorHelpers.CallOpts, data)
}

// PackValidator is a free data retrieval call binding the contract method 0x8e4fa317.
//
// Solidity: function packValidator(uint24 nodeIndex, bool hasUptime, bool hasSpace, uint24 hundredsOfAvax) pure returns(uint24)
func (_ValidatorHelpers *ValidatorHelpersCaller) PackValidator(opts *bind.CallOpts, nodeIndex *big.Int, hasUptime bool, hasSpace bool, hundredsOfAvax *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _ValidatorHelpers.contract.Call(opts, &out, "packValidator", nodeIndex, hasUptime, hasSpace, hundredsOfAvax)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// PackValidator is a free data retrieval call binding the contract method 0x8e4fa317.
//
// Solidity: function packValidator(uint24 nodeIndex, bool hasUptime, bool hasSpace, uint24 hundredsOfAvax) pure returns(uint24)
func (_ValidatorHelpers *ValidatorHelpersSession) PackValidator(nodeIndex *big.Int, hasUptime bool, hasSpace bool, hundredsOfAvax *big.Int) (*big.Int, error) {
	return _ValidatorHelpers.Contract.PackValidator(&_ValidatorHelpers.CallOpts, nodeIndex, hasUptime, hasSpace, hundredsOfAvax)
}

// PackValidator is a free data retrieval call binding the contract method 0x8e4fa317.
//
// Solidity: function packValidator(uint24 nodeIndex, bool hasUptime, bool hasSpace, uint24 hundredsOfAvax) pure returns(uint24)
func (_ValidatorHelpers *ValidatorHelpersCallerSession) PackValidator(nodeIndex *big.Int, hasUptime bool, hasSpace bool, hundredsOfAvax *big.Int) (*big.Int, error) {
	return _ValidatorHelpers.Contract.PackValidator(&_ValidatorHelpers.CallOpts, nodeIndex, hasUptime, hasSpace, hundredsOfAvax)
}

// StAVAXMetaData contains all meta data concerning the StAVAX contract.
var StAVAXMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalControlled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"avaxAmount\",\"type\":\"uint256\"}],\"name\":\"avaxToStAVAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolControlledAVAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalControlled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stAvaxAmount\",\"type\":\"uint256\"}],\"name\":\"stAVAXToAVAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Sigs: map[string]string{
		"dd62ed3e": "allowance(address,address)",
		"095ea7b3": "approve(address,uint256)",
		"85990de5": "avaxToStAVAX(uint256,uint256)",
		"70a08231": "balanceOf(address)",
		"313ce567": "decimals()",
		"a457c2d7": "decreaseAllowance(address,uint256)",
		"39509351": "increaseAllowance(address,uint256)",
		"06fdde03": "name()",
		"a23b4965": "protocolControlledAVAX()",
		"bc56684a": "stAVAXToAVAX(uint256,uint256)",
		"95d89b41": "symbol()",
		"18160ddd": "totalSupply()",
		"a9059cbb": "transfer(address,uint256)",
		"23b872dd": "transferFrom(address,address,uint256)",
	},
}

// StAVAXABI is the input ABI used to generate the binding from.
// Deprecated: Use StAVAXMetaData.ABI instead.
var StAVAXABI = StAVAXMetaData.ABI

// Deprecated: Use StAVAXMetaData.Sigs instead.
// StAVAXFuncSigs maps the 4-byte function signature to its string representation.
var StAVAXFuncSigs = StAVAXMetaData.Sigs

// StAVAX is an auto generated Go binding around an Ethereum contract.
type StAVAX struct {
	StAVAXCaller     // Read-only binding to the contract
	StAVAXTransactor // Write-only binding to the contract
	StAVAXFilterer   // Log filterer for contract events
}

// StAVAXCaller is an auto generated read-only Go binding around an Ethereum contract.
type StAVAXCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StAVAXTransactor is an auto generated write-only Go binding around an Ethereum contract.
type StAVAXTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StAVAXFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type StAVAXFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StAVAXSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type StAVAXSession struct {
	Contract     *StAVAX           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// StAVAXCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type StAVAXCallerSession struct {
	Contract *StAVAXCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// StAVAXTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type StAVAXTransactorSession struct {
	Contract     *StAVAXTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// StAVAXRaw is an auto generated low-level Go binding around an Ethereum contract.
type StAVAXRaw struct {
	Contract *StAVAX // Generic contract binding to access the raw methods on
}

// StAVAXCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type StAVAXCallerRaw struct {
	Contract *StAVAXCaller // Generic read-only contract binding to access the raw methods on
}

// StAVAXTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type StAVAXTransactorRaw struct {
	Contract *StAVAXTransactor // Generic write-only contract binding to access the raw methods on
}

// NewStAVAX creates a new instance of StAVAX, bound to a specific deployed contract.
func NewStAVAX(address common.Address, backend bind.ContractBackend) (*StAVAX, error) {
	contract, err := bindStAVAX(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &StAVAX{StAVAXCaller: StAVAXCaller{contract: contract}, StAVAXTransactor: StAVAXTransactor{contract: contract}, StAVAXFilterer: StAVAXFilterer{contract: contract}}, nil
}

// NewStAVAXCaller creates a new read-only instance of StAVAX, bound to a specific deployed contract.
func NewStAVAXCaller(address common.Address, caller bind.ContractCaller) (*StAVAXCaller, error) {
	contract, err := bindStAVAX(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &StAVAXCaller{contract: contract}, nil
}

// NewStAVAXTransactor creates a new write-only instance of StAVAX, bound to a specific deployed contract.
func NewStAVAXTransactor(address common.Address, transactor bind.ContractTransactor) (*StAVAXTransactor, error) {
	contract, err := bindStAVAX(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &StAVAXTransactor{contract: contract}, nil
}

// NewStAVAXFilterer creates a new log filterer instance of StAVAX, bound to a specific deployed contract.
func NewStAVAXFilterer(address common.Address, filterer bind.ContractFilterer) (*StAVAXFilterer, error) {
	contract, err := bindStAVAX(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &StAVAXFilterer{contract: contract}, nil
}

// bindStAVAX binds a generic wrapper to an already deployed contract.
func bindStAVAX(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(StAVAXABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_StAVAX *StAVAXRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _StAVAX.Contract.StAVAXCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_StAVAX *StAVAXRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _StAVAX.Contract.StAVAXTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_StAVAX *StAVAXRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _StAVAX.Contract.StAVAXTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_StAVAX *StAVAXCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _StAVAX.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_StAVAX *StAVAXTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _StAVAX.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_StAVAX *StAVAXTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _StAVAX.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_StAVAX *StAVAXCaller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _StAVAX.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_StAVAX *StAVAXSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _StAVAX.Contract.Allowance(&_StAVAX.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_StAVAX *StAVAXCallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _StAVAX.Contract.Allowance(&_StAVAX.CallOpts, owner, spender)
}

// AvaxToStAVAX is a free data retrieval call binding the contract method 0x85990de5.
//
// Solidity: function avaxToStAVAX(uint256 totalControlled, uint256 avaxAmount) view returns(uint256)
func (_StAVAX *StAVAXCaller) AvaxToStAVAX(opts *bind.CallOpts, totalControlled *big.Int, avaxAmount *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _StAVAX.contract.Call(opts, &out, "avaxToStAVAX", totalControlled, avaxAmount)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// AvaxToStAVAX is a free data retrieval call binding the contract method 0x85990de5.
//
// Solidity: function avaxToStAVAX(uint256 totalControlled, uint256 avaxAmount) view returns(uint256)
func (_StAVAX *StAVAXSession) AvaxToStAVAX(totalControlled *big.Int, avaxAmount *big.Int) (*big.Int, error) {
	return _StAVAX.Contract.AvaxToStAVAX(&_StAVAX.CallOpts, totalControlled, avaxAmount)
}

// AvaxToStAVAX is a free data retrieval call binding the contract method 0x85990de5.
//
// Solidity: function avaxToStAVAX(uint256 totalControlled, uint256 avaxAmount) view returns(uint256)
func (_StAVAX *StAVAXCallerSession) AvaxToStAVAX(totalControlled *big.Int, avaxAmount *big.Int) (*big.Int, error) {
	return _StAVAX.Contract.AvaxToStAVAX(&_StAVAX.CallOpts, totalControlled, avaxAmount)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_StAVAX *StAVAXCaller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _StAVAX.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_StAVAX *StAVAXSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _StAVAX.Contract.BalanceOf(&_StAVAX.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_StAVAX *StAVAXCallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _StAVAX.Contract.BalanceOf(&_StAVAX.CallOpts, account)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_StAVAX *StAVAXCaller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _StAVAX.contract.Call(opts, &out, "decimals")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_StAVAX *StAVAXSession) Decimals() (uint8, error) {
	return _StAVAX.Contract.Decimals(&_StAVAX.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_StAVAX *StAVAXCallerSession) Decimals() (uint8, error) {
	return _StAVAX.Contract.Decimals(&_StAVAX.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_StAVAX *StAVAXCaller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _StAVAX.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_StAVAX *StAVAXSession) Name() (string, error) {
	return _StAVAX.Contract.Name(&_StAVAX.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_StAVAX *StAVAXCallerSession) Name() (string, error) {
	return _StAVAX.Contract.Name(&_StAVAX.CallOpts)
}

// ProtocolControlledAVAX is a free data retrieval call binding the contract method 0xa23b4965.
//
// Solidity: function protocolControlledAVAX() view returns(uint256)
func (_StAVAX *StAVAXCaller) ProtocolControlledAVAX(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _StAVAX.contract.Call(opts, &out, "protocolControlledAVAX")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// ProtocolControlledAVAX is a free data retrieval call binding the contract method 0xa23b4965.
//
// Solidity: function protocolControlledAVAX() view returns(uint256)
func (_StAVAX *StAVAXSession) ProtocolControlledAVAX() (*big.Int, error) {
	return _StAVAX.Contract.ProtocolControlledAVAX(&_StAVAX.CallOpts)
}

// ProtocolControlledAVAX is a free data retrieval call binding the contract method 0xa23b4965.
//
// Solidity: function protocolControlledAVAX() view returns(uint256)
func (_StAVAX *StAVAXCallerSession) ProtocolControlledAVAX() (*big.Int, error) {
	return _StAVAX.Contract.ProtocolControlledAVAX(&_StAVAX.CallOpts)
}

// StAVAXToAVAX is a free data retrieval call binding the contract method 0xbc56684a.
//
// Solidity: function stAVAXToAVAX(uint256 totalControlled, uint256 stAvaxAmount) view returns(uint256)
func (_StAVAX *StAVAXCaller) StAVAXToAVAX(opts *bind.CallOpts, totalControlled *big.Int, stAvaxAmount *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _StAVAX.contract.Call(opts, &out, "stAVAXToAVAX", totalControlled, stAvaxAmount)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// StAVAXToAVAX is a free data retrieval call binding the contract method 0xbc56684a.
//
// Solidity: function stAVAXToAVAX(uint256 totalControlled, uint256 stAvaxAmount) view returns(uint256)
func (_StAVAX *StAVAXSession) StAVAXToAVAX(totalControlled *big.Int, stAvaxAmount *big.Int) (*big.Int, error) {
	return _StAVAX.Contract.StAVAXToAVAX(&_StAVAX.CallOpts, totalControlled, stAvaxAmount)
}

// StAVAXToAVAX is a free data retrieval call binding the contract method 0xbc56684a.
//
// Solidity: function stAVAXToAVAX(uint256 totalControlled, uint256 stAvaxAmount) view returns(uint256)
func (_StAVAX *StAVAXCallerSession) StAVAXToAVAX(totalControlled *big.Int, stAvaxAmount *big.Int) (*big.Int, error) {
	return _StAVAX.Contract.StAVAXToAVAX(&_StAVAX.CallOpts, totalControlled, stAvaxAmount)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_StAVAX *StAVAXCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _StAVAX.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_StAVAX *StAVAXSession) Symbol() (string, error) {
	return _StAVAX.Contract.Symbol(&_StAVAX.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_StAVAX *StAVAXCallerSession) Symbol() (string, error) {
	return _StAVAX.Contract.Symbol(&_StAVAX.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_StAVAX *StAVAXCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _StAVAX.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_StAVAX *StAVAXSession) TotalSupply() (*big.Int, error) {
	return _StAVAX.Contract.TotalSupply(&_StAVAX.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_StAVAX *StAVAXCallerSession) TotalSupply() (*big.Int, error) {
	return _StAVAX.Contract.TotalSupply(&_StAVAX.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_StAVAX *StAVAXTransactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _StAVAX.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_StAVAX *StAVAXSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _StAVAX.Contract.Approve(&_StAVAX.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_StAVAX *StAVAXTransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _StAVAX.Contract.Approve(&_StAVAX.TransactOpts, spender, amount)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_StAVAX *StAVAXTransactor) DecreaseAllowance(opts *bind.TransactOpts, spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _StAVAX.contract.Transact(opts, "decreaseAllowance", spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_StAVAX *StAVAXSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _StAVAX.Contract.DecreaseAllowance(&_StAVAX.TransactOpts, spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_StAVAX *StAVAXTransactorSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _StAVAX.Contract.DecreaseAllowance(&_StAVAX.TransactOpts, spender, subtractedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_StAVAX *StAVAXTransactor) IncreaseAllowance(opts *bind.TransactOpts, spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _StAVAX.contract.Transact(opts, "increaseAllowance", spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_StAVAX *StAVAXSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _StAVAX.Contract.IncreaseAllowance(&_StAVAX.TransactOpts, spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_StAVAX *StAVAXTransactorSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _StAVAX.Contract.IncreaseAllowance(&_StAVAX.TransactOpts, spender, addedValue)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_StAVAX *StAVAXTransactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _StAVAX.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_StAVAX *StAVAXSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _StAVAX.Contract.Transfer(&_StAVAX.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_StAVAX *StAVAXTransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _StAVAX.Contract.Transfer(&_StAVAX.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_StAVAX *StAVAXTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _StAVAX.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_StAVAX *StAVAXSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _StAVAX.Contract.TransferFrom(&_StAVAX.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_StAVAX *StAVAXTransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _StAVAX.Contract.TransferFrom(&_StAVAX.TransactOpts, from, to, amount)
}

// StAVAXApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the StAVAX contract.
type StAVAXApprovalIterator struct {
	Event *StAVAXApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StAVAXApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StAVAXApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StAVAXApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StAVAXApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StAVAXApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StAVAXApproval represents a Approval event raised by the StAVAX contract.
type StAVAXApproval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_StAVAX *StAVAXFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*StAVAXApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _StAVAX.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &StAVAXApprovalIterator{contract: _StAVAX.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_StAVAX *StAVAXFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *StAVAXApproval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _StAVAX.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StAVAXApproval)
				if err := _StAVAX.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_StAVAX *StAVAXFilterer) ParseApproval(log types.Log) (*StAVAXApproval, error) {
	event := new(StAVAXApproval)
	if err := _StAVAX.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// StAVAXInitializedIterator is returned from FilterInitialized and is used to iterate over the raw logs and unpacked data for Initialized events raised by the StAVAX contract.
type StAVAXInitializedIterator struct {
	Event *StAVAXInitialized // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StAVAXInitializedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StAVAXInitialized)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StAVAXInitialized)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StAVAXInitializedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StAVAXInitializedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StAVAXInitialized represents a Initialized event raised by the StAVAX contract.
type StAVAXInitialized struct {
	Version uint8
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInitialized is a free log retrieval operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_StAVAX *StAVAXFilterer) FilterInitialized(opts *bind.FilterOpts) (*StAVAXInitializedIterator, error) {

	logs, sub, err := _StAVAX.contract.FilterLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return &StAVAXInitializedIterator{contract: _StAVAX.contract, event: "Initialized", logs: logs, sub: sub}, nil
}

// WatchInitialized is a free log subscription operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_StAVAX *StAVAXFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *StAVAXInitialized) (event.Subscription, error) {

	logs, sub, err := _StAVAX.contract.WatchLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StAVAXInitialized)
				if err := _StAVAX.contract.UnpackLog(event, "Initialized", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInitialized is a log parse operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_StAVAX *StAVAXFilterer) ParseInitialized(log types.Log) (*StAVAXInitialized, error) {
	event := new(StAVAXInitialized)
	if err := _StAVAX.contract.UnpackLog(event, "Initialized", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// StAVAXTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the StAVAX contract.
type StAVAXTransferIterator struct {
	Event *StAVAXTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StAVAXTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StAVAXTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StAVAXTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StAVAXTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StAVAXTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StAVAXTransfer represents a Transfer event raised by the StAVAX contract.
type StAVAXTransfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_StAVAX *StAVAXFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*StAVAXTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _StAVAX.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &StAVAXTransferIterator{contract: _StAVAX.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_StAVAX *StAVAXFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *StAVAXTransfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _StAVAX.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StAVAXTransfer)
				if err := _StAVAX.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_StAVAX *StAVAXFilterer) ParseTransfer(log types.Log) (*StAVAXTransfer, error) {
	event := new(StAVAXTransfer)
	if err := _StAVAX.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
